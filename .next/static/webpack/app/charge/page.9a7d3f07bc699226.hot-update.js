"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/charge/page",{

/***/ "(app-pages-browser)/./hooks/useTimerStatus.ts":
/*!*********************************!*\
  !*** ./hooks/useTimerStatus.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTimerStatus: () => (/* binding */ useTimerStatus)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _useChargingStatus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useChargingStatus */ \"(app-pages-browser)/./hooks/useChargingStatus.ts\");\n/* harmony import */ var _useBMSData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useBMSData */ \"(app-pages-browser)/./hooks/useBMSData.ts\");\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// export function useTimerStatus() {\n//   const [endTime, setEndTime] = useState<number | null>(null);\n//   // Function to set the timer\n//   const setTimer = (durationMinutes: number) => {\n//     const currentTime = Date.now();\n//     const calculatedEndTime = currentTime + durationMinutes * 60 * 1000; // Convert minutes to milliseconds\n//     setEndTime(calculatedEndTime);\n//     localStorage.setItem(\"chargingEndTime\", calculatedEndTime.toString()); // Persist data\n//   };\n//   // Retrieve stored endTime on component mount\n//   useEffect(() => {\n//     const storedEndTime = localStorage.getItem(\"chargingEndTime\");\n//     if (storedEndTime) {\n//       setEndTime(Number(storedEndTime));\n//     }\n//   }, []);\n//   return {\n//     endTime,\n//     setTimer,\n//   };\n// }\n//pushing to done page\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { useRouter } from \"next/navigation\";\n// import { useChargingStatus } from \"./useChargingStatus\"; // ✅ Import charging status hook\n// export function useTimerStatus() {\n//   const [endTime, setEndTime] = useState<number | null>(null);\n//   const router = useRouter();\n//   const { isChargingInitialized } = useChargingStatus(); // ✅ Check if charging is active\n//   // Function to set the timer\n//   const setTimer = (durationMinutes: number) => {\n//     const currentTime = Date.now();\n//     const calculatedEndTime = currentTime + durationMinutes * 60 * 1000; // Convert minutes to milliseconds\n//     setEndTime(calculatedEndTime);\n//     localStorage.setItem(\"chargingEndTime\", calculatedEndTime.toString()); // Persist data\n//   };\n//   // Retrieve stored endTime on component mount\n//   useEffect(() => {\n//     const storedEndTime = localStorage.getItem(\"chargingEndTime\");\n//     if (storedEndTime) {\n//       setEndTime(Number(storedEndTime));\n//     }\n//   }, []);\n//   // ✅ Automatically redirect when timer reaches zero AND charging is active\n//   useEffect(() => {\n//     if (!endTime || !isChargingInitialized) return; // ✅ Prevent flicker issue\n//     const checkTime = () => {\n//       const now = Date.now();\n//       if (now >= endTime && isChargingInitialized) {\n//         console.log(\"⏰ Timer expired! Redirecting to /done...\");\n//         router.replace(\"/done\"); // ✅ Redirect only when charging is active\n//       }\n//     };\n//     const interval = setInterval(checkTime, 1000);\n//     checkTime(); // Run immediately\n//     return () => clearInterval(interval);\n//   }, [endTime, isChargingInitialized, router]);\n//   return {\n//     endTime,\n//     setTimer,\n//   };\n// }\n//pause and resumne\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { useRouter } from \"next/navigation\";\n// import { useChargingStatus } from \"./useChargingStatus\";\n// import { useBMSData } from \"./useBMSData\"; // ✅ Import BMS data hook\n// export function useTimerStatus() {\n//   const [endTime, setEndTime] = useState<number | null>(null);\n//   const [remainingTime, setRemainingTime] = useState<number | null>(null);\n//   const [isPaused, setIsPaused] = useState(false); // ✅ Track pause state\n//   const router = useRouter();\n//   const { isChargingInitialized } = useChargingStatus();\n//   const { bmsData } = useBMSData(); // ✅ Get FOD & misalignment status\n//   // Function to set the timer\n//   const setTimer = (durationMinutes: number) => {\n//     const currentTime = Date.now();\n//     const calculatedEndTime = currentTime + durationMinutes * 60 * 1000;\n//     setEndTime(calculatedEndTime);\n//     setRemainingTime(durationMinutes * 60 * 1000);\n//     localStorage.setItem(\"chargingEndTime\", calculatedEndTime.toString());\n//   };\n//   // Retrieve stored endTime on component mount\n//   useEffect(() => {\n//     const storedEndTime = localStorage.getItem(\"chargingEndTime\");\n//     if (storedEndTime) {\n//       setEndTime(Number(storedEndTime));\n//     }\n//   }, []);\n//   // ✅ Handle pause and resume logic\n//   useEffect(() => {\n//     if (bmsData?.isFOD || bmsData?.isMiss ) {\n//       if (!isPaused) {\n//         setIsPaused(true);\n//         setRemainingTime((prev) => (endTime ? endTime - Date.now() : prev)); // Store remaining time\n//         setEndTime(null); // Pause the countdown\n//       }\n//     } else {\n//       if (isPaused) {\n//         setIsPaused(false);\n//         if (remainingTime !== null) {\n//           const newEndTime = Date.now() + remainingTime;\n//           setEndTime(newEndTime);\n//           localStorage.setItem(\"chargingEndTime\", newEndTime.toString());\n//         }\n//       }\n//     }\n//   }, [bmsData?.isFOD, bmsData?.isMiss]);\n//   // ✅ Timer countdown logic\n//   useEffect(() => {\n//     if (!endTime || !isChargingInitialized || isPaused) return;\n//     const checkTime = () => {\n//       const now = Date.now();\n//       if (now >= endTime && isChargingInitialized) {\n//         console.log(\"⏰ Timer expired! Redirecting to /done...\");\n//         router.replace(\"/done\");\n//       }\n//     };\n//     const interval = setInterval(checkTime, 1000);\n//     checkTime();\n//     return () => clearInterval(interval);\n//   }, [endTime, isChargingInitialized, isPaused, router]);\n//   return {\n//     endTime,\n//     setTimer,\n//     isPaused,\n//   };\n// }\n//counter\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { useRouter } from \"next/navigation\";\n// import { useChargingStatus } from \"./useChargingStatus\";\n// import { useBMSData } from \"./useBMSData\"; // ✅ Import BMS data hook\n// export function useTimerStatus() {\n//   const [endTime, setEndTime] = useState<number | null>(null);\n//   const [remainingTime, setRemainingTime] = useState<number | null>(null);\n//   const [isPaused, setIsPaused] = useState(true);\n//   const router = useRouter();\n//   const { updateChargingStatus, isChargingInitialized } = useChargingStatus(); // ✅ Update charging state\n//   const { bmsData } = useBMSData(); // ✅ Get FOD & misalignment status\n//   // Function to set the timer\n//   const setTimer = (durationMinutes: number) => {\n//     const currentTime = Date.now();\n//     const calculatedEndTime = currentTime + durationMinutes * 60 * 1000;\n//     setEndTime(calculatedEndTime);\n//     setRemainingTime(durationMinutes * 60 * 1000);\n//     localStorage.setItem(\"chargingEndTime\", calculatedEndTime.toString());\n//     updateChargingStatus(true); // ✅ Start charging when timer starts\n//   };\n//   // Retrieve stored endTime on component mount\n//   useEffect(() => {\n//     const storedEndTime = localStorage.getItem(\"chargingEndTime\");\n//     if (storedEndTime) {\n//       setEndTime(Number(storedEndTime));\n//     }\n//   }, []);\n//   // ✅ Handle pause and resume logic\n//   useEffect(() => {\n//     const shouldPause = bmsData?.isFOD || bmsData?.isMiss || !bmsData?.isReceiverCoilDetected;\n//     if (shouldPause && !isPaused) {\n//       // Pause the timer\n//       setIsPaused(true);\n//       setRemainingTime(endTime ? Math.max(endTime - Date.now(), 0) : remainingTime);\n//       setEndTime(null); // Stop the countdown\n//       updateChargingStatus(false); // ✅ Stop charging when paused\n//     } else if (!shouldPause && isPaused && remainingTime !== null) {\n//       // Resume the timer\n//       setIsPaused(false);\n//       const newEndTime = Date.now() + remainingTime;\n//       setEndTime(newEndTime);\n//       localStorage.setItem(\"chargingEndTime\", newEndTime.toString());\n//       updateChargingStatus(true); // ✅ Resume charging\n//     }\n//   }, [bmsData?.isFOD, bmsData?.isMiss, bmsData?.isReceiverCoilDetected]);\n//   // ✅ Timer countdown logic\n//   useEffect(() => {\n//     if (!endTime || !isChargingInitialized || isPaused) return;\n//     const checkTime = () => {\n//       const now = Date.now();\n//       if (now >= endTime && isChargingInitialized) {\n//         console.log(\"⏰ Timer expired! Redirecting to /done...\");\n//         router.replace(\"/done\");\n//       }\n//     };\n//     const interval = setInterval(checkTime, 1000);\n//     checkTime();\n//     return () => clearInterval(interval);\n//   }, [endTime, isChargingInitialized, isPaused, router]);\n//   return {\n//     endTime,\n//     setTimer,\n//     isPaused,\n//   };\n// }\n//after app building\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { useRouter } from \"next/navigation\";\n// import { useChargingStatus } from \"./useChargingStatus\";\n// import { useBMSData } from \"./useBMSData\";\n// export function useTimerStatus() {\n//   const [endTime, setEndTime] = useState<number | null>(null);\n//   const [remainingTime, setRemainingTime] = useState<number | null>(null);\n//   const [isPaused, setIsPaused] = useState(true);\n//   const router = useRouter();\n//   const { updateChargingStatus, isChargingInitialized } = useChargingStatus();\n//   const { bmsData } = useBMSData();\n//   // Set a timer with duration in minutes\n//   const setTimer = (durationMinutes: number) => {\n//     const currentTime = Date.now();\n//     const calculatedEndTime = currentTime + durationMinutes * 60 * 1000;\n//     setEndTime(calculatedEndTime);\n//     setRemainingTime(durationMinutes * 60 * 1000);\n//     localStorage.setItem(\"chargingEndTime\", calculatedEndTime.toString());\n//     updateChargingStatus(true); // Start charging\n//     setIsPaused(false);\n//   };\n//   // Load endTime from localStorage when hook mounts\n//   useEffect(() => {\n//     const storedEndTime = localStorage.getItem(\"chargingEndTime\");\n//     if (storedEndTime) {\n//       const parsedEndTime = Number(storedEndTime);\n//       const currentTime = Date.now();\n//       const timeLeft = parsedEndTime - currentTime;\n//       if (timeLeft > 0) {\n//         setEndTime(parsedEndTime);\n//         setRemainingTime(timeLeft);\n//         setIsPaused(false);\n//       } else {\n//         localStorage.removeItem(\"chargingEndTime\");\n//         router.replace(\"/done\");\n//       }\n//     }\n//   }, [router]);\n//   // Pause/resume based on FOD, misalignment, or receiver coil detection\n//   // useEffect(() => {\n//   //   const shouldPause =\n//   //     bmsData?.isFOD || bmsData?.isMiss || !bmsData?.isReceiverCoilDetected;\n//   //   if (shouldPause && !isPaused) {\n//   //     // Pause\n//   //     const now = Date.now();\n//   //     setIsPaused(true);\n//   //     if (endTime) {\n//   //       const timeLeft = Math.max(endTime - now, 0);\n//   //       setRemainingTime(timeLeft);\n//   //       setEndTime(null);\n//   //     }\n//   //     updateChargingStatus(false);\n//   //   } else if (!shouldPause && isPaused && remainingTime !== null) {\n//   //     // Resume\n//   //     if (remainingTime <= 0) {\n//   //       localStorage.removeItem(\"chargingEndTime\");\n//   //       router.replace(\"/done\");\n//   //       return;\n//   //     }\n//   //     const newEndTime = Date.now() + remainingTime;\n//   //     setEndTime(newEndTime);\n//   //     localStorage.setItem(\"chargingEndTime\", newEndTime.toString());\n//   //     setIsPaused(false);\n//   //     updateChargingStatus(true);\n//   //   }\n//   // }, [\n//   //   bmsData?.isFOD,\n//   //   bmsData?.isMiss,\n//   //   bmsData?.isReceiverCoilDetected,\n//   //   isPaused,\n//   //   endTime,\n//   //   remainingTime,\n//   //   router,\n//   //   updateChargingStatus,\n//   // ]);\n// useEffect(() => {\n//   const shouldPause =\n//     bmsData?.isFOD || bmsData?.isMiss || !bmsData?.isReceiverCoilDetected;\n//   const now = Date.now();\n//   if (shouldPause && !isPaused) {\n//     // 🔴 Pause logic\n//     setIsPaused(true);\n//     if (endTime) {\n//       const timeLeft = Math.max(endTime - now, 0);\n//       setRemainingTime(timeLeft);\n//       setEndTime(null);\n//     }\n//     updateChargingStatus(false); // Optional: await if you want to guarantee state sync\n//   }\n//   else if (!shouldPause && isPaused) {\n//     // 🟢 Resume logic\n//     const safeRemaining = remainingTime ?? (endTime ? Math.max(endTime - now, 0) : 0);\n//     if (safeRemaining <= 0) {\n//       localStorage.removeItem(\"chargingEndTime\");\n//       updateChargingStatus(false).then(() => {\n//         // router.replace(\"/done\");\n//       });\n//       return;\n//     }\n//     const newEndTime = now + safeRemaining;\n//     setEndTime(newEndTime);\n//     localStorage.setItem(\"chargingEndTime\", newEndTime.toString());\n//     setRemainingTime(null); // Clear after using\n//     setIsPaused(false);\n//     updateChargingStatus(true);\n//   }\n// }, [\n//   bmsData?.isFOD,\n//   bmsData?.isMiss,\n//   bmsData?.isReceiverCoilDetected,\n//   isPaused,\n//   endTime,\n//   remainingTime,\n//   router,\n//   updateChargingStatus,\n// ]);\n//   // Countdown timer - redirect when complete\n//   useEffect(() => {\n//     if (!endTime || !isChargingInitialized || isPaused) return;\n//     const interval = setInterval(() => {\n//       const now = Date.now();\n//       if (now >= endTime) {\n//         localStorage.removeItem(\"chargingEndTime\");\n//         // router.replace(\"/done\");\n//       }\n//     }, 1000);\n//     return () => clearInterval(interval);\n//   }, [endTime, isChargingInitialized, isPaused, router]);\n//   return {\n//     endTime,\n//     setTimer,\n//     isPaused,\n//   };\n// }\n///inal fix\n/* __next_internal_client_entry_do_not_use__ useTimerStatus auto */ \n\n\n // ✅ Import BMS data hook\nfunction useTimerStatus() {\n    const [endTime, setEndTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [remainingTime, setRemainingTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isPaused, setIsPaused] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.useRouter)();\n    const { updateChargingStatus, isChargingInitialized } = (0,_useChargingStatus__WEBPACK_IMPORTED_MODULE_2__.useChargingStatus)(); // ✅ Update charging state\n    const { bmsData } = (0,_useBMSData__WEBPACK_IMPORTED_MODULE_3__.useBMSData)(); // ✅ Get FOD & misalignment status\n    // Function to set the timer\n    const setTimer = (durationMinutes)=>{\n        const currentTime = Date.now();\n        const calculatedEndTime = currentTime + durationMinutes * 60 * 1000;\n        setEndTime(calculatedEndTime);\n        setRemainingTime(durationMinutes * 60 * 1000);\n        localStorage.setItem(\"chargingEndTime\", calculatedEndTime.toString());\n        updateChargingStatus(true); // ✅ Start charging when timer starts\n    };\n    // Retrieve stored endTime on component mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimerStatus.useEffect\": ()=>{\n            const storedEndTime = localStorage.getItem(\"chargingEndTime\");\n            if (storedEndTime) {\n                setEndTime(Number(storedEndTime));\n            }\n        }\n    }[\"useTimerStatus.useEffect\"], []);\n    // ✅ Handle pause and resume logic\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimerStatus.useEffect\": ()=>{\n            const isFOD = !!(bmsData === null || bmsData === void 0 ? void 0 : bmsData.isFOD);\n            const isMiss = !!(bmsData === null || bmsData === void 0 ? void 0 : bmsData.isMiss);\n            const isReceiverDetected = !!(bmsData === null || bmsData === void 0 ? void 0 : bmsData.isReceiverCoilDetected);\n            const shouldPause = isFOD || isMiss || !isReceiverDetected;\n            const now = Date.now();\n            if (shouldPause && !isPaused) {\n                console.log(\"⏸ Pausing timer\");\n                setIsPaused(true);\n                if (endTime) {\n                    const timeLeft = Math.max(endTime - now, 0);\n                    setRemainingTime(timeLeft);\n                    setEndTime(null); // This triggers cleanup of the timer effect\n                }\n                updateChargingStatus(false);\n            }\n            if (!shouldPause && isPaused && remainingTime) {\n                console.log(\"▶️ Resuming timer\");\n                const newEndTime = now + remainingTime;\n                setEndTime(newEndTime);\n                setRemainingTime(null);\n                setIsPaused(false);\n                updateChargingStatus(true);\n                localStorage.setItem(\"chargingEndTime\", newEndTime.toString());\n            }\n        }\n    }[\"useTimerStatus.useEffect\"], [\n        bmsData === null || bmsData === void 0 ? void 0 : bmsData.isFOD,\n        bmsData === null || bmsData === void 0 ? void 0 : bmsData.isMiss,\n        bmsData === null || bmsData === void 0 ? void 0 : bmsData.isReceiverCoilDetected,\n        isPaused,\n        endTime,\n        remainingTime\n    ]);\n    // ✅ Timer countdown logic\n    const intervalRef = useRef(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimerStatus.useEffect\": ()=>{\n            if (!endTime || isPaused || !isChargingInitialized) {\n                console.log(\"⏸ Timer not active:\", {\n                    endTime,\n                    isPaused,\n                    isChargingInitialized\n                });\n                if (intervalRef.current) {\n                    clearInterval(intervalRef.current);\n                    intervalRef.current = null;\n                    console.log(\"🧹 Interval cleared due to pause or missing state.\");\n                }\n                return;\n            }\n            console.log(\"🕒 Starting interval. End time:\", new Date(endTime).toLocaleTimeString());\n            const checkTime = {\n                \"useTimerStatus.useEffect.checkTime\": ()=>{\n                    const now = Date.now();\n                    if (now >= endTime) {\n                        console.log(\"⏰ Timer expired! Redirecting...\");\n                        updateChargingStatus(false).then({\n                            \"useTimerStatus.useEffect.checkTime\": ()=>{\n                                router.replace(\"/done\");\n                            }\n                        }[\"useTimerStatus.useEffect.checkTime\"]);\n                        clearInterval(intervalRef.current);\n                        intervalRef.current = null;\n                    }\n                }\n            }[\"useTimerStatus.useEffect.checkTime\"];\n            intervalRef.current = setInterval(checkTime, 1000);\n            checkTime(); // run once immediately\n            return ({\n                \"useTimerStatus.useEffect\": ()=>{\n                    if (intervalRef.current) {\n                        clearInterval(intervalRef.current);\n                        intervalRef.current = null;\n                        console.log(\"🧹 Cleaning up timer on unmount or re-run\");\n                    }\n                }\n            })[\"useTimerStatus.useEffect\"];\n        }\n    }[\"useTimerStatus.useEffect\"], [\n        endTime,\n        isPaused,\n        isChargingInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTimerStatus.useEffect\": ()=>{\n            console.log(\"DEBUG -> endTime:\", endTime);\n            console.log(\"DEBUG -> isChargingInitialized:\", isChargingInitialized);\n            console.log(\"DEBUG -> isPaused:\", isPaused);\n        }\n    }[\"useTimerStatus.useEffect\"], [\n        endTime,\n        isChargingInitialized,\n        isPaused\n    ]);\n    return {\n        endTime,\n        setTimer,\n        isPaused\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVRpbWVyU3RhdHVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLGdCQUFnQjtBQUVoQiwrQ0FBK0M7QUFFL0MscUNBQXFDO0FBQ3JDLGlFQUFpRTtBQUVqRSxpQ0FBaUM7QUFDakMsb0RBQW9EO0FBQ3BELHNDQUFzQztBQUN0Qyw4R0FBOEc7QUFDOUcscUNBQXFDO0FBQ3JDLDZGQUE2RjtBQUM3RixPQUFPO0FBRVAsa0RBQWtEO0FBQ2xELHNCQUFzQjtBQUN0QixxRUFBcUU7QUFDckUsMkJBQTJCO0FBQzNCLDJDQUEyQztBQUMzQyxRQUFRO0FBQ1IsWUFBWTtBQUVaLGFBQWE7QUFDYixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLE9BQU87QUFDUCxJQUFJO0FBQ0osc0JBQXNCO0FBQ3RCLGdCQUFnQjtBQUVoQiwrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DLDRGQUE0RjtBQUU1RixxQ0FBcUM7QUFDckMsaUVBQWlFO0FBQ2pFLGdDQUFnQztBQUNoQyw0RkFBNEY7QUFFNUYsaUNBQWlDO0FBQ2pDLG9EQUFvRDtBQUNwRCxzQ0FBc0M7QUFDdEMsOEdBQThHO0FBQzlHLHFDQUFxQztBQUNyQyw2RkFBNkY7QUFDN0YsT0FBTztBQUVQLGtEQUFrRDtBQUNsRCxzQkFBc0I7QUFDdEIscUVBQXFFO0FBQ3JFLDJCQUEyQjtBQUMzQiwyQ0FBMkM7QUFDM0MsUUFBUTtBQUNSLFlBQVk7QUFFWiwrRUFBK0U7QUFDL0Usc0JBQXNCO0FBQ3RCLGlGQUFpRjtBQUVqRixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLHVEQUF1RDtBQUN2RCxtRUFBbUU7QUFDbkUsOEVBQThFO0FBQzlFLFVBQVU7QUFDVixTQUFTO0FBRVQscURBQXFEO0FBQ3JELHNDQUFzQztBQUV0Qyw0Q0FBNEM7QUFDNUMsa0RBQWtEO0FBRWxELGFBQWE7QUFDYixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLE9BQU87QUFDUCxJQUFJO0FBQ0osbUJBQW1CO0FB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T0FBTyxHQUFHTSxZQUFZSCxXQUFXO1lBQzdDQSxhQUFhLHVCQUF1QjtZQUVwQzs0Q0FBTztvQkFDTCxJQUFJTCxZQUFZRSxPQUFPLEVBQUU7d0JBQ3ZCQyxjQUFjSCxZQUFZRSxPQUFPO3dCQUNqQ0YsWUFBWUUsT0FBTyxHQUFHO3dCQUN0QlIsUUFBUUMsR0FBRyxDQUFDO29CQUNkO2dCQUNGOztRQUNGO21DQUFHO1FBQUM1QjtRQUFTSTtRQUFVSTtLQUFzQjtJQUczQ2IsZ0RBQVNBO29DQUFDO1lBQ1JnQyxRQUFRQyxHQUFHLENBQUMscUJBQXFCNUI7WUFDakMyQixRQUFRQyxHQUFHLENBQUMsbUNBQW1DcEI7WUFDL0NtQixRQUFRQyxHQUFHLENBQUMsc0JBQXNCeEI7UUFDcEM7bUNBQUc7UUFBQ0o7UUFBU1E7UUFBdUJKO0tBQVM7SUFJN0MsT0FBTztRQUNMSjtRQUNBVTtRQUNBTjtJQUVGO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxjb2RpbmdcXGRhc2ggZHluYW1pY3NcXGRhc2hib2FyZHNcXExvY2FsYmFja2VuZFxcY2hhcmdpbmctc3lzdGVtXFxob29rc1xcdXNlVGltZXJTdGF0dXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gXCJ1c2UgY2xpZW50XCI7XHJcblxyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gdXNlVGltZXJTdGF0dXMoKSB7XHJcbi8vICAgY29uc3QgW2VuZFRpbWUsIHNldEVuZFRpbWVdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcblxyXG4vLyAgIC8vIEZ1bmN0aW9uIHRvIHNldCB0aGUgdGltZXJcclxuLy8gICBjb25zdCBzZXRUaW1lciA9IChkdXJhdGlvbk1pbnV0ZXM6IG51bWJlcikgPT4ge1xyXG4vLyAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xyXG4vLyAgICAgY29uc3QgY2FsY3VsYXRlZEVuZFRpbWUgPSBjdXJyZW50VGltZSArIGR1cmF0aW9uTWludXRlcyAqIDYwICogMTAwMDsgLy8gQ29udmVydCBtaW51dGVzIHRvIG1pbGxpc2Vjb25kc1xyXG4vLyAgICAgc2V0RW5kVGltZShjYWxjdWxhdGVkRW5kVGltZSk7XHJcbi8vICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImNoYXJnaW5nRW5kVGltZVwiLCBjYWxjdWxhdGVkRW5kVGltZS50b1N0cmluZygpKTsgLy8gUGVyc2lzdCBkYXRhXHJcbi8vICAgfTtcclxuXHJcbi8vICAgLy8gUmV0cmlldmUgc3RvcmVkIGVuZFRpbWUgb24gY29tcG9uZW50IG1vdW50XHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIGNvbnN0IHN0b3JlZEVuZFRpbWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImNoYXJnaW5nRW5kVGltZVwiKTtcclxuLy8gICAgIGlmIChzdG9yZWRFbmRUaW1lKSB7XHJcbi8vICAgICAgIHNldEVuZFRpbWUoTnVtYmVyKHN0b3JlZEVuZFRpbWUpKTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbXSk7XHJcblxyXG4vLyAgIHJldHVybiB7XHJcbi8vICAgICBlbmRUaW1lLFxyXG4vLyAgICAgc2V0VGltZXIsXHJcbi8vICAgfTtcclxuLy8gfVxyXG4vL3B1c2hpbmcgdG8gZG9uZSBwYWdlXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG5cclxuLy8gaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG4vLyBpbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tIFwibmV4dC9uYXZpZ2F0aW9uXCI7XHJcbi8vIGltcG9ydCB7IHVzZUNoYXJnaW5nU3RhdHVzIH0gZnJvbSBcIi4vdXNlQ2hhcmdpbmdTdGF0dXNcIjsgLy8g4pyFIEltcG9ydCBjaGFyZ2luZyBzdGF0dXMgaG9va1xyXG5cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIHVzZVRpbWVyU3RhdHVzKCkge1xyXG4vLyAgIGNvbnN0IFtlbmRUaW1lLCBzZXRFbmRUaW1lXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG4vLyAgIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xyXG4vLyAgIGNvbnN0IHsgaXNDaGFyZ2luZ0luaXRpYWxpemVkIH0gPSB1c2VDaGFyZ2luZ1N0YXR1cygpOyAvLyDinIUgQ2hlY2sgaWYgY2hhcmdpbmcgaXMgYWN0aXZlXHJcblxyXG4vLyAgIC8vIEZ1bmN0aW9uIHRvIHNldCB0aGUgdGltZXJcclxuLy8gICBjb25zdCBzZXRUaW1lciA9IChkdXJhdGlvbk1pbnV0ZXM6IG51bWJlcikgPT4ge1xyXG4vLyAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xyXG4vLyAgICAgY29uc3QgY2FsY3VsYXRlZEVuZFRpbWUgPSBjdXJyZW50VGltZSArIGR1cmF0aW9uTWludXRlcyAqIDYwICogMTAwMDsgLy8gQ29udmVydCBtaW51dGVzIHRvIG1pbGxpc2Vjb25kc1xyXG4vLyAgICAgc2V0RW5kVGltZShjYWxjdWxhdGVkRW5kVGltZSk7XHJcbi8vICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImNoYXJnaW5nRW5kVGltZVwiLCBjYWxjdWxhdGVkRW5kVGltZS50b1N0cmluZygpKTsgLy8gUGVyc2lzdCBkYXRhXHJcbi8vICAgfTtcclxuXHJcbi8vICAgLy8gUmV0cmlldmUgc3RvcmVkIGVuZFRpbWUgb24gY29tcG9uZW50IG1vdW50XHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIGNvbnN0IHN0b3JlZEVuZFRpbWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImNoYXJnaW5nRW5kVGltZVwiKTtcclxuLy8gICAgIGlmIChzdG9yZWRFbmRUaW1lKSB7XHJcbi8vICAgICAgIHNldEVuZFRpbWUoTnVtYmVyKHN0b3JlZEVuZFRpbWUpKTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbXSk7XHJcblxyXG4vLyAgIC8vIOKchSBBdXRvbWF0aWNhbGx5IHJlZGlyZWN0IHdoZW4gdGltZXIgcmVhY2hlcyB6ZXJvIEFORCBjaGFyZ2luZyBpcyBhY3RpdmVcclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFlbmRUaW1lIHx8ICFpc0NoYXJnaW5nSW5pdGlhbGl6ZWQpIHJldHVybjsgLy8g4pyFIFByZXZlbnQgZmxpY2tlciBpc3N1ZVxyXG5cclxuLy8gICAgIGNvbnN0IGNoZWNrVGltZSA9ICgpID0+IHtcclxuLy8gICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuLy8gICAgICAgaWYgKG5vdyA+PSBlbmRUaW1lICYmIGlzQ2hhcmdpbmdJbml0aWFsaXplZCkge1xyXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKFwi4o+wIFRpbWVyIGV4cGlyZWQhIFJlZGlyZWN0aW5nIHRvIC9kb25lLi4uXCIpO1xyXG4vLyAgICAgICAgIHJvdXRlci5yZXBsYWNlKFwiL2RvbmVcIik7IC8vIOKchSBSZWRpcmVjdCBvbmx5IHdoZW4gY2hhcmdpbmcgaXMgYWN0aXZlXHJcbi8vICAgICAgIH1cclxuLy8gICAgIH07XHJcblxyXG4vLyAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjaGVja1RpbWUsIDEwMDApO1xyXG4vLyAgICAgY2hlY2tUaW1lKCk7IC8vIFJ1biBpbW1lZGlhdGVseVxyXG5cclxuLy8gICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuLy8gICB9LCBbZW5kVGltZSwgaXNDaGFyZ2luZ0luaXRpYWxpemVkLCByb3V0ZXJdKTtcclxuXHJcbi8vICAgcmV0dXJuIHtcclxuLy8gICAgIGVuZFRpbWUsXHJcbi8vICAgICBzZXRUaW1lcixcclxuLy8gICB9O1xyXG4vLyB9XHJcbi8vcGF1c2UgYW5kIHJlc3VtbmVcclxuLy8gXCJ1c2UgY2xpZW50XCI7XHJcblxyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcbi8vIGltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcclxuLy8gaW1wb3J0IHsgdXNlQ2hhcmdpbmdTdGF0dXMgfSBmcm9tIFwiLi91c2VDaGFyZ2luZ1N0YXR1c1wiO1xyXG4vLyBpbXBvcnQgeyB1c2VCTVNEYXRhIH0gZnJvbSBcIi4vdXNlQk1TRGF0YVwiOyAvLyDinIUgSW1wb3J0IEJNUyBkYXRhIGhvb2tcclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiB1c2VUaW1lclN0YXR1cygpIHtcclxuLy8gICBjb25zdCBbZW5kVGltZSwgc2V0RW5kVGltZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbcmVtYWluaW5nVGltZSwgc2V0UmVtYWluaW5nVGltZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbaXNQYXVzZWQsIHNldElzUGF1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTsgLy8g4pyFIFRyYWNrIHBhdXNlIHN0YXRlXHJcbi8vICAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XHJcbi8vICAgY29uc3QgeyBpc0NoYXJnaW5nSW5pdGlhbGl6ZWQgfSA9IHVzZUNoYXJnaW5nU3RhdHVzKCk7XHJcbi8vICAgY29uc3QgeyBibXNEYXRhIH0gPSB1c2VCTVNEYXRhKCk7IC8vIOKchSBHZXQgRk9EICYgbWlzYWxpZ25tZW50IHN0YXR1c1xyXG5cclxuLy8gICAvLyBGdW5jdGlvbiB0byBzZXQgdGhlIHRpbWVyXHJcbi8vICAgY29uc3Qgc2V0VGltZXIgPSAoZHVyYXRpb25NaW51dGVzOiBudW1iZXIpID0+IHtcclxuLy8gICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcclxuLy8gICAgIGNvbnN0IGNhbGN1bGF0ZWRFbmRUaW1lID0gY3VycmVudFRpbWUgKyBkdXJhdGlvbk1pbnV0ZXMgKiA2MCAqIDEwMDA7XHJcbi8vICAgICBzZXRFbmRUaW1lKGNhbGN1bGF0ZWRFbmRUaW1lKTtcclxuLy8gICAgIHNldFJlbWFpbmluZ1RpbWUoZHVyYXRpb25NaW51dGVzICogNjAgKiAxMDAwKTtcclxuLy8gICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiY2hhcmdpbmdFbmRUaW1lXCIsIGNhbGN1bGF0ZWRFbmRUaW1lLnRvU3RyaW5nKCkpO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIC8vIFJldHJpZXZlIHN0b3JlZCBlbmRUaW1lIG9uIGNvbXBvbmVudCBtb3VudFxyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBjb25zdCBzdG9yZWRFbmRUaW1lID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJjaGFyZ2luZ0VuZFRpbWVcIik7XHJcbi8vICAgICBpZiAoc3RvcmVkRW5kVGltZSkge1xyXG4vLyAgICAgICBzZXRFbmRUaW1lKE51bWJlcihzdG9yZWRFbmRUaW1lKSk7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW10pO1xyXG5cclxuLy8gICAvLyDinIUgSGFuZGxlIHBhdXNlIGFuZCByZXN1bWUgbG9naWNcclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgaWYgKGJtc0RhdGE/LmlzRk9EIHx8IGJtc0RhdGE/LmlzTWlzcyApIHtcclxuLy8gICAgICAgaWYgKCFpc1BhdXNlZCkge1xyXG4vLyAgICAgICAgIHNldElzUGF1c2VkKHRydWUpO1xyXG4vLyAgICAgICAgIHNldFJlbWFpbmluZ1RpbWUoKHByZXYpID0+IChlbmRUaW1lID8gZW5kVGltZSAtIERhdGUubm93KCkgOiBwcmV2KSk7IC8vIFN0b3JlIHJlbWFpbmluZyB0aW1lXHJcbi8vICAgICAgICAgc2V0RW5kVGltZShudWxsKTsgLy8gUGF1c2UgdGhlIGNvdW50ZG93blxyXG4vLyAgICAgICB9XHJcbi8vICAgICB9IGVsc2Uge1xyXG4vLyAgICAgICBpZiAoaXNQYXVzZWQpIHtcclxuLy8gICAgICAgICBzZXRJc1BhdXNlZChmYWxzZSk7XHJcbi8vICAgICAgICAgaWYgKHJlbWFpbmluZ1RpbWUgIT09IG51bGwpIHtcclxuLy8gICAgICAgICAgIGNvbnN0IG5ld0VuZFRpbWUgPSBEYXRlLm5vdygpICsgcmVtYWluaW5nVGltZTtcclxuLy8gICAgICAgICAgIHNldEVuZFRpbWUobmV3RW5kVGltZSk7XHJcbi8vICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImNoYXJnaW5nRW5kVGltZVwiLCBuZXdFbmRUaW1lLnRvU3RyaW5nKCkpO1xyXG4vLyAgICAgICAgIH1cclxuLy8gICAgICAgfVxyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtibXNEYXRhPy5pc0ZPRCwgYm1zRGF0YT8uaXNNaXNzXSk7XHJcblxyXG4vLyAgIC8vIOKchSBUaW1lciBjb3VudGRvd24gbG9naWNcclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFlbmRUaW1lIHx8ICFpc0NoYXJnaW5nSW5pdGlhbGl6ZWQgfHwgaXNQYXVzZWQpIHJldHVybjtcclxuXHJcbi8vICAgICBjb25zdCBjaGVja1RpbWUgPSAoKSA9PiB7XHJcbi8vICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbi8vICAgICAgIGlmIChub3cgPj0gZW5kVGltZSAmJiBpc0NoYXJnaW5nSW5pdGlhbGl6ZWQpIHtcclxuLy8gICAgICAgICBjb25zb2xlLmxvZyhcIuKPsCBUaW1lciBleHBpcmVkISBSZWRpcmVjdGluZyB0byAvZG9uZS4uLlwiKTtcclxuLy8gICAgICAgICByb3V0ZXIucmVwbGFjZShcIi9kb25lXCIpO1xyXG4vLyAgICAgICB9XHJcbi8vICAgICB9O1xyXG5cclxuLy8gICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoY2hlY2tUaW1lLCAxMDAwKTtcclxuLy8gICAgIGNoZWNrVGltZSgpO1xyXG5cclxuLy8gICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuLy8gICB9LCBbZW5kVGltZSwgaXNDaGFyZ2luZ0luaXRpYWxpemVkLCBpc1BhdXNlZCwgcm91dGVyXSk7XHJcblxyXG4vLyAgIHJldHVybiB7XHJcbi8vICAgICBlbmRUaW1lLFxyXG4vLyAgICAgc2V0VGltZXIsXHJcbi8vICAgICBpc1BhdXNlZCxcclxuLy8gICB9O1xyXG4vLyB9XHJcbi8vY291bnRlclxyXG4vLyBcInVzZSBjbGllbnRcIjtcclxuXHJcbi8vIGltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuLy8gaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvblwiO1xyXG4vLyBpbXBvcnQgeyB1c2VDaGFyZ2luZ1N0YXR1cyB9IGZyb20gXCIuL3VzZUNoYXJnaW5nU3RhdHVzXCI7XHJcbi8vIGltcG9ydCB7IHVzZUJNU0RhdGEgfSBmcm9tIFwiLi91c2VCTVNEYXRhXCI7IC8vIOKchSBJbXBvcnQgQk1TIGRhdGEgaG9va1xyXG5cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIHVzZVRpbWVyU3RhdHVzKCkge1xyXG4vLyAgIGNvbnN0IFtlbmRUaW1lLCBzZXRFbmRUaW1lXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG4vLyAgIGNvbnN0IFtyZW1haW5pbmdUaW1lLCBzZXRSZW1haW5pbmdUaW1lXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG4vLyAgIGNvbnN0IFtpc1BhdXNlZCwgc2V0SXNQYXVzZWRdID0gdXNlU3RhdGUodHJ1ZSk7XHJcbi8vICAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XHJcbi8vICAgY29uc3QgeyB1cGRhdGVDaGFyZ2luZ1N0YXR1cywgaXNDaGFyZ2luZ0luaXRpYWxpemVkIH0gPSB1c2VDaGFyZ2luZ1N0YXR1cygpOyAvLyDinIUgVXBkYXRlIGNoYXJnaW5nIHN0YXRlXHJcbi8vICAgY29uc3QgeyBibXNEYXRhIH0gPSB1c2VCTVNEYXRhKCk7IC8vIOKchSBHZXQgRk9EICYgbWlzYWxpZ25tZW50IHN0YXR1c1xyXG5cclxuLy8gICAvLyBGdW5jdGlvbiB0byBzZXQgdGhlIHRpbWVyXHJcbi8vICAgY29uc3Qgc2V0VGltZXIgPSAoZHVyYXRpb25NaW51dGVzOiBudW1iZXIpID0+IHtcclxuLy8gICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcclxuLy8gICAgIGNvbnN0IGNhbGN1bGF0ZWRFbmRUaW1lID0gY3VycmVudFRpbWUgKyBkdXJhdGlvbk1pbnV0ZXMgKiA2MCAqIDEwMDA7XHJcbi8vICAgICBzZXRFbmRUaW1lKGNhbGN1bGF0ZWRFbmRUaW1lKTtcclxuLy8gICAgIHNldFJlbWFpbmluZ1RpbWUoZHVyYXRpb25NaW51dGVzICogNjAgKiAxMDAwKTtcclxuLy8gICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiY2hhcmdpbmdFbmRUaW1lXCIsIGNhbGN1bGF0ZWRFbmRUaW1lLnRvU3RyaW5nKCkpO1xyXG4vLyAgICAgdXBkYXRlQ2hhcmdpbmdTdGF0dXModHJ1ZSk7IC8vIOKchSBTdGFydCBjaGFyZ2luZyB3aGVuIHRpbWVyIHN0YXJ0c1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIC8vIFJldHJpZXZlIHN0b3JlZCBlbmRUaW1lIG9uIGNvbXBvbmVudCBtb3VudFxyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBjb25zdCBzdG9yZWRFbmRUaW1lID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJjaGFyZ2luZ0VuZFRpbWVcIik7XHJcbi8vICAgICBpZiAoc3RvcmVkRW5kVGltZSkge1xyXG4vLyAgICAgICBzZXRFbmRUaW1lKE51bWJlcihzdG9yZWRFbmRUaW1lKSk7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW10pO1xyXG5cclxuLy8gICAvLyDinIUgSGFuZGxlIHBhdXNlIGFuZCByZXN1bWUgbG9naWNcclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgY29uc3Qgc2hvdWxkUGF1c2UgPSBibXNEYXRhPy5pc0ZPRCB8fCBibXNEYXRhPy5pc01pc3MgfHwgIWJtc0RhdGE/LmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ7XHJcblxyXG4vLyAgICAgaWYgKHNob3VsZFBhdXNlICYmICFpc1BhdXNlZCkge1xyXG4vLyAgICAgICAvLyBQYXVzZSB0aGUgdGltZXJcclxuLy8gICAgICAgc2V0SXNQYXVzZWQodHJ1ZSk7XHJcbi8vICAgICAgIHNldFJlbWFpbmluZ1RpbWUoZW5kVGltZSA/IE1hdGgubWF4KGVuZFRpbWUgLSBEYXRlLm5vdygpLCAwKSA6IHJlbWFpbmluZ1RpbWUpO1xyXG4vLyAgICAgICBzZXRFbmRUaW1lKG51bGwpOyAvLyBTdG9wIHRoZSBjb3VudGRvd25cclxuLy8gICAgICAgdXBkYXRlQ2hhcmdpbmdTdGF0dXMoZmFsc2UpOyAvLyDinIUgU3RvcCBjaGFyZ2luZyB3aGVuIHBhdXNlZFxyXG4vLyAgICAgfSBlbHNlIGlmICghc2hvdWxkUGF1c2UgJiYgaXNQYXVzZWQgJiYgcmVtYWluaW5nVGltZSAhPT0gbnVsbCkge1xyXG4vLyAgICAgICAvLyBSZXN1bWUgdGhlIHRpbWVyXHJcbi8vICAgICAgIHNldElzUGF1c2VkKGZhbHNlKTtcclxuLy8gICAgICAgY29uc3QgbmV3RW5kVGltZSA9IERhdGUubm93KCkgKyByZW1haW5pbmdUaW1lO1xyXG4vLyAgICAgICBzZXRFbmRUaW1lKG5ld0VuZFRpbWUpO1xyXG4vLyAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImNoYXJnaW5nRW5kVGltZVwiLCBuZXdFbmRUaW1lLnRvU3RyaW5nKCkpO1xyXG4vLyAgICAgICB1cGRhdGVDaGFyZ2luZ1N0YXR1cyh0cnVlKTsgLy8g4pyFIFJlc3VtZSBjaGFyZ2luZ1xyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtibXNEYXRhPy5pc0ZPRCwgYm1zRGF0YT8uaXNNaXNzLCBibXNEYXRhPy5pc1JlY2VpdmVyQ29pbERldGVjdGVkXSk7XHJcblxyXG4vLyAgIC8vIOKchSBUaW1lciBjb3VudGRvd24gbG9naWNcclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFlbmRUaW1lIHx8ICFpc0NoYXJnaW5nSW5pdGlhbGl6ZWQgfHwgaXNQYXVzZWQpIHJldHVybjtcclxuXHJcbi8vICAgICBjb25zdCBjaGVja1RpbWUgPSAoKSA9PiB7XHJcbi8vICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbi8vICAgICAgIGlmIChub3cgPj0gZW5kVGltZSAmJiBpc0NoYXJnaW5nSW5pdGlhbGl6ZWQpIHtcclxuLy8gICAgICAgICBjb25zb2xlLmxvZyhcIuKPsCBUaW1lciBleHBpcmVkISBSZWRpcmVjdGluZyB0byAvZG9uZS4uLlwiKTtcclxuLy8gICAgICAgICByb3V0ZXIucmVwbGFjZShcIi9kb25lXCIpO1xyXG4vLyAgICAgICB9XHJcbi8vICAgICB9O1xyXG5cclxuLy8gICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoY2hlY2tUaW1lLCAxMDAwKTtcclxuLy8gICAgIGNoZWNrVGltZSgpO1xyXG5cclxuLy8gICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuLy8gICB9LCBbZW5kVGltZSwgaXNDaGFyZ2luZ0luaXRpYWxpemVkLCBpc1BhdXNlZCwgcm91dGVyXSk7XHJcblxyXG4vLyAgIHJldHVybiB7XHJcbi8vICAgICBlbmRUaW1lLFxyXG4vLyAgICAgc2V0VGltZXIsXHJcbi8vICAgICBpc1BhdXNlZCxcclxuXHJcbi8vICAgfTtcclxuLy8gfVxyXG5cclxuXHJcbi8vYWZ0ZXIgYXBwIGJ1aWxkaW5nXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG5cclxuLy8gaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG4vLyBpbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tIFwibmV4dC9uYXZpZ2F0aW9uXCI7XHJcbi8vIGltcG9ydCB7IHVzZUNoYXJnaW5nU3RhdHVzIH0gZnJvbSBcIi4vdXNlQ2hhcmdpbmdTdGF0dXNcIjtcclxuLy8gaW1wb3J0IHsgdXNlQk1TRGF0YSB9IGZyb20gXCIuL3VzZUJNU0RhdGFcIjtcclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiB1c2VUaW1lclN0YXR1cygpIHtcclxuLy8gICBjb25zdCBbZW5kVGltZSwgc2V0RW5kVGltZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbcmVtYWluaW5nVGltZSwgc2V0UmVtYWluaW5nVGltZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbaXNQYXVzZWQsIHNldElzUGF1c2VkXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4vLyAgIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xyXG4vLyAgIGNvbnN0IHsgdXBkYXRlQ2hhcmdpbmdTdGF0dXMsIGlzQ2hhcmdpbmdJbml0aWFsaXplZCB9ID0gdXNlQ2hhcmdpbmdTdGF0dXMoKTtcclxuLy8gICBjb25zdCB7IGJtc0RhdGEgfSA9IHVzZUJNU0RhdGEoKTtcclxuXHJcbi8vICAgLy8gU2V0IGEgdGltZXIgd2l0aCBkdXJhdGlvbiBpbiBtaW51dGVzXHJcbi8vICAgY29uc3Qgc2V0VGltZXIgPSAoZHVyYXRpb25NaW51dGVzOiBudW1iZXIpID0+IHtcclxuLy8gICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcclxuLy8gICAgIGNvbnN0IGNhbGN1bGF0ZWRFbmRUaW1lID0gY3VycmVudFRpbWUgKyBkdXJhdGlvbk1pbnV0ZXMgKiA2MCAqIDEwMDA7XHJcbi8vICAgICBzZXRFbmRUaW1lKGNhbGN1bGF0ZWRFbmRUaW1lKTtcclxuLy8gICAgIHNldFJlbWFpbmluZ1RpbWUoZHVyYXRpb25NaW51dGVzICogNjAgKiAxMDAwKTtcclxuLy8gICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiY2hhcmdpbmdFbmRUaW1lXCIsIGNhbGN1bGF0ZWRFbmRUaW1lLnRvU3RyaW5nKCkpO1xyXG4vLyAgICAgdXBkYXRlQ2hhcmdpbmdTdGF0dXModHJ1ZSk7IC8vIFN0YXJ0IGNoYXJnaW5nXHJcbi8vICAgICBzZXRJc1BhdXNlZChmYWxzZSk7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgLy8gTG9hZCBlbmRUaW1lIGZyb20gbG9jYWxTdG9yYWdlIHdoZW4gaG9vayBtb3VudHNcclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgY29uc3Qgc3RvcmVkRW5kVGltZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiY2hhcmdpbmdFbmRUaW1lXCIpO1xyXG4vLyAgICAgaWYgKHN0b3JlZEVuZFRpbWUpIHtcclxuLy8gICAgICAgY29uc3QgcGFyc2VkRW5kVGltZSA9IE51bWJlcihzdG9yZWRFbmRUaW1lKTtcclxuLy8gICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xyXG4vLyAgICAgICBjb25zdCB0aW1lTGVmdCA9IHBhcnNlZEVuZFRpbWUgLSBjdXJyZW50VGltZTtcclxuXHJcbi8vICAgICAgIGlmICh0aW1lTGVmdCA+IDApIHtcclxuLy8gICAgICAgICBzZXRFbmRUaW1lKHBhcnNlZEVuZFRpbWUpO1xyXG4vLyAgICAgICAgIHNldFJlbWFpbmluZ1RpbWUodGltZUxlZnQpO1xyXG4vLyAgICAgICAgIHNldElzUGF1c2VkKGZhbHNlKTtcclxuLy8gICAgICAgfSBlbHNlIHtcclxuLy8gICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcImNoYXJnaW5nRW5kVGltZVwiKTtcclxuLy8gICAgICAgICByb3V0ZXIucmVwbGFjZShcIi9kb25lXCIpO1xyXG4vLyAgICAgICB9XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW3JvdXRlcl0pO1xyXG5cclxuICBcclxuXHJcbi8vICAgLy8gUGF1c2UvcmVzdW1lIGJhc2VkIG9uIEZPRCwgbWlzYWxpZ25tZW50LCBvciByZWNlaXZlciBjb2lsIGRldGVjdGlvblxyXG4vLyAgIC8vIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgLy8gICBjb25zdCBzaG91bGRQYXVzZSA9XHJcbi8vICAgLy8gICAgIGJtc0RhdGE/LmlzRk9EIHx8IGJtc0RhdGE/LmlzTWlzcyB8fCAhYm1zRGF0YT8uaXNSZWNlaXZlckNvaWxEZXRlY3RlZDtcclxuXHJcbi8vICAgLy8gICBpZiAoc2hvdWxkUGF1c2UgJiYgIWlzUGF1c2VkKSB7XHJcbi8vICAgLy8gICAgIC8vIFBhdXNlXHJcbi8vICAgLy8gICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbi8vICAgLy8gICAgIHNldElzUGF1c2VkKHRydWUpO1xyXG4vLyAgIC8vICAgICBpZiAoZW5kVGltZSkge1xyXG4vLyAgIC8vICAgICAgIGNvbnN0IHRpbWVMZWZ0ID0gTWF0aC5tYXgoZW5kVGltZSAtIG5vdywgMCk7XHJcbi8vICAgLy8gICAgICAgc2V0UmVtYWluaW5nVGltZSh0aW1lTGVmdCk7XHJcbi8vICAgLy8gICAgICAgc2V0RW5kVGltZShudWxsKTtcclxuLy8gICAvLyAgICAgfVxyXG4vLyAgIC8vICAgICB1cGRhdGVDaGFyZ2luZ1N0YXR1cyhmYWxzZSk7XHJcbi8vICAgLy8gICB9IGVsc2UgaWYgKCFzaG91bGRQYXVzZSAmJiBpc1BhdXNlZCAmJiByZW1haW5pbmdUaW1lICE9PSBudWxsKSB7XHJcbi8vICAgLy8gICAgIC8vIFJlc3VtZVxyXG4vLyAgIC8vICAgICBpZiAocmVtYWluaW5nVGltZSA8PSAwKSB7XHJcbi8vICAgLy8gICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJjaGFyZ2luZ0VuZFRpbWVcIik7XHJcbi8vICAgLy8gICAgICAgcm91dGVyLnJlcGxhY2UoXCIvZG9uZVwiKTtcclxuLy8gICAvLyAgICAgICByZXR1cm47XHJcbi8vICAgLy8gICAgIH1cclxuLy8gICAvLyAgICAgY29uc3QgbmV3RW5kVGltZSA9IERhdGUubm93KCkgKyByZW1haW5pbmdUaW1lO1xyXG4vLyAgIC8vICAgICBzZXRFbmRUaW1lKG5ld0VuZFRpbWUpO1xyXG4vLyAgIC8vICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImNoYXJnaW5nRW5kVGltZVwiLCBuZXdFbmRUaW1lLnRvU3RyaW5nKCkpO1xyXG4vLyAgIC8vICAgICBzZXRJc1BhdXNlZChmYWxzZSk7XHJcbi8vICAgLy8gICAgIHVwZGF0ZUNoYXJnaW5nU3RhdHVzKHRydWUpO1xyXG4vLyAgIC8vICAgfVxyXG4vLyAgIC8vIH0sIFtcclxuLy8gICAvLyAgIGJtc0RhdGE/LmlzRk9ELFxyXG4vLyAgIC8vICAgYm1zRGF0YT8uaXNNaXNzLFxyXG4vLyAgIC8vICAgYm1zRGF0YT8uaXNSZWNlaXZlckNvaWxEZXRlY3RlZCxcclxuLy8gICAvLyAgIGlzUGF1c2VkLFxyXG4vLyAgIC8vICAgZW5kVGltZSxcclxuLy8gICAvLyAgIHJlbWFpbmluZ1RpbWUsXHJcbi8vICAgLy8gICByb3V0ZXIsXHJcbi8vICAgLy8gICB1cGRhdGVDaGFyZ2luZ1N0YXR1cyxcclxuLy8gICAvLyBdKTtcclxuXHJcblxyXG4gIC8vIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgLy8gICBjb25zdCBzaG91bGRQYXVzZSA9XHJcbiAgLy8gICAgIGJtc0RhdGE/LmlzRk9EIHx8IGJtc0RhdGE/LmlzTWlzcyB8fCAhYm1zRGF0YT8uaXNSZWNlaXZlckNvaWxEZXRlY3RlZDtcclxuICBcclxuICAvLyAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgXHJcbiAgLy8gICBpZiAoc2hvdWxkUGF1c2UgJiYgIWlzUGF1c2VkKSB7XHJcbiAgLy8gICAgIC8vIPCflLQgUGF1c2UgbG9naWNcclxuICAvLyAgICAgc2V0SXNQYXVzZWQodHJ1ZSk7XHJcbiAgXHJcbiAgLy8gICAgIGlmIChlbmRUaW1lKSB7XHJcbiAgLy8gICAgICAgY29uc3QgdGltZUxlZnQgPSBNYXRoLm1heChlbmRUaW1lIC0gbm93LCAwKTtcclxuICAvLyAgICAgICBzZXRSZW1haW5pbmdUaW1lKHRpbWVMZWZ0KTtcclxuICAvLyAgICAgICBzZXRFbmRUaW1lKG51bGwpO1xyXG4gIC8vICAgICB9XHJcbiAgXHJcbiAgLy8gICAgIHVwZGF0ZUNoYXJnaW5nU3RhdHVzKGZhbHNlKTsgLy8gT3B0aW9uYWw6IGF3YWl0IGlmIHlvdSB3YW50IHRvIGd1YXJhbnRlZSBzdGF0ZSBzeW5jXHJcbiAgLy8gICB9XHJcbiAgXHJcbiAgLy8gICBlbHNlIGlmICghc2hvdWxkUGF1c2UgJiYgaXNQYXVzZWQpIHtcclxuICAvLyAgICAgLy8g8J+foiBSZXN1bWUgbG9naWNcclxuICBcclxuICAvLyAgICAgY29uc3Qgc2FmZVJlbWFpbmluZyA9IHJlbWFpbmluZ1RpbWUgPz8gKGVuZFRpbWUgPyBNYXRoLm1heChlbmRUaW1lIC0gbm93LCAwKSA6IDApO1xyXG4gIFxyXG4gIC8vICAgICBpZiAoc2FmZVJlbWFpbmluZyA8PSAwKSB7XHJcbiAgLy8gICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJjaGFyZ2luZ0VuZFRpbWVcIik7XHJcbiAgLy8gICAgICAgdXBkYXRlQ2hhcmdpbmdTdGF0dXMoZmFsc2UpLnRoZW4oKCkgPT4ge1xyXG4gIC8vICAgICAgICAgLy8gcm91dGVyLnJlcGxhY2UoXCIvZG9uZVwiKTtcclxuICAvLyAgICAgICB9KTtcclxuICAvLyAgICAgICByZXR1cm47XHJcbiAgLy8gICAgIH1cclxuICBcclxuICAvLyAgICAgY29uc3QgbmV3RW5kVGltZSA9IG5vdyArIHNhZmVSZW1haW5pbmc7XHJcbiAgLy8gICAgIHNldEVuZFRpbWUobmV3RW5kVGltZSk7XHJcbiAgLy8gICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiY2hhcmdpbmdFbmRUaW1lXCIsIG5ld0VuZFRpbWUudG9TdHJpbmcoKSk7XHJcbiAgXHJcbiAgLy8gICAgIHNldFJlbWFpbmluZ1RpbWUobnVsbCk7IC8vIENsZWFyIGFmdGVyIHVzaW5nXHJcbiAgLy8gICAgIHNldElzUGF1c2VkKGZhbHNlKTtcclxuICAvLyAgICAgdXBkYXRlQ2hhcmdpbmdTdGF0dXModHJ1ZSk7XHJcbiAgLy8gICB9XHJcbiAgLy8gfSwgW1xyXG4gIC8vICAgYm1zRGF0YT8uaXNGT0QsXHJcbiAgLy8gICBibXNEYXRhPy5pc01pc3MsXHJcbiAgLy8gICBibXNEYXRhPy5pc1JlY2VpdmVyQ29pbERldGVjdGVkLFxyXG4gIC8vICAgaXNQYXVzZWQsXHJcbiAgLy8gICBlbmRUaW1lLFxyXG4gIC8vICAgcmVtYWluaW5nVGltZSxcclxuICAvLyAgIHJvdXRlcixcclxuICAvLyAgIHVwZGF0ZUNoYXJnaW5nU3RhdHVzLFxyXG4gIC8vIF0pO1xyXG4gIFxyXG5cclxuLy8gICAvLyBDb3VudGRvd24gdGltZXIgLSByZWRpcmVjdCB3aGVuIGNvbXBsZXRlXHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIGlmICghZW5kVGltZSB8fCAhaXNDaGFyZ2luZ0luaXRpYWxpemVkIHx8IGlzUGF1c2VkKSByZXR1cm47XHJcblxyXG4vLyAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbi8vICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbi8vICAgICAgIGlmIChub3cgPj0gZW5kVGltZSkge1xyXG4vLyAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwiY2hhcmdpbmdFbmRUaW1lXCIpO1xyXG4vLyAgICAgICAgIC8vIHJvdXRlci5yZXBsYWNlKFwiL2RvbmVcIik7XHJcbi8vICAgICAgIH1cclxuLy8gICAgIH0sIDEwMDApO1xyXG5cclxuLy8gICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuLy8gICB9LCBbZW5kVGltZSwgaXNDaGFyZ2luZ0luaXRpYWxpemVkLCBpc1BhdXNlZCwgcm91dGVyXSk7XHJcblxyXG4vLyAgIHJldHVybiB7XHJcbi8vICAgICBlbmRUaW1lLFxyXG4vLyAgICAgc2V0VGltZXIsXHJcbi8vICAgICBpc1BhdXNlZCxcclxuLy8gICB9O1xyXG4vLyB9XHJcblxyXG4vLy9pbmFsIGZpeFxyXG5cInVzZSBjbGllbnRcIjtcclxuXHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VDaGFyZ2luZ1N0YXR1cyB9IGZyb20gXCIuL3VzZUNoYXJnaW5nU3RhdHVzXCI7IFxyXG5pbXBvcnQgeyB1c2VCTVNEYXRhIH0gZnJvbSBcIi4vdXNlQk1TRGF0YVwiOyAvLyDinIUgSW1wb3J0IEJNUyBkYXRhIGhvb2tcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VUaW1lclN0YXR1cygpIHtcclxuICBjb25zdCBbZW5kVGltZSwgc2V0RW5kVGltZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbcmVtYWluaW5nVGltZSwgc2V0UmVtYWluaW5nVGltZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbaXNQYXVzZWQsIHNldElzUGF1c2VkXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xyXG4gIGNvbnN0IHsgdXBkYXRlQ2hhcmdpbmdTdGF0dXMsIGlzQ2hhcmdpbmdJbml0aWFsaXplZCB9ID0gdXNlQ2hhcmdpbmdTdGF0dXMoKTsgLy8g4pyFIFVwZGF0ZSBjaGFyZ2luZyBzdGF0ZVxyXG4gIGNvbnN0IHsgYm1zRGF0YSB9ID0gdXNlQk1TRGF0YSgpOyAvLyDinIUgR2V0IEZPRCAmIG1pc2FsaWdubWVudCBzdGF0dXNcclxuXHJcbiAgLy8gRnVuY3Rpb24gdG8gc2V0IHRoZSB0aW1lclxyXG4gIGNvbnN0IHNldFRpbWVyID0gKGR1cmF0aW9uTWludXRlczogbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XHJcbiAgICBjb25zdCBjYWxjdWxhdGVkRW5kVGltZSA9IGN1cnJlbnRUaW1lICsgZHVyYXRpb25NaW51dGVzICogNjAgKiAxMDAwO1xyXG4gICAgc2V0RW5kVGltZShjYWxjdWxhdGVkRW5kVGltZSk7XHJcbiAgICBzZXRSZW1haW5pbmdUaW1lKGR1cmF0aW9uTWludXRlcyAqIDYwICogMTAwMCk7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImNoYXJnaW5nRW5kVGltZVwiLCBjYWxjdWxhdGVkRW5kVGltZS50b1N0cmluZygpKTtcclxuICAgIHVwZGF0ZUNoYXJnaW5nU3RhdHVzKHRydWUpOyAvLyDinIUgU3RhcnQgY2hhcmdpbmcgd2hlbiB0aW1lciBzdGFydHNcclxuICB9O1xyXG5cclxuICAvLyBSZXRyaWV2ZSBzdG9yZWQgZW5kVGltZSBvbiBjb21wb25lbnQgbW91bnRcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3Qgc3RvcmVkRW5kVGltZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiY2hhcmdpbmdFbmRUaW1lXCIpO1xyXG4gICAgaWYgKHN0b3JlZEVuZFRpbWUpIHtcclxuICAgICAgc2V0RW5kVGltZShOdW1iZXIoc3RvcmVkRW5kVGltZSkpO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8g4pyFIEhhbmRsZSBwYXVzZSBhbmQgcmVzdW1lIGxvZ2ljXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGlzRk9EID0gISFibXNEYXRhPy5pc0ZPRDtcclxuICAgIGNvbnN0IGlzTWlzcyA9ICEhYm1zRGF0YT8uaXNNaXNzO1xyXG4gICAgY29uc3QgaXNSZWNlaXZlckRldGVjdGVkID0gISFibXNEYXRhPy5pc1JlY2VpdmVyQ29pbERldGVjdGVkO1xyXG4gICAgY29uc3Qgc2hvdWxkUGF1c2UgPSBpc0ZPRCB8fCBpc01pc3MgfHwgIWlzUmVjZWl2ZXJEZXRlY3RlZDtcclxuICBcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgXHJcbiAgICBpZiAoc2hvdWxkUGF1c2UgJiYgIWlzUGF1c2VkKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi4o+4IFBhdXNpbmcgdGltZXJcIik7XHJcbiAgICAgIHNldElzUGF1c2VkKHRydWUpO1xyXG4gIFxyXG4gICAgICBpZiAoZW5kVGltZSkge1xyXG4gICAgICAgIGNvbnN0IHRpbWVMZWZ0ID0gTWF0aC5tYXgoZW5kVGltZSAtIG5vdywgMCk7XHJcbiAgICAgICAgc2V0UmVtYWluaW5nVGltZSh0aW1lTGVmdCk7XHJcbiAgICAgICAgc2V0RW5kVGltZShudWxsKTsgLy8gVGhpcyB0cmlnZ2VycyBjbGVhbnVwIG9mIHRoZSB0aW1lciBlZmZlY3RcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICB1cGRhdGVDaGFyZ2luZ1N0YXR1cyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBpZiAoIXNob3VsZFBhdXNlICYmIGlzUGF1c2VkICYmIHJlbWFpbmluZ1RpbWUpIHtcclxuICAgICAgY29uc29sZS5sb2coXCLilrbvuI8gUmVzdW1pbmcgdGltZXJcIik7XHJcbiAgICAgIGNvbnN0IG5ld0VuZFRpbWUgPSBub3cgKyByZW1haW5pbmdUaW1lO1xyXG4gIFxyXG4gICAgICBzZXRFbmRUaW1lKG5ld0VuZFRpbWUpO1xyXG4gICAgICBzZXRSZW1haW5pbmdUaW1lKG51bGwpO1xyXG4gICAgICBzZXRJc1BhdXNlZChmYWxzZSk7XHJcbiAgICAgIHVwZGF0ZUNoYXJnaW5nU3RhdHVzKHRydWUpO1xyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImNoYXJnaW5nRW5kVGltZVwiLCBuZXdFbmRUaW1lLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gIH0sIFtcclxuICAgIGJtc0RhdGE/LmlzRk9ELFxyXG4gICAgYm1zRGF0YT8uaXNNaXNzLFxyXG4gICAgYm1zRGF0YT8uaXNSZWNlaXZlckNvaWxEZXRlY3RlZCxcclxuICAgIGlzUGF1c2VkLFxyXG4gICAgZW5kVGltZSxcclxuICAgIHJlbWFpbmluZ1RpbWUsXHJcbiAgXSk7XHJcbiAgXHJcbiAgXHJcbiAgLy8g4pyFIFRpbWVyIGNvdW50ZG93biBsb2dpY1xyXG4gIGNvbnN0IGludGVydmFsUmVmID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XHJcblxyXG51c2VFZmZlY3QoKCkgPT4ge1xyXG4gIGlmICghZW5kVGltZSB8fCBpc1BhdXNlZCB8fCAhaXNDaGFyZ2luZ0luaXRpYWxpemVkKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIuKPuCBUaW1lciBub3QgYWN0aXZlOlwiLCB7IGVuZFRpbWUsIGlzUGF1c2VkLCBpc0NoYXJnaW5nSW5pdGlhbGl6ZWQgfSk7XHJcblxyXG4gICAgaWYgKGludGVydmFsUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbFJlZi5jdXJyZW50KTtcclxuICAgICAgaW50ZXJ2YWxSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+nuSBJbnRlcnZhbCBjbGVhcmVkIGR1ZSB0byBwYXVzZSBvciBtaXNzaW5nIHN0YXRlLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLmxvZyhcIvCflZIgU3RhcnRpbmcgaW50ZXJ2YWwuIEVuZCB0aW1lOlwiLCBuZXcgRGF0ZShlbmRUaW1lKS50b0xvY2FsZVRpbWVTdHJpbmcoKSk7XHJcblxyXG4gIGNvbnN0IGNoZWNrVGltZSA9ICgpID0+IHtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBpZiAobm93ID49IGVuZFRpbWUpIHtcclxuICAgICAgY29uc29sZS5sb2coXCLij7AgVGltZXIgZXhwaXJlZCEgUmVkaXJlY3RpbmcuLi5cIik7XHJcbiAgICAgIHVwZGF0ZUNoYXJnaW5nU3RhdHVzKGZhbHNlKS50aGVuKCgpID0+IHtcclxuICAgICAgICByb3V0ZXIucmVwbGFjZShcIi9kb25lXCIpO1xyXG4gICAgICB9KTtcclxuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbFJlZi5jdXJyZW50ISk7XHJcbiAgICAgIGludGVydmFsUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGludGVydmFsUmVmLmN1cnJlbnQgPSBzZXRJbnRlcnZhbChjaGVja1RpbWUsIDEwMDApO1xyXG4gIGNoZWNrVGltZSgpOyAvLyBydW4gb25jZSBpbW1lZGlhdGVseVxyXG5cclxuICByZXR1cm4gKCkgPT4ge1xyXG4gICAgaWYgKGludGVydmFsUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbFJlZi5jdXJyZW50KTtcclxuICAgICAgaW50ZXJ2YWxSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+nuSBDbGVhbmluZyB1cCB0aW1lciBvbiB1bm1vdW50IG9yIHJlLXJ1blwiKTtcclxuICAgIH1cclxuICB9O1xyXG59LCBbZW5kVGltZSwgaXNQYXVzZWQsIGlzQ2hhcmdpbmdJbml0aWFsaXplZF0pO1xyXG5cclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKFwiREVCVUcgLT4gZW5kVGltZTpcIiwgZW5kVGltZSk7XHJcbiAgICBjb25zb2xlLmxvZyhcIkRFQlVHIC0+IGlzQ2hhcmdpbmdJbml0aWFsaXplZDpcIiwgaXNDaGFyZ2luZ0luaXRpYWxpemVkKTtcclxuICAgIGNvbnNvbGUubG9nKFwiREVCVUcgLT4gaXNQYXVzZWQ6XCIsIGlzUGF1c2VkKTtcclxuICB9LCBbZW5kVGltZSwgaXNDaGFyZ2luZ0luaXRpYWxpemVkLCBpc1BhdXNlZF0pO1xyXG4gIFxyXG4gIFxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZW5kVGltZSxcclxuICAgIHNldFRpbWVyLFxyXG4gICAgaXNQYXVzZWQsXHJcblxyXG4gIH07XHJcbn0iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSb3V0ZXIiLCJ1c2VDaGFyZ2luZ1N0YXR1cyIsInVzZUJNU0RhdGEiLCJ1c2VUaW1lclN0YXR1cyIsImVuZFRpbWUiLCJzZXRFbmRUaW1lIiwicmVtYWluaW5nVGltZSIsInNldFJlbWFpbmluZ1RpbWUiLCJpc1BhdXNlZCIsInNldElzUGF1c2VkIiwicm91dGVyIiwidXBkYXRlQ2hhcmdpbmdTdGF0dXMiLCJpc0NoYXJnaW5nSW5pdGlhbGl6ZWQiLCJibXNEYXRhIiwic2V0VGltZXIiLCJkdXJhdGlvbk1pbnV0ZXMiLCJjdXJyZW50VGltZSIsIkRhdGUiLCJub3ciLCJjYWxjdWxhdGVkRW5kVGltZSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJ0b1N0cmluZyIsInN0b3JlZEVuZFRpbWUiLCJnZXRJdGVtIiwiTnVtYmVyIiwiaXNGT0QiLCJpc01pc3MiLCJpc1JlY2VpdmVyRGV0ZWN0ZWQiLCJpc1JlY2VpdmVyQ29pbERldGVjdGVkIiwic2hvdWxkUGF1c2UiLCJjb25zb2xlIiwibG9nIiwidGltZUxlZnQiLCJNYXRoIiwibWF4IiwibmV3RW5kVGltZSIsImludGVydmFsUmVmIiwidXNlUmVmIiwiY3VycmVudCIsImNsZWFySW50ZXJ2YWwiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJjaGVja1RpbWUiLCJ0aGVuIiwicmVwbGFjZSIsInNldEludGVydmFsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useTimerStatus.ts\n"));

/***/ })

});