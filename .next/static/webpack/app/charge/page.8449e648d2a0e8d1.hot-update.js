"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/charge/page",{

/***/ "(app-pages-browser)/./components/WaveCharging.tsx":
/*!*************************************!*\
  !*** ./components/WaveCharging.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WaveCharging)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n// \"use client\";\n// import React, { useState, useEffect, useMemo } from \"react\";\n// import { Inter } from \"next/font/google\";\n// import { Zap } from \"lucide-react\";\n// const interThin = Inter({\n//   subsets: [\"latin\"],\n//   weight: [\"200\"],\n//   variable: \"--font-inter\",\n// });\n// interface WaveChargingProps {\n//   percentage?: number;\n//   waveColor?: string;\n//   backgroundColor?: string;\n//   size?: number;\n// }\n// const WaveCharging = ({ \n//   percentage = 0, \n//   waveColor = \"rgba(0, 123, 255, 0.7)\",\n//   backgroundColor = \"rgba(220, 220, 220, 0.2)\",\n//   size = 160\n// }: WaveChargingProps) => {\n//   const [phase, setPhase] = useState(0);\n//   const clampedPercentage = Math.min(100, Math.max(0, percentage));\n//   // Smoother animation using requestAnimationFrame\n//   useEffect(() => {\n//     let animationFrameId: number;\n//     let lastTime = 0;\n//     const fps = 30; // Target 30fps for smoother animation\n//     const interval = 1000 / fps;\n//     const animate = (time: number) => {\n//       if (time - lastTime > interval) {\n//         setPhase((prev) => (prev + 2) % 360); // Slightly faster phase change\n//         lastTime = time;\n//       }\n//       animationFrameId = requestAnimationFrame(animate);\n//     };\n//     animationFrameId = requestAnimationFrame(animate);\n//     return () => cancelAnimationFrame(animationFrameId);\n//   }, []);\n//   // Dynamic wave amplitude based on charging percentage\n//   const waveAmplitude = useMemo(() => {\n//     return clampedPercentage > 90 ? 1 : clampedPercentage > 50 ? 2 : 3;\n//   }, [clampedPercentage]);\n//   // Memoized wave path for better performance\n//   const wavePath = useMemo(() => {\n//     const yPos = 100 - clampedPercentage;\n//     return `M0 ${yPos} \n//             Q20 ${yPos + Math.sin((phase * Math.PI) / 180) * waveAmplitude} \n//             40 ${yPos} \n//             T100 ${yPos} \n//             V100 H0 Z`;\n//   }, [phase, clampedPercentage, waveAmplitude]);\n//   return (\n//     <div\n//       className=\"relative flex items-center justify-center rounded-full overflow-hidden\"\n//       style={{\n//         width: `${size}px`,\n//         height: `${size}px`,\n//         backgroundColor,\n//         boxShadow: `0px 0px 15px ${waveColor}`,\n//       }}\n//       role=\"progressbar\"\n//       aria-valuenow={clampedPercentage}\n//       aria-valuemin={0}\n//       aria-valuemax={100}\n//     >\n//       <svg \n//         className=\"absolute inset-0 w-full h-full\" \n//         viewBox=\"0 0 100 100\" \n//         preserveAspectRatio=\"none\"\n//         aria-hidden=\"true\"\n//       >\n//         <path\n//           fill={waveColor}\n//           d={wavePath}\n//         />\n//       </svg>\n//       <span\n//         className=\"text-white text-4xl font-bold relative z-10\"\n//         style={{\n//           textShadow: \"0 0 8px rgba(0, 0, 0, 0.5)\",\n//         }}\n//         aria-hidden=\"true\"\n//       >\n//         {clampedPercentage}%\n//       </span>\n//     </div>\n//   );\n// };\n// export default WaveCharging;\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction WaveCharging(param) {\n    let { safePercentag } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WaveCharging.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const ctx = canvas.getContext('2d');\n            if (!ctx) return;\n            const width = canvas.width;\n            const height = canvas.height;\n            const waveHeight = 10;\n            const waveLength = 60;\n            const waveSpeed = 0.05;\n            let offset = 0;\n            let animationFrameId;\n            const drawWave = {\n                \"WaveCharging.useEffect.drawWave\": ()=>{\n                    ctx.clearRect(0, 0, width, height);\n                    // Draw circular clip\n                    ctx.beginPath();\n                    ctx.arc(width / 2, height / 2, width / 2, 0, Math.PI * 2);\n                    ctx.clip();\n                    // Draw water fill background\n                    ctx.fillStyle = '#1E40AF'; // dark blue\n                    ctx.fillRect(0, 0, width, height);\n                    // Wave y position based on percentage\n                    const waveY = height * (1 - safePercentag / 100);\n                    ctx.beginPath();\n                    for(let x = 0; x <= width; x++){\n                        const y = waveY + Math.sin((x + offset) / waveLength) * waveHeight;\n                        ctx.lineTo(x, y);\n                    }\n                    ctx.lineTo(width, height);\n                    ctx.lineTo(0, height);\n                    ctx.closePath();\n                    ctx.fillStyle = '#60A5FA'; // lighter blue\n                    ctx.fill();\n                    offset += waveSpeed * waveLength;\n                    animationFrameId = requestAnimationFrame(drawWave);\n                }\n            }[\"WaveCharging.useEffect.drawWave\"];\n            drawWave();\n            return ({\n                \"WaveCharging.useEffect\": ()=>cancelAnimationFrame(animationFrameId)\n            })[\"WaveCharging.useEffect\"];\n        }\n    }[\"WaveCharging.useEffect\"], [\n        safePercentag\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        width: 200,\n        height: 200,\n        className: \"rounded-full bg-transparent\"\n    }, void 0, false, {\n        fileName: \"D:\\\\coding\\\\dash dynamics\\\\dashboards\\\\Localbackend\\\\charging-system\\\\components\\\\WaveCharging.tsx\",\n        lineNumber: 170,\n        columnNumber: 5\n    }, this);\n}\n_s(WaveCharging, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = WaveCharging;\nvar _c;\n$RefreshReg$(_c, \"WaveCharging\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvV2F2ZUNoYXJnaW5nLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0EsZ0JBQWdCO0FBQ2hCLCtEQUErRDtBQUMvRCw0Q0FBNEM7QUFDNUMsc0NBQXNDO0FBQ3RDLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCLDhCQUE4QjtBQUM5QixNQUFNO0FBR04sZ0NBQWdDO0FBQ2hDLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsOEJBQThCO0FBQzlCLG1CQUFtQjtBQUNuQixJQUFJO0FBRUosMkJBQTJCO0FBQzNCLHFCQUFxQjtBQUNyQiwwQ0FBMEM7QUFDMUMsa0RBQWtEO0FBQ2xELGVBQWU7QUFDZiw2QkFBNkI7QUFDN0IsMkNBQTJDO0FBQzNDLHNFQUFzRTtBQUd0RSxzREFBc0Q7QUFDdEQsc0JBQXNCO0FBQ3RCLG9DQUFvQztBQUNwQyx3QkFBd0I7QUFDeEIsNkRBQTZEO0FBQzdELG1DQUFtQztBQUtuQywwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLGdGQUFnRjtBQUNoRiwyQkFBMkI7QUFDM0IsVUFBVTtBQUNWLDJEQUEyRDtBQUMzRCxTQUFTO0FBRVQseURBQXlEO0FBQ3pELDJEQUEyRDtBQUMzRCxZQUFZO0FBRVosMkRBQTJEO0FBQzNELDBDQUEwQztBQUMxQywwRUFBMEU7QUFDMUUsNkJBQTZCO0FBRTdCLGlEQUFpRDtBQUNqRCxxQ0FBcUM7QUFDckMsNENBQTRDO0FBQzVDLDBCQUEwQjtBQUMxQiwrRUFBK0U7QUFDL0UsMEJBQTBCO0FBQzFCLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIsbURBQW1EO0FBRW5ELGFBQWE7QUFDYixXQUFXO0FBQ1gsMkZBQTJGO0FBQzNGLGlCQUFpQjtBQUNqQiw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CLDJCQUEyQjtBQUMzQixrREFBa0Q7QUFDbEQsV0FBVztBQUNYLDJCQUEyQjtBQUMzQiwwQ0FBMEM7QUFDMUMsMEJBQTBCO0FBQzFCLDRCQUE0QjtBQUM1QixRQUFRO0FBQ1IsY0FBYztBQUNkLHNEQUFzRDtBQUN0RCxpQ0FBaUM7QUFDakMscUNBQXFDO0FBQ3JDLDZCQUE2QjtBQUM3QixVQUFVO0FBQ1YsZ0JBQWdCO0FBQ2hCLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsYUFBYTtBQUNiLGVBQWU7QUFFZixjQUFjO0FBQ2Qsa0VBQWtFO0FBQ2xFLG1CQUFtQjtBQUNuQixzREFBc0Q7QUFDdEQsYUFBYTtBQUNiLDZCQUE2QjtBQUM3QixVQUFVO0FBQ1YsK0JBQStCO0FBQy9CLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsT0FBTztBQUNQLEtBQUs7QUFFTCwrQkFBK0I7OztBQUdXO0FBTTNCLFNBQVNFLGFBQWEsS0FBb0M7UUFBcEMsRUFBRUMsYUFBYSxFQUFxQixHQUFwQzs7SUFDbkMsTUFBTUMsWUFBWUgsNkNBQU1BLENBQW9CO0lBRTVDRCxnREFBU0E7a0NBQUM7WUFDUixNQUFNSyxTQUFTRCxVQUFVRSxPQUFPO1lBQ2hDLElBQUksQ0FBQ0QsUUFBUTtZQUNiLE1BQU1FLE1BQU1GLE9BQU9HLFVBQVUsQ0FBQztZQUM5QixJQUFJLENBQUNELEtBQUs7WUFFVixNQUFNRSxRQUFRSixPQUFPSSxLQUFLO1lBQzFCLE1BQU1DLFNBQVNMLE9BQU9LLE1BQU07WUFDNUIsTUFBTUMsYUFBYTtZQUNuQixNQUFNQyxhQUFhO1lBQ25CLE1BQU1DLFlBQVk7WUFFbEIsSUFBSUMsU0FBUztZQUNiLElBQUlDO1lBRUosTUFBTUM7bURBQVc7b0JBQ2ZULElBQUlVLFNBQVMsQ0FBQyxHQUFHLEdBQUdSLE9BQU9DO29CQUUzQixxQkFBcUI7b0JBQ3JCSCxJQUFJVyxTQUFTO29CQUNiWCxJQUFJWSxHQUFHLENBQUNWLFFBQVEsR0FBR0MsU0FBUyxHQUFHRCxRQUFRLEdBQUcsR0FBR1csS0FBS0MsRUFBRSxHQUFHO29CQUN2RGQsSUFBSWUsSUFBSTtvQkFFUiw2QkFBNkI7b0JBQzdCZixJQUFJZ0IsU0FBUyxHQUFHLFdBQVcsWUFBWTtvQkFDdkNoQixJQUFJaUIsUUFBUSxDQUFDLEdBQUcsR0FBR2YsT0FBT0M7b0JBRTFCLHNDQUFzQztvQkFDdEMsTUFBTWUsUUFBUWYsU0FBVSxLQUFJUCxnQkFBZ0IsR0FBRTtvQkFFOUNJLElBQUlXLFNBQVM7b0JBQ2IsSUFBSyxJQUFJUSxJQUFJLEdBQUdBLEtBQUtqQixPQUFPaUIsSUFBSzt3QkFDL0IsTUFBTUMsSUFBSUYsUUFBUUwsS0FBS1EsR0FBRyxDQUFDLENBQUNGLElBQUlaLE1BQUssSUFBS0YsY0FBY0Q7d0JBQ3hESixJQUFJc0IsTUFBTSxDQUFDSCxHQUFHQztvQkFDaEI7b0JBQ0FwQixJQUFJc0IsTUFBTSxDQUFDcEIsT0FBT0M7b0JBQ2xCSCxJQUFJc0IsTUFBTSxDQUFDLEdBQUduQjtvQkFDZEgsSUFBSXVCLFNBQVM7b0JBRWJ2QixJQUFJZ0IsU0FBUyxHQUFHLFdBQVcsZUFBZTtvQkFDMUNoQixJQUFJd0IsSUFBSTtvQkFFUmpCLFVBQVVELFlBQVlEO29CQUN0QkcsbUJBQW1CaUIsc0JBQXNCaEI7Z0JBQzNDOztZQUVBQTtZQUVBOzBDQUFPLElBQU1pQixxQkFBcUJsQjs7UUFDcEM7aUNBQUc7UUFBQ1o7S0FBYztJQUVsQixxQkFDRSw4REFBQ0U7UUFDQzZCLEtBQUs5QjtRQUNMSyxPQUFPO1FBQ1BDLFFBQVE7UUFDUnlCLFdBQVU7Ozs7OztBQUdoQjtHQTlEd0JqQztLQUFBQSIsInNvdXJjZXMiOlsiRDpcXGNvZGluZ1xcZGFzaCBkeW5hbWljc1xcZGFzaGJvYXJkc1xcTG9jYWxiYWNrZW5kXFxjaGFyZ2luZy1zeXN0ZW1cXGNvbXBvbmVudHNcXFdhdmVDaGFyZ2luZy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG4vLyBpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xyXG4vLyBpbXBvcnQgeyBJbnRlciB9IGZyb20gXCJuZXh0L2ZvbnQvZ29vZ2xlXCI7XHJcbi8vIGltcG9ydCB7IFphcCB9IGZyb20gXCJsdWNpZGUtcmVhY3RcIjtcclxuLy8gY29uc3QgaW50ZXJUaGluID0gSW50ZXIoe1xyXG4vLyAgIHN1YnNldHM6IFtcImxhdGluXCJdLFxyXG4vLyAgIHdlaWdodDogW1wiMjAwXCJdLFxyXG4vLyAgIHZhcmlhYmxlOiBcIi0tZm9udC1pbnRlclwiLFxyXG4vLyB9KTtcclxuXHJcblxyXG4vLyBpbnRlcmZhY2UgV2F2ZUNoYXJnaW5nUHJvcHMge1xyXG4vLyAgIHBlcmNlbnRhZ2U/OiBudW1iZXI7XHJcbi8vICAgd2F2ZUNvbG9yPzogc3RyaW5nO1xyXG4vLyAgIGJhY2tncm91bmRDb2xvcj86IHN0cmluZztcclxuLy8gICBzaXplPzogbnVtYmVyO1xyXG4vLyB9XHJcblxyXG4vLyBjb25zdCBXYXZlQ2hhcmdpbmcgPSAoeyBcclxuLy8gICBwZXJjZW50YWdlID0gMCwgXHJcbi8vICAgd2F2ZUNvbG9yID0gXCJyZ2JhKDAsIDEyMywgMjU1LCAwLjcpXCIsXHJcbi8vICAgYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKDIyMCwgMjIwLCAyMjAsIDAuMilcIixcclxuLy8gICBzaXplID0gMTYwXHJcbi8vIH06IFdhdmVDaGFyZ2luZ1Byb3BzKSA9PiB7XHJcbi8vICAgY29uc3QgW3BoYXNlLCBzZXRQaGFzZV0gPSB1c2VTdGF0ZSgwKTtcclxuLy8gICBjb25zdCBjbGFtcGVkUGVyY2VudGFnZSA9IE1hdGgubWluKDEwMCwgTWF0aC5tYXgoMCwgcGVyY2VudGFnZSkpO1xyXG5cclxuXHJcbi8vICAgLy8gU21vb3RoZXIgYW5pbWF0aW9uIHVzaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBsZXQgYW5pbWF0aW9uRnJhbWVJZDogbnVtYmVyO1xyXG4vLyAgICAgbGV0IGxhc3RUaW1lID0gMDtcclxuLy8gICAgIGNvbnN0IGZwcyA9IDMwOyAvLyBUYXJnZXQgMzBmcHMgZm9yIHNtb290aGVyIGFuaW1hdGlvblxyXG4vLyAgICAgY29uc3QgaW50ZXJ2YWwgPSAxMDAwIC8gZnBzO1xyXG4gICBcclxuICAgXHJcblxyXG5cclxuLy8gICAgIGNvbnN0IGFuaW1hdGUgPSAodGltZTogbnVtYmVyKSA9PiB7XHJcbi8vICAgICAgIGlmICh0aW1lIC0gbGFzdFRpbWUgPiBpbnRlcnZhbCkge1xyXG4vLyAgICAgICAgIHNldFBoYXNlKChwcmV2KSA9PiAocHJldiArIDIpICUgMzYwKTsgLy8gU2xpZ2h0bHkgZmFzdGVyIHBoYXNlIGNoYW5nZVxyXG4vLyAgICAgICAgIGxhc3RUaW1lID0gdGltZTtcclxuLy8gICAgICAgfVxyXG4vLyAgICAgICBhbmltYXRpb25GcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4vLyAgICAgfTtcclxuXHJcbi8vICAgICBhbmltYXRpb25GcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4vLyAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpO1xyXG4vLyAgIH0sIFtdKTtcclxuXHJcbi8vICAgLy8gRHluYW1pYyB3YXZlIGFtcGxpdHVkZSBiYXNlZCBvbiBjaGFyZ2luZyBwZXJjZW50YWdlXHJcbi8vICAgY29uc3Qgd2F2ZUFtcGxpdHVkZSA9IHVzZU1lbW8oKCkgPT4ge1xyXG4vLyAgICAgcmV0dXJuIGNsYW1wZWRQZXJjZW50YWdlID4gOTAgPyAxIDogY2xhbXBlZFBlcmNlbnRhZ2UgPiA1MCA/IDIgOiAzO1xyXG4vLyAgIH0sIFtjbGFtcGVkUGVyY2VudGFnZV0pO1xyXG5cclxuLy8gICAvLyBNZW1vaXplZCB3YXZlIHBhdGggZm9yIGJldHRlciBwZXJmb3JtYW5jZVxyXG4vLyAgIGNvbnN0IHdhdmVQYXRoID0gdXNlTWVtbygoKSA9PiB7XHJcbi8vICAgICBjb25zdCB5UG9zID0gMTAwIC0gY2xhbXBlZFBlcmNlbnRhZ2U7XHJcbi8vICAgICByZXR1cm4gYE0wICR7eVBvc30gXHJcbi8vICAgICAgICAgICAgIFEyMCAke3lQb3MgKyBNYXRoLnNpbigocGhhc2UgKiBNYXRoLlBJKSAvIDE4MCkgKiB3YXZlQW1wbGl0dWRlfSBcclxuLy8gICAgICAgICAgICAgNDAgJHt5UG9zfSBcclxuLy8gICAgICAgICAgICAgVDEwMCAke3lQb3N9IFxyXG4vLyAgICAgICAgICAgICBWMTAwIEgwIFpgO1xyXG4vLyAgIH0sIFtwaGFzZSwgY2xhbXBlZFBlcmNlbnRhZ2UsIHdhdmVBbXBsaXR1ZGVdKTtcclxuXHJcbi8vICAgcmV0dXJuIChcclxuLy8gICAgIDxkaXZcclxuLy8gICAgICAgY2xhc3NOYW1lPVwicmVsYXRpdmUgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcm91bmRlZC1mdWxsIG92ZXJmbG93LWhpZGRlblwiXHJcbi8vICAgICAgIHN0eWxlPXt7XHJcbi8vICAgICAgICAgd2lkdGg6IGAke3NpemV9cHhgLFxyXG4vLyAgICAgICAgIGhlaWdodDogYCR7c2l6ZX1weGAsXHJcbi8vICAgICAgICAgYmFja2dyb3VuZENvbG9yLFxyXG4vLyAgICAgICAgIGJveFNoYWRvdzogYDBweCAwcHggMTVweCAke3dhdmVDb2xvcn1gLFxyXG4vLyAgICAgICB9fVxyXG4vLyAgICAgICByb2xlPVwicHJvZ3Jlc3NiYXJcIlxyXG4vLyAgICAgICBhcmlhLXZhbHVlbm93PXtjbGFtcGVkUGVyY2VudGFnZX1cclxuLy8gICAgICAgYXJpYS12YWx1ZW1pbj17MH1cclxuLy8gICAgICAgYXJpYS12YWx1ZW1heD17MTAwfVxyXG4vLyAgICAgPlxyXG4vLyAgICAgICA8c3ZnIFxyXG4vLyAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgdy1mdWxsIGgtZnVsbFwiIFxyXG4vLyAgICAgICAgIHZpZXdCb3g9XCIwIDAgMTAwIDEwMFwiIFxyXG4vLyAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCJcclxuLy8gICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxyXG4vLyAgICAgICA+XHJcbi8vICAgICAgICAgPHBhdGhcclxuLy8gICAgICAgICAgIGZpbGw9e3dhdmVDb2xvcn1cclxuLy8gICAgICAgICAgIGQ9e3dhdmVQYXRofVxyXG4vLyAgICAgICAgIC8+XHJcbi8vICAgICAgIDwvc3ZnPlxyXG5cclxuLy8gICAgICAgPHNwYW5cclxuLy8gICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LXdoaXRlIHRleHQtNHhsIGZvbnQtYm9sZCByZWxhdGl2ZSB6LTEwXCJcclxuLy8gICAgICAgICBzdHlsZT17e1xyXG4vLyAgICAgICAgICAgdGV4dFNoYWRvdzogXCIwIDAgOHB4IHJnYmEoMCwgMCwgMCwgMC41KVwiLFxyXG4vLyAgICAgICAgIH19XHJcbi8vICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcclxuLy8gICAgICAgPlxyXG4vLyAgICAgICAgIHtjbGFtcGVkUGVyY2VudGFnZX0lXHJcbi8vICAgICAgIDwvc3Bhbj5cclxuLy8gICAgIDwvZGl2PlxyXG4vLyAgICk7XHJcbi8vIH07XHJcblxyXG4vLyBleHBvcnQgZGVmYXVsdCBXYXZlQ2hhcmdpbmc7XHJcbid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW50ZXJmYWNlIFdhdmVDaGFyZ2luZ1Byb3BzIHtcclxuICBzYWZlUGVyY2VudGFnOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFdhdmVDaGFyZ2luZyh7IHNhZmVQZXJjZW50YWcgfTogV2F2ZUNoYXJnaW5nUHJvcHMpIHtcclxuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzLndpZHRoO1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcclxuICAgIGNvbnN0IHdhdmVIZWlnaHQgPSAxMDtcclxuICAgIGNvbnN0IHdhdmVMZW5ndGggPSA2MDtcclxuICAgIGNvbnN0IHdhdmVTcGVlZCA9IDAuMDU7XHJcblxyXG4gICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICBsZXQgYW5pbWF0aW9uRnJhbWVJZDogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0IGRyYXdXYXZlID0gKCkgPT4ge1xyXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgLy8gRHJhdyBjaXJjdWxhciBjbGlwXHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgY3R4LmFyYyh3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHdpZHRoIC8gMiwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICBjdHguY2xpcCgpO1xyXG5cclxuICAgICAgLy8gRHJhdyB3YXRlciBmaWxsIGJhY2tncm91bmRcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjMUU0MEFGJzsgLy8gZGFyayBibHVlXHJcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgIC8vIFdhdmUgeSBwb3NpdGlvbiBiYXNlZCBvbiBwZXJjZW50YWdlXHJcbiAgICAgIGNvbnN0IHdhdmVZID0gaGVpZ2h0ICogKDEgLSBzYWZlUGVyY2VudGFnIC8gMTAwKTtcclxuXHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPD0gd2lkdGg7IHgrKykge1xyXG4gICAgICAgIGNvbnN0IHkgPSB3YXZlWSArIE1hdGguc2luKCh4ICsgb2Zmc2V0KSAvIHdhdmVMZW5ndGgpICogd2F2ZUhlaWdodDtcclxuICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xyXG4gICAgICB9XHJcbiAgICAgIGN0eC5saW5lVG8od2lkdGgsIGhlaWdodCk7XHJcbiAgICAgIGN0eC5saW5lVG8oMCwgaGVpZ2h0KTtcclxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG5cclxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjNjBBNUZBJzsgLy8gbGlnaHRlciBibHVlXHJcbiAgICAgIGN0eC5maWxsKCk7XHJcblxyXG4gICAgICBvZmZzZXQgKz0gd2F2ZVNwZWVkICogd2F2ZUxlbmd0aDtcclxuICAgICAgYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3V2F2ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGRyYXdXYXZlKCk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpO1xyXG4gIH0sIFtzYWZlUGVyY2VudGFnXSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8Y2FudmFzXHJcbiAgICAgIHJlZj17Y2FudmFzUmVmfVxyXG4gICAgICB3aWR0aD17MjAwfVxyXG4gICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgY2xhc3NOYW1lPVwicm91bmRlZC1mdWxsIGJnLXRyYW5zcGFyZW50XCJcclxuICAgIC8+XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiV2F2ZUNoYXJnaW5nIiwic2FmZVBlcmNlbnRhZyIsImNhbnZhc1JlZiIsImNhbnZhcyIsImN1cnJlbnQiLCJjdHgiLCJnZXRDb250ZXh0Iiwid2lkdGgiLCJoZWlnaHQiLCJ3YXZlSGVpZ2h0Iiwid2F2ZUxlbmd0aCIsIndhdmVTcGVlZCIsIm9mZnNldCIsImFuaW1hdGlvbkZyYW1lSWQiLCJkcmF3V2F2ZSIsImNsZWFyUmVjdCIsImJlZ2luUGF0aCIsImFyYyIsIk1hdGgiLCJQSSIsImNsaXAiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsIndhdmVZIiwieCIsInkiLCJzaW4iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJmaWxsIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZWYiLCJjbGFzc05hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/WaveCharging.tsx\n"));

/***/ })

});