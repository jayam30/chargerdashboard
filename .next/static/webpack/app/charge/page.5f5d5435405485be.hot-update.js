"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/charge/page",{

/***/ "(app-pages-browser)/./components/WaveCharging.tsx":
/*!*************************************!*\
  !*** ./components/WaveCharging.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WaveCharging)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n// \"use client\";\n// import React, { useState, useEffect, useMemo } from \"react\";\n// import { Inter } from \"next/font/google\";\n// import { Zap } from \"lucide-react\";\n// const interThin = Inter({\n//   subsets: [\"latin\"],\n//   weight: [\"200\"],\n//   variable: \"--font-inter\",\n// });\n// interface WaveChargingProps {\n//   percentage?: number;\n//   waveColor?: string;\n//   backgroundColor?: string;\n//   size?: number;\n// }\n// const WaveCharging = ({\n//   percentage = 0,\n//   waveColor = \"rgba(0, 123, 255, 0.7)\",\n//   backgroundColor = \"rgba(220, 220, 220, 0.2)\",\n//   size = 160\n// }: WaveChargingProps) => {\n//   const [phase, setPhase] = useState(0);\n//   const clampedPercentage = Math.min(100, Math.max(0, percentage));\n//   // Smoother animation using requestAnimationFrame\n//   useEffect(() => {\n//     let animationFrameId: number;\n//     let lastTime = 0;\n//     const fps = 30; // Target 30fps for smoother animation\n//     const interval = 1000 / fps;\n//     const animate = (time: number) => {\n//       if (time - lastTime > interval) {\n//         setPhase((prev) => (prev + 2) % 360); // Slightly faster phase change\n//         lastTime = time;\n//       }\n//       animationFrameId = requestAnimationFrame(animate);\n//     };\n//     animationFrameId = requestAnimationFrame(animate);\n//     return () => cancelAnimationFrame(animationFrameId);\n//   }, []);\n//   // Dynamic wave amplitude based on charging percentage\n//   const waveAmplitude = useMemo(() => {\n//     return clampedPercentage > 90 ? 1 : clampedPercentage > 50 ? 2 : 3;\n//   }, [clampedPercentage]);\n//   // Memoized wave path for better performance\n//   const wavePath = useMemo(() => {\n//     const yPos = 100 - clampedPercentage;\n//     return `M0 ${yPos}\n//             Q20 ${yPos + Math.sin((phase * Math.PI) / 180) * waveAmplitude}\n//             40 ${yPos}\n//             T100 ${yPos}\n//             V100 H0 Z`;\n//   }, [phase, clampedPercentage, waveAmplitude]);\n//   return (\n//     <div\n//       className=\"relative flex items-center justify-center rounded-full overflow-hidden\"\n//       style={{\n//         width: `${size}px`,\n//         height: `${size}px`,\n//         backgroundColor,\n//         boxShadow: `0px 0px 15px ${waveColor}`,\n//       }}\n//       role=\"progressbar\"\n//       aria-valuenow={clampedPercentage}\n//       aria-valuemin={0}\n//       aria-valuemax={100}\n//     >\n//       <svg\n//         className=\"absolute inset-0 w-full h-full\"\n//         viewBox=\"0 0 100 100\"\n//         preserveAspectRatio=\"none\"\n//         aria-hidden=\"true\"\n//       >\n//         <path\n//           fill={waveColor}\n//           d={wavePath}\n//         />\n//       </svg>\n//       <span\n//         className=\"text-white text-4xl font-bold relative z-10\"\n//         style={{\n//           textShadow: \"0 0 8px rgba(0, 0, 0, 0.5)\",\n//         }}\n//         aria-hidden=\"true\"\n//       >\n//         {clampedPercentage}%\n//       </span>\n//     </div>\n//   );\n// };\n// export default WaveCharging;\n// 'use client';\n// import { useEffect, useRef } from 'react';\n// interface WaveChargingProps {\n//   safePercentag: number;\n// }\n// function getWaveGradient(ctx: CanvasRenderingContext2D, width: number, height: number, percent: number): CanvasGradient {\n//   const gradient = ctx.createLinearGradient(0, height, 0, 0);\n//   if (percent < 25) {\n//     gradient.addColorStop(0, '#ff3b30'); // red\n//     gradient.addColorStop(1, '#ff9500'); // orange\n//   } else if (percent < 50) {\n//     gradient.addColorStop(0, '#ffcc00'); // yellow\n//     gradient.addColorStop(1, '#34c759'); // green\n//   } else if (percent < 75) {\n//     gradient.addColorStop(0, '#34c759'); // green\n//     gradient.addColorStop(1, '#0a84ff'); // blue\n//   } else {\n//     gradient.addColorStop(0, '#0a84ff'); // blue\n//     gradient.addColorStop(1, '#5e5ce6'); // violet\n//   }\n//   return gradient;\n// }\n// export default function WaveCharging({ safePercentag }: WaveChargingProps) {\n//   const canvasRef = useRef<HTMLCanvasElement>(null);\n//   useEffect(() => {\n//     const canvas = canvasRef.current;\n//     if (!canvas) return;\n//     const ctx = canvas.getContext('2d');\n//     if (!ctx) return;\n//     const width = canvas.width;\n//     const height = canvas.height;\n//     const waveHeight = 12;\n//     const waveLength = 80;\n//     const waveSpeed = 0.08;\n//     const secondaryWaveOffset = 15;\n//     let offset = 0;\n//     let animationFrameId: number;\n//     const drawWave = () => {\n//       ctx.clearRect(0, 0, width, height);\n//       // Glassy background\n//       ctx.beginPath();\n//       ctx.arc(width / 2, height / 2, width / 2, 0, Math.PI * 2);\n//       ctx.closePath();\n//       ctx.fillStyle = 'rgba(15, 23, 42, 0.6)'; // Slate with alpha\n//       ctx.fill();\n//       // Clip the circle\n//       ctx.save();\n//       ctx.beginPath();\n//       ctx.arc(width / 2, height / 2, width / 2, 0, Math.PI * 2);\n//       ctx.clip();\n//       const waveY = height * (1 - safePercentag / 100);\n//       // Dynamic neon gradient\n//       const gradient = getWaveGradient(ctx, width, height, safePercentag);\n//       ctx.fillStyle = gradient;\n//       ctx.shadowColor = gradient as any;\n//       ctx.shadowBlur = 25;\n//       // Main wave\n//       ctx.beginPath();\n//       for (let x = 0; x <= width; x++) {\n//         const y = waveY + Math.sin((x + offset) / waveLength) * waveHeight;\n//         ctx.lineTo(x, y);\n//       }\n//       ctx.lineTo(width, height);\n//       ctx.lineTo(0, height);\n//       ctx.closePath();\n//       ctx.fill();\n//       // Second wave layer (lighter & transparent)\n//       ctx.globalAlpha = 0.4;\n//       ctx.beginPath();\n//       for (let x = 0; x <= width; x++) {\n//         const y = waveY + Math.sin((x + offset + secondaryWaveOffset) / waveLength) * (waveHeight - 4);\n//         ctx.lineTo(x, y);\n//       }\n//       ctx.lineTo(width, height);\n//       ctx.lineTo(0, height);\n//       ctx.closePath();\n//       ctx.fill();\n//       ctx.globalAlpha = 1;\n//       ctx.restore();\n//       offset += waveSpeed * waveLength;\n//       animationFrameId = requestAnimationFrame(drawWave);\n//     };\n//     drawWave();\n//     return () => cancelAnimationFrame(animationFrameId);\n//   }, [safePercentag]);\n//   return (\n//     <canvas\n//       ref={canvasRef}\n//       width={200}\n//       height={200}\n//       className=\"rounded-full backdrop-blur-md bg-transparent border-2 border-white/10 shadow-2xl\"\n//     />\n//   );\n// }\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction getWaveColor(percent) {\n    // Clamp between 0 and 100\n    const p = Math.max(0, Math.min(percent, 100));\n    // Custom blend: Red → Yellow → Blue → Green\n    let r = 0, g = 0, b = 0;\n    if (p < 25) {\n        // Red to Yellow\n        r = 255;\n        g = Math.round(p / 25 * 255);\n        b = 0;\n    } else if (p < 50) {\n        // Yellow to Blue\n        r = Math.round(255 - (p - 25) / 25 * 255);\n        g = 255;\n        b = Math.round((p - 25) / 25 * 255);\n    } else if (p < 75) {\n        // Blue to Cyan\n        r = 0;\n        g = Math.round(255 - (p - 50) / 25 * 155);\n        b = 255;\n    } else {\n        // Cyan to Green\n        r = 0;\n        g = 255;\n        b = Math.round(255 - (p - 75) / 25 * 255);\n    }\n    return \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n}\nfunction WaveCharging(param) {\n    let { safePercentag } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WaveCharging.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const ctx = canvas.getContext('2d');\n            if (!ctx) return;\n            const width = canvas.width;\n            const height = canvas.height;\n            const waveHeight = 10;\n            const waveLength = 60;\n            const waveSpeed = 0.05;\n            let offset = 0;\n            let animationFrameId;\n            const drawWave = {\n                \"WaveCharging.useEffect.drawWave\": ()=>{\n                    ctx.clearRect(0, 0, width, height);\n                    // Clip in a circle\n                    ctx.beginPath();\n                    ctx.arc(width / 2, height / 2, width / 2, 0, Math.PI * 2);\n                    ctx.clip();\n                    // Background\n                    ctx.fillStyle = '#0f172a'; // dark slate\n                    ctx.fillRect(0, 0, width, height);\n                    const waveY = height * (1 - safePercentag / 100);\n                    // Dynamic wave color\n                    ctx.beginPath();\n                    for(let x = 0; x <= width; x++){\n                        const y = waveY + Math.sin((x + offset) / waveLength) * waveHeight;\n                        ctx.lineTo(x, y);\n                    }\n                    ctx.lineTo(width, height);\n                    ctx.lineTo(0, height);\n                    ctx.closePath();\n                    ctx.fillStyle = getWaveColor(safePercentag);\n                    ctx.shadowColor = ctx.fillStyle;\n                    ctx.shadowBlur = 20;\n                    ctx.fill();\n                    offset += waveSpeed * waveLength;\n                    animationFrameId = requestAnimationFrame(drawWave);\n                }\n            }[\"WaveCharging.useEffect.drawWave\"];\n            drawWave();\n            return ({\n                \"WaveCharging.useEffect\": ()=>cancelAnimationFrame(animationFrameId)\n            })[\"WaveCharging.useEffect\"];\n        }\n    }[\"WaveCharging.useEffect\"], [\n        safePercentag\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        width: 200,\n        height: 200,\n        className: \"rounded-full bg-transparent\"\n    }, void 0, false, {\n        fileName: \"D:\\\\coding\\\\dash dynamics\\\\dashboards\\\\Localbackend\\\\charging-system\\\\components\\\\WaveCharging.tsx\",\n        lineNumber: 319,\n        columnNumber: 5\n    }, this);\n} // 'use client';\n // import { useEffect, useRef, useState } from 'react';\n // interface WaveChargingProps {\n //   safePercentag: number;\n //   charging: boolean;\n // }\n // function getWaveGradient(ctx: CanvasRenderingContext2D, width: number, height: number, percent: number): CanvasGradient {\n //   const gradient = ctx.createLinearGradient(0, height, 0, 0);\n //   if (percent < 25) {\n //     gradient.addColorStop(0, '#ff3b30'); // red\n //     gradient.addColorStop(1, '#ff9500'); // orange\n //   } else if (percent < 50) {\n //     gradient.addColorStop(0, '#ffcc00'); // yellow\n //     gradient.addColorStop(1, '#34c759'); // green\n //   } else if (percent < 75) {\n //     gradient.addColorStop(0, '#34c759'); // green\n //     gradient.addColorStop(1, '#0a84ff'); // blue\n //   } else {\n //     gradient.addColorStop(0, '#0a84ff'); // blue\n //     gradient.addColorStop(1, '#5e5ce6'); // violet\n //   }\n //   return gradient;\n // }\n // export default function WaveCharging({ safePercentag, charging }: WaveChargingProps) {\n //   const canvasRef = useRef<HTMLCanvasElement>(null);\n //   const rippleRef = useRef<HTMLDivElement>(null);\n //   const [prevPercent, setPrevPercent] = useState(safePercentag);\n //   useEffect(() => {\n //     if (safePercentag !== prevPercent && charging) {\n //       // Trigger ripple effect\n //       if (rippleRef.current) {\n //         rippleRef.current.classList.remove('ripple-animate');\n //         void rippleRef.current.offsetWidth; // Trigger reflow\n //         rippleRef.current.classList.add('ripple-animate');\n //       }\n //       setPrevPercent(safePercentag);\n //     }\n //   }, [safePercentag, charging, prevPercent]);\n //   useEffect(() => {\n //     const canvas = canvasRef.current;\n //     if (!canvas) return;\n //     const ctx = canvas.getContext('2d');\n //     if (!ctx) return;\n //     const width = canvas.width;\n //     const height = canvas.height;\n //     const waveHeight = 12;\n //     const waveLength = 80;\n //     const waveSpeed = 0.08;\n //     const secondaryWaveOffset = 15;\n //     let offset = 0;\n //     let animationFrameId: number;\n //     // Sparkle effect params\n //     const sparkles: { x: number; y: number; radius: number; alpha: number; delta: number }[] = [];\n //     const maxSparkles = 8;\n //     // Initialize sparkles randomly around the wave area\n //     for (let i = 0; i < maxSparkles; i++) {\n //       sparkles.push({\n //         x: Math.random() * width,\n //         y: height * 0.5 + Math.random() * height * 0.5,\n //         radius: 1 + Math.random() * 2,\n //         alpha: Math.random(),\n //         delta: 0.02 + Math.random() * 0.03,\n //       });\n //     }\n //     const drawSparkles = () => {\n //       sparkles.forEach((s) => {\n //         s.alpha += s.delta;\n //         if (s.alpha > 1 || s.alpha < 0) s.delta = -s.delta;\n //         ctx.beginPath();\n //         ctx.shadowColor = 'white';\n //         ctx.shadowBlur = 6;\n //         ctx.fillStyle = `rgba(255,255,255,${s.alpha.toFixed(2)})`;\n //         ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);\n //         ctx.fill();\n //         ctx.shadowBlur = 0;\n //       });\n //     };\n //     const drawWave = () => {\n //       ctx.clearRect(0, 0, width, height);\n //       // Glassy background circle\n //       ctx.beginPath();\n //       ctx.arc(width / 2, height / 2, width / 2, 0, Math.PI * 2);\n //       ctx.closePath();\n //       ctx.fillStyle = 'rgba(15, 23, 42, 0.7)'; // Slightly darker glass\n //       ctx.fill();\n //       ctx.save();\n //       ctx.beginPath();\n //       ctx.arc(width / 2, height / 2, width / 2, 0, Math.PI * 2);\n //       ctx.clip();\n //       const waveY = height * (1 - safePercentag / 100);\n //       // Dynamic neon gradient\n //       const gradient = getWaveGradient(ctx, width, height, safePercentag);\n //       ctx.fillStyle = gradient;\n //       ctx.shadowColor = gradient as any;\n //       ctx.shadowBlur = 25;\n //       // Main wave\n //       ctx.beginPath();\n //       for (let x = 0; x <= width; x++) {\n //         const y = waveY + Math.sin((x + offset) / waveLength) * waveHeight;\n //         ctx.lineTo(x, y);\n //       }\n //       ctx.lineTo(width, height);\n //       ctx.lineTo(0, height);\n //       ctx.closePath();\n //       ctx.fill();\n //       // Secondary wave layer (lighter)\n //       ctx.globalAlpha = 0.3;\n //       ctx.beginPath();\n //       for (let x = 0; x <= width; x++) {\n //         const y = waveY + Math.sin((x + offset + secondaryWaveOffset) / waveLength) * (waveHeight - 6);\n //         ctx.lineTo(x, y);\n //       }\n //       ctx.lineTo(width, height);\n //       ctx.lineTo(0, height);\n //       ctx.closePath();\n //       ctx.fill();\n //       ctx.globalAlpha = 1;\n //       // Draw sparkles\n //       drawSparkles();\n //       ctx.restore();\n //       // Pulse effect if 100%\n //       if (safePercentag >= 100) {\n //         const pulseRadius = 100 + Math.sin(offset * 0.3) * 10;\n //         ctx.beginPath();\n //         ctx.arc(width / 2, height / 2, pulseRadius, 0, Math.PI * 2);\n //         ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';\n //         ctx.lineWidth = 6;\n //         ctx.shadowColor = 'cyan';\n //         ctx.shadowBlur = 30;\n //         ctx.stroke();\n //       }\n //       offset += waveSpeed * waveLength;\n //       animationFrameId = requestAnimationFrame(drawWave);\n //     };\n //     drawWave();\n //     return () => cancelAnimationFrame(animationFrameId);\n //   }, [safePercentag]);\n //   return (\n //     <div className=\"relative w-[220px] h-[220px] rounded-full bg-gradient-to-br from-[#111827] via-[#1e293b] to-[#0f172a] shadow-2xl shadow-cyan-900/40 flex items-center justify-center select-none\">\n //       <canvas\n //         ref={canvasRef}\n //         width={220}\n //         height={220}\n //         className=\"rounded-full\"\n //       />\n //       {/* Ripple effect */}\n //       <div\n //         ref={rippleRef}\n //         className=\"pointer-events-none absolute rounded-full border-2 border-cyan-400 opacity-0\"\n //         style={{\n //           width: 220,\n //           height: 220,\n //           top: 0,\n //           left: 0,\n //           boxShadow: '0 0 15px 3px cyan',\n //           transition: 'opacity 0.3s ease-in-out, transform 0.5s ease-out',\n //         }}\n //       />\n //       {/* Center SOC Text */}\n //       <div className=\"absolute inset-0 flex flex-col items-center justify-center text-cyan-400 font-extrabold select-none pointer-events-none\">\n //         <span className=\"text-6xl drop-shadow-lg\">{safePercentag}%</span>\n //         <span className=\"uppercase text-xs tracking-widest drop-shadow-md text-cyan-300\">\n //           Charge Level\n //         </span>\n //       </div>\n //       <style jsx>{`\n //         .ripple-animate {\n //           opacity: 0.6 !important;\n //           transform: scale(1.3);\n //           transition: opacity 0.6s ease-out, transform 0.6s ease-out;\n //         }\n //       `}</style>\n //     </div>\n //   );\n // }\n_s(WaveCharging, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = WaveCharging;\nvar _c;\n$RefreshReg$(_c, \"WaveCharging\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvV2F2ZUNoYXJnaW5nLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0EsZ0JBQWdCO0FBQ2hCLCtEQUErRDtBQUMvRCw0Q0FBNEM7QUFDNUMsc0NBQXNDO0FBQ3RDLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCLDhCQUE4QjtBQUM5QixNQUFNO0FBR04sZ0NBQWdDO0FBQ2hDLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsOEJBQThCO0FBQzlCLG1CQUFtQjtBQUNuQixJQUFJO0FBRUosMEJBQTBCO0FBQzFCLG9CQUFvQjtBQUNwQiwwQ0FBMEM7QUFDMUMsa0RBQWtEO0FBQ2xELGVBQWU7QUFDZiw2QkFBNkI7QUFDN0IsMkNBQTJDO0FBQzNDLHNFQUFzRTtBQUd0RSxzREFBc0Q7QUFDdEQsc0JBQXNCO0FBQ3RCLG9DQUFvQztBQUNwQyx3QkFBd0I7QUFDeEIsNkRBQTZEO0FBQzdELG1DQUFtQztBQUtuQywwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLGdGQUFnRjtBQUNoRiwyQkFBMkI7QUFDM0IsVUFBVTtBQUNWLDJEQUEyRDtBQUMzRCxTQUFTO0FBRVQseURBQXlEO0FBQ3pELDJEQUEyRDtBQUMzRCxZQUFZO0FBRVosMkRBQTJEO0FBQzNELDBDQUEwQztBQUMxQywwRUFBMEU7QUFDMUUsNkJBQTZCO0FBRTdCLGlEQUFpRDtBQUNqRCxxQ0FBcUM7QUFDckMsNENBQTRDO0FBQzVDLHlCQUF5QjtBQUN6Qiw4RUFBOEU7QUFDOUUseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsbURBQW1EO0FBRW5ELGFBQWE7QUFDYixXQUFXO0FBQ1gsMkZBQTJGO0FBQzNGLGlCQUFpQjtBQUNqQiw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CLDJCQUEyQjtBQUMzQixrREFBa0Q7QUFDbEQsV0FBVztBQUNYLDJCQUEyQjtBQUMzQiwwQ0FBMEM7QUFDMUMsMEJBQTBCO0FBQzFC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QUE0QztDQUM1Qyw2RUFBNkU7Q0FDN0UsYUFBYTtDQUNiLFdBQVc7Q0FFWCxnQ0FBZ0M7Q0FDaEMsa0pBQWtKO0NBQ2xKLDRFQUE0RTtDQUM1RSw0RkFBNEY7Q0FDNUYseUJBQXlCO0NBQ3pCLGtCQUFrQjtDQUNsQixlQUFlO0NBRWYsc0JBQXNCO0NBQ3RCLDRCQUE0QjtDQUM1QixxQ0FBcUM7Q0FDckMsbUNBQW1DO0NBQ25DLHdFQUF3RTtDQUN4RSxZQUFZO0NBQ1osbUJBQW1CO0NBQ25CLGFBQWE7Q0FDYixPQUFPO0NBQ1AsSUFBSTtHQTlRb0JsQztLQUFBQSIsInNvdXJjZXMiOlsiRDpcXGNvZGluZ1xcZGFzaCBkeW5hbWljc1xcZGFzaGJvYXJkc1xcTG9jYWxiYWNrZW5kXFxjaGFyZ2luZy1zeXN0ZW1cXGNvbXBvbmVudHNcXFdhdmVDaGFyZ2luZy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG4vLyBpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xyXG4vLyBpbXBvcnQgeyBJbnRlciB9IGZyb20gXCJuZXh0L2ZvbnQvZ29vZ2xlXCI7XHJcbi8vIGltcG9ydCB7IFphcCB9IGZyb20gXCJsdWNpZGUtcmVhY3RcIjtcclxuLy8gY29uc3QgaW50ZXJUaGluID0gSW50ZXIoe1xyXG4vLyAgIHN1YnNldHM6IFtcImxhdGluXCJdLFxyXG4vLyAgIHdlaWdodDogW1wiMjAwXCJdLFxyXG4vLyAgIHZhcmlhYmxlOiBcIi0tZm9udC1pbnRlclwiLFxyXG4vLyB9KTtcclxuXHJcblxyXG4vLyBpbnRlcmZhY2UgV2F2ZUNoYXJnaW5nUHJvcHMge1xyXG4vLyAgIHBlcmNlbnRhZ2U/OiBudW1iZXI7XHJcbi8vICAgd2F2ZUNvbG9yPzogc3RyaW5nO1xyXG4vLyAgIGJhY2tncm91bmRDb2xvcj86IHN0cmluZztcclxuLy8gICBzaXplPzogbnVtYmVyO1xyXG4vLyB9XHJcblxyXG4vLyBjb25zdCBXYXZlQ2hhcmdpbmcgPSAoe1xyXG4vLyAgIHBlcmNlbnRhZ2UgPSAwLFxyXG4vLyAgIHdhdmVDb2xvciA9IFwicmdiYSgwLCAxMjMsIDI1NSwgMC43KVwiLFxyXG4vLyAgIGJhY2tncm91bmRDb2xvciA9IFwicmdiYSgyMjAsIDIyMCwgMjIwLCAwLjIpXCIsXHJcbi8vICAgc2l6ZSA9IDE2MFxyXG4vLyB9OiBXYXZlQ2hhcmdpbmdQcm9wcykgPT4ge1xyXG4vLyAgIGNvbnN0IFtwaGFzZSwgc2V0UGhhc2VdID0gdXNlU3RhdGUoMCk7XHJcbi8vICAgY29uc3QgY2xhbXBlZFBlcmNlbnRhZ2UgPSBNYXRoLm1pbigxMDAsIE1hdGgubWF4KDAsIHBlcmNlbnRhZ2UpKTtcclxuXHJcblxyXG4vLyAgIC8vIFNtb290aGVyIGFuaW1hdGlvbiB1c2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgbGV0IGFuaW1hdGlvbkZyYW1lSWQ6IG51bWJlcjtcclxuLy8gICAgIGxldCBsYXN0VGltZSA9IDA7XHJcbi8vICAgICBjb25zdCBmcHMgPSAzMDsgLy8gVGFyZ2V0IDMwZnBzIGZvciBzbW9vdGhlciBhbmltYXRpb25cclxuLy8gICAgIGNvbnN0IGludGVydmFsID0gMTAwMCAvIGZwcztcclxuICAgXHJcbiAgIFxyXG5cclxuXHJcbi8vICAgICBjb25zdCBhbmltYXRlID0gKHRpbWU6IG51bWJlcikgPT4ge1xyXG4vLyAgICAgICBpZiAodGltZSAtIGxhc3RUaW1lID4gaW50ZXJ2YWwpIHtcclxuLy8gICAgICAgICBzZXRQaGFzZSgocHJldikgPT4gKHByZXYgKyAyKSAlIDM2MCk7IC8vIFNsaWdodGx5IGZhc3RlciBwaGFzZSBjaGFuZ2VcclxuLy8gICAgICAgICBsYXN0VGltZSA9IHRpbWU7XHJcbi8vICAgICAgIH1cclxuLy8gICAgICAgYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuLy8gICAgIH07XHJcblxyXG4vLyAgICAgYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuLy8gICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkKTtcclxuLy8gICB9LCBbXSk7XHJcblxyXG4vLyAgIC8vIER5bmFtaWMgd2F2ZSBhbXBsaXR1ZGUgYmFzZWQgb24gY2hhcmdpbmcgcGVyY2VudGFnZVxyXG4vLyAgIGNvbnN0IHdhdmVBbXBsaXR1ZGUgPSB1c2VNZW1vKCgpID0+IHtcclxuLy8gICAgIHJldHVybiBjbGFtcGVkUGVyY2VudGFnZSA+IDkwID8gMSA6IGNsYW1wZWRQZXJjZW50YWdlID4gNTAgPyAyIDogMztcclxuLy8gICB9LCBbY2xhbXBlZFBlcmNlbnRhZ2VdKTtcclxuXHJcbi8vICAgLy8gTWVtb2l6ZWQgd2F2ZSBwYXRoIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcclxuLy8gICBjb25zdCB3YXZlUGF0aCA9IHVzZU1lbW8oKCkgPT4ge1xyXG4vLyAgICAgY29uc3QgeVBvcyA9IDEwMCAtIGNsYW1wZWRQZXJjZW50YWdlO1xyXG4vLyAgICAgcmV0dXJuIGBNMCAke3lQb3N9XHJcbi8vICAgICAgICAgICAgIFEyMCAke3lQb3MgKyBNYXRoLnNpbigocGhhc2UgKiBNYXRoLlBJKSAvIDE4MCkgKiB3YXZlQW1wbGl0dWRlfVxyXG4vLyAgICAgICAgICAgICA0MCAke3lQb3N9XHJcbi8vICAgICAgICAgICAgIFQxMDAgJHt5UG9zfVxyXG4vLyAgICAgICAgICAgICBWMTAwIEgwIFpgO1xyXG4vLyAgIH0sIFtwaGFzZSwgY2xhbXBlZFBlcmNlbnRhZ2UsIHdhdmVBbXBsaXR1ZGVdKTtcclxuXHJcbi8vICAgcmV0dXJuIChcclxuLy8gICAgIDxkaXZcclxuLy8gICAgICAgY2xhc3NOYW1lPVwicmVsYXRpdmUgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcm91bmRlZC1mdWxsIG92ZXJmbG93LWhpZGRlblwiXHJcbi8vICAgICAgIHN0eWxlPXt7XHJcbi8vICAgICAgICAgd2lkdGg6IGAke3NpemV9cHhgLFxyXG4vLyAgICAgICAgIGhlaWdodDogYCR7c2l6ZX1weGAsXHJcbi8vICAgICAgICAgYmFja2dyb3VuZENvbG9yLFxyXG4vLyAgICAgICAgIGJveFNoYWRvdzogYDBweCAwcHggMTVweCAke3dhdmVDb2xvcn1gLFxyXG4vLyAgICAgICB9fVxyXG4vLyAgICAgICByb2xlPVwicHJvZ3Jlc3NiYXJcIlxyXG4vLyAgICAgICBhcmlhLXZhbHVlbm93PXtjbGFtcGVkUGVyY2VudGFnZX1cclxuLy8gICAgICAgYXJpYS12YWx1ZW1pbj17MH1cclxuLy8gICAgICAgYXJpYS12YWx1ZW1heD17MTAwfVxyXG4vLyAgICAgPlxyXG4vLyAgICAgICA8c3ZnXHJcbi8vICAgICAgICAgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCB3LWZ1bGwgaC1mdWxsXCJcclxuLy8gICAgICAgICB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIlxyXG4vLyAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCJcclxuLy8gICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxyXG4vLyAgICAgICA+XHJcbi8vICAgICAgICAgPHBhdGhcclxuLy8gICAgICAgICAgIGZpbGw9e3dhdmVDb2xvcn1cclxuLy8gICAgICAgICAgIGQ9e3dhdmVQYXRofVxyXG4vLyAgICAgICAgIC8+XHJcbi8vICAgICAgIDwvc3ZnPlxyXG5cclxuLy8gICAgICAgPHNwYW5cclxuLy8gICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LXdoaXRlIHRleHQtNHhsIGZvbnQtYm9sZCByZWxhdGl2ZSB6LTEwXCJcclxuLy8gICAgICAgICBzdHlsZT17e1xyXG4vLyAgICAgICAgICAgdGV4dFNoYWRvdzogXCIwIDAgOHB4IHJnYmEoMCwgMCwgMCwgMC41KVwiLFxyXG4vLyAgICAgICAgIH19XHJcbi8vICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcclxuLy8gICAgICAgPlxyXG4vLyAgICAgICAgIHtjbGFtcGVkUGVyY2VudGFnZX0lXHJcbi8vICAgICAgIDwvc3Bhbj5cclxuLy8gICAgIDwvZGl2PlxyXG4vLyAgICk7XHJcbi8vIH07XHJcblxyXG4vLyBleHBvcnQgZGVmYXVsdCBXYXZlQ2hhcmdpbmc7XHJcbi8vICd1c2UgY2xpZW50JztcclxuXHJcbi8vIGltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuLy8gaW50ZXJmYWNlIFdhdmVDaGFyZ2luZ1Byb3BzIHtcclxuLy8gICBzYWZlUGVyY2VudGFnOiBudW1iZXI7XHJcbi8vIH1cclxuXHJcbi8vIGZ1bmN0aW9uIGdldFdhdmVHcmFkaWVudChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHBlcmNlbnQ6IG51bWJlcik6IENhbnZhc0dyYWRpZW50IHtcclxuLy8gICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCBoZWlnaHQsIDAsIDApO1xyXG5cclxuLy8gICBpZiAocGVyY2VudCA8IDI1KSB7XHJcbi8vICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyNmZjNiMzAnKTsgLy8gcmVkXHJcbi8vICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJyNmZjk1MDAnKTsgLy8gb3JhbmdlXHJcbi8vICAgfSBlbHNlIGlmIChwZXJjZW50IDwgNTApIHtcclxuLy8gICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAnI2ZmY2MwMCcpOyAvLyB5ZWxsb3dcclxuLy8gICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzM0Yzc1OScpOyAvLyBncmVlblxyXG4vLyAgIH0gZWxzZSBpZiAocGVyY2VudCA8IDc1KSB7XHJcbi8vICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyMzNGM3NTknKTsgLy8gZ3JlZW5cclxuLy8gICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzBhODRmZicpOyAvLyBibHVlXHJcbi8vICAgfSBlbHNlIHtcclxuLy8gICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAnIzBhODRmZicpOyAvLyBibHVlXHJcbi8vICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJyM1ZTVjZTYnKTsgLy8gdmlvbGV0XHJcbi8vICAgfVxyXG5cclxuLy8gICByZXR1cm4gZ3JhZGllbnQ7XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFdhdmVDaGFyZ2luZyh7IHNhZmVQZXJjZW50YWcgfTogV2F2ZUNoYXJnaW5nUHJvcHMpIHtcclxuLy8gICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xyXG5cclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbi8vICAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG4vLyAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbi8vICAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuLy8gICAgIGNvbnN0IHdpZHRoID0gY2FudmFzLndpZHRoO1xyXG4vLyAgICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcclxuXHJcbi8vICAgICBjb25zdCB3YXZlSGVpZ2h0ID0gMTI7XHJcbi8vICAgICBjb25zdCB3YXZlTGVuZ3RoID0gODA7XHJcbi8vICAgICBjb25zdCB3YXZlU3BlZWQgPSAwLjA4O1xyXG4vLyAgICAgY29uc3Qgc2Vjb25kYXJ5V2F2ZU9mZnNldCA9IDE1O1xyXG5cclxuLy8gICAgIGxldCBvZmZzZXQgPSAwO1xyXG4vLyAgICAgbGV0IGFuaW1hdGlvbkZyYW1lSWQ6IG51bWJlcjtcclxuXHJcbi8vICAgICBjb25zdCBkcmF3V2F2ZSA9ICgpID0+IHtcclxuLy8gICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbi8vICAgICAgIC8vIEdsYXNzeSBiYWNrZ3JvdW5kXHJcbi8vICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuLy8gICAgICAgY3R4LmFyYyh3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHdpZHRoIC8gMiwgMCwgTWF0aC5QSSAqIDIpO1xyXG4vLyAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbi8vICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgxNSwgMjMsIDQyLCAwLjYpJzsgLy8gU2xhdGUgd2l0aCBhbHBoYVxyXG4vLyAgICAgICBjdHguZmlsbCgpO1xyXG5cclxuLy8gICAgICAgLy8gQ2xpcCB0aGUgY2lyY2xlXHJcbi8vICAgICAgIGN0eC5zYXZlKCk7XHJcbi8vICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuLy8gICAgICAgY3R4LmFyYyh3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHdpZHRoIC8gMiwgMCwgTWF0aC5QSSAqIDIpO1xyXG4vLyAgICAgICBjdHguY2xpcCgpO1xyXG5cclxuLy8gICAgICAgY29uc3Qgd2F2ZVkgPSBoZWlnaHQgKiAoMSAtIHNhZmVQZXJjZW50YWcgLyAxMDApO1xyXG5cclxuLy8gICAgICAgLy8gRHluYW1pYyBuZW9uIGdyYWRpZW50XHJcbi8vICAgICAgIGNvbnN0IGdyYWRpZW50ID0gZ2V0V2F2ZUdyYWRpZW50KGN0eCwgd2lkdGgsIGhlaWdodCwgc2FmZVBlcmNlbnRhZyk7XHJcbi8vICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcclxuLy8gICAgICAgY3R4LnNoYWRvd0NvbG9yID0gZ3JhZGllbnQgYXMgYW55O1xyXG4vLyAgICAgICBjdHguc2hhZG93Qmx1ciA9IDI1O1xyXG5cclxuLy8gICAgICAgLy8gTWFpbiB3YXZlXHJcbi8vICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuLy8gICAgICAgZm9yIChsZXQgeCA9IDA7IHggPD0gd2lkdGg7IHgrKykge1xyXG4vLyAgICAgICAgIGNvbnN0IHkgPSB3YXZlWSArIE1hdGguc2luKCh4ICsgb2Zmc2V0KSAvIHdhdmVMZW5ndGgpICogd2F2ZUhlaWdodDtcclxuLy8gICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xyXG4vLyAgICAgICB9XHJcbi8vICAgICAgIGN0eC5saW5lVG8od2lkdGgsIGhlaWdodCk7XHJcbi8vICAgICAgIGN0eC5saW5lVG8oMCwgaGVpZ2h0KTtcclxuLy8gICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4vLyAgICAgICBjdHguZmlsbCgpO1xyXG5cclxuLy8gICAgICAgLy8gU2Vjb25kIHdhdmUgbGF5ZXIgKGxpZ2h0ZXIgJiB0cmFuc3BhcmVudClcclxuLy8gICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC40O1xyXG4vLyAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbi8vICAgICAgIGZvciAobGV0IHggPSAwOyB4IDw9IHdpZHRoOyB4KyspIHtcclxuLy8gICAgICAgICBjb25zdCB5ID0gd2F2ZVkgKyBNYXRoLnNpbigoeCArIG9mZnNldCArIHNlY29uZGFyeVdhdmVPZmZzZXQpIC8gd2F2ZUxlbmd0aCkgKiAod2F2ZUhlaWdodCAtIDQpO1xyXG4vLyAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XHJcbi8vICAgICAgIH1cclxuLy8gICAgICAgY3R4LmxpbmVUbyh3aWR0aCwgaGVpZ2h0KTtcclxuLy8gICAgICAgY3R4LmxpbmVUbygwLCBoZWlnaHQpO1xyXG4vLyAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbi8vICAgICAgIGN0eC5maWxsKCk7XHJcbi8vICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XHJcblxyXG4vLyAgICAgICBjdHgucmVzdG9yZSgpO1xyXG5cclxuLy8gICAgICAgb2Zmc2V0ICs9IHdhdmVTcGVlZCAqIHdhdmVMZW5ndGg7XHJcbi8vICAgICAgIGFuaW1hdGlvbkZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhd1dhdmUpO1xyXG4vLyAgICAgfTtcclxuXHJcbi8vICAgICBkcmF3V2F2ZSgpO1xyXG4vLyAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpO1xyXG4vLyAgIH0sIFtzYWZlUGVyY2VudGFnXSk7XHJcblxyXG4vLyAgIHJldHVybiAoXHJcbi8vICAgICA8Y2FudmFzXHJcbi8vICAgICAgIHJlZj17Y2FudmFzUmVmfVxyXG4vLyAgICAgICB3aWR0aD17MjAwfVxyXG4vLyAgICAgICBoZWlnaHQ9ezIwMH1cclxuLy8gICAgICAgY2xhc3NOYW1lPVwicm91bmRlZC1mdWxsIGJhY2tkcm9wLWJsdXItbWQgYmctdHJhbnNwYXJlbnQgYm9yZGVyLTIgYm9yZGVyLXdoaXRlLzEwIHNoYWRvdy0yeGxcIlxyXG4vLyAgICAgLz5cclxuLy8gICApO1xyXG4vLyB9XHJcbid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW50ZXJmYWNlIFdhdmVDaGFyZ2luZ1Byb3BzIHtcclxuICBzYWZlUGVyY2VudGFnOiBudW1iZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFdhdmVDb2xvcihwZXJjZW50OiBudW1iZXIpOiBzdHJpbmcge1xyXG4gIC8vIENsYW1wIGJldHdlZW4gMCBhbmQgMTAwXHJcbiAgY29uc3QgcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBlcmNlbnQsIDEwMCkpO1xyXG5cclxuICAvLyBDdXN0b20gYmxlbmQ6IFJlZCDihpIgWWVsbG93IOKGkiBCbHVlIOKGkiBHcmVlblxyXG4gIGxldCByID0gMCwgZyA9IDAsIGIgPSAwO1xyXG5cclxuICBpZiAocCA8IDI1KSB7XHJcbiAgICAvLyBSZWQgdG8gWWVsbG93XHJcbiAgICByID0gMjU1O1xyXG4gICAgZyA9IE1hdGgucm91bmQoKHAgLyAyNSkgKiAyNTUpO1xyXG4gICAgYiA9IDA7XHJcbiAgfSBlbHNlIGlmIChwIDwgNTApIHtcclxuICAgIC8vIFllbGxvdyB0byBCbHVlXHJcbiAgICByID0gTWF0aC5yb3VuZCgyNTUgLSAoKHAgLSAyNSkgLyAyNSkgKiAyNTUpO1xyXG4gICAgZyA9IDI1NTtcclxuICAgIGIgPSBNYXRoLnJvdW5kKCgocCAtIDI1KSAvIDI1KSAqIDI1NSk7XHJcbiAgfSBlbHNlIGlmIChwIDwgNzUpIHtcclxuICAgIC8vIEJsdWUgdG8gQ3lhblxyXG4gICAgciA9IDA7XHJcbiAgICBnID0gTWF0aC5yb3VuZCgyNTUgLSAoKHAgLSA1MCkgLyAyNSkgKiAxNTUpO1xyXG4gICAgYiA9IDI1NTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gQ3lhbiB0byBHcmVlblxyXG4gICAgciA9IDA7XHJcbiAgICBnID0gMjU1O1xyXG4gICAgYiA9IE1hdGgucm91bmQoMjU1IC0gKChwIC0gNzUpIC8gMjUpICogMjU1KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBgcmdiKCR7cn0sICR7Z30sICR7Yn0pYDtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gV2F2ZUNoYXJnaW5nKHsgc2FmZVBlcmNlbnRhZyB9OiBXYXZlQ2hhcmdpbmdQcm9wcykge1xyXG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgIGlmICghY2FudmFzKSByZXR1cm47XHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIGlmICghY3R4KSByZXR1cm47XHJcblxyXG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMud2lkdGg7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xyXG4gICAgY29uc3Qgd2F2ZUhlaWdodCA9IDEwO1xyXG4gICAgY29uc3Qgd2F2ZUxlbmd0aCA9IDYwO1xyXG4gICAgY29uc3Qgd2F2ZVNwZWVkID0gMC4wNTtcclxuXHJcbiAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgIGxldCBhbmltYXRpb25GcmFtZUlkOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3QgZHJhd1dhdmUgPSAoKSA9PiB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAvLyBDbGlwIGluIGEgY2lyY2xlXHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgY3R4LmFyYyh3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHdpZHRoIC8gMiwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICBjdHguY2xpcCgpO1xyXG5cclxuICAgICAgLy8gQmFja2dyb3VuZFxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gJyMwZjE3MmEnOyAvLyBkYXJrIHNsYXRlXHJcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgIGNvbnN0IHdhdmVZID0gaGVpZ2h0ICogKDEgLSBzYWZlUGVyY2VudGFnIC8gMTAwKTtcclxuXHJcbiAgICAgIC8vIER5bmFtaWMgd2F2ZSBjb2xvclxyXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDw9IHdpZHRoOyB4KyspIHtcclxuICAgICAgICBjb25zdCB5ID0gd2F2ZVkgKyBNYXRoLnNpbigoeCArIG9mZnNldCkgLyB3YXZlTGVuZ3RoKSAqIHdhdmVIZWlnaHQ7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcclxuICAgICAgfVxyXG4gICAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICBjdHgubGluZVRvKDAsIGhlaWdodCk7XHJcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBnZXRXYXZlQ29sb3Ioc2FmZVBlcmNlbnRhZyk7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IGN0eC5maWxsU3R5bGU7XHJcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gMjA7XHJcbiAgICAgIGN0eC5maWxsKCk7XHJcblxyXG4gICAgICBvZmZzZXQgKz0gd2F2ZVNwZWVkICogd2F2ZUxlbmd0aDtcclxuICAgICAgYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3V2F2ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGRyYXdXYXZlKCk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpO1xyXG4gIH0sIFtzYWZlUGVyY2VudGFnXSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8Y2FudmFzXHJcbiAgICAgIHJlZj17Y2FudmFzUmVmfVxyXG4gICAgICB3aWR0aD17MjAwfVxyXG4gICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgY2xhc3NOYW1lPVwicm91bmRlZC1mdWxsIGJnLXRyYW5zcGFyZW50XCJcclxuICAgIC8+XHJcbiAgKTtcclxufVxyXG4vLyAndXNlIGNsaWVudCc7XHJcblxyXG4vLyBpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcblxyXG4vLyBpbnRlcmZhY2UgV2F2ZUNoYXJnaW5nUHJvcHMge1xyXG4vLyAgIHNhZmVQZXJjZW50YWc6IG51bWJlcjtcclxuLy8gICBjaGFyZ2luZzogYm9vbGVhbjtcclxuLy8gfVxyXG5cclxuLy8gZnVuY3Rpb24gZ2V0V2F2ZUdyYWRpZW50KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgcGVyY2VudDogbnVtYmVyKTogQ2FudmFzR3JhZGllbnQge1xyXG4vLyAgIGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIGhlaWdodCwgMCwgMCk7XHJcblxyXG4vLyAgIGlmIChwZXJjZW50IDwgMjUpIHtcclxuLy8gICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAnI2ZmM2IzMCcpOyAvLyByZWRcclxuLy8gICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnI2ZmOTUwMCcpOyAvLyBvcmFuZ2VcclxuLy8gICB9IGVsc2UgaWYgKHBlcmNlbnQgPCA1MCkge1xyXG4vLyAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjZmZjYzAwJyk7IC8vIHllbGxvd1xyXG4vLyAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjMzRjNzU5Jyk7IC8vIGdyZWVuXHJcbi8vICAgfSBlbHNlIGlmIChwZXJjZW50IDwgNzUpIHtcclxuLy8gICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAnIzM0Yzc1OScpOyAvLyBncmVlblxyXG4vLyAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjMGE4NGZmJyk7IC8vIGJsdWVcclxuLy8gICB9IGVsc2Uge1xyXG4vLyAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjMGE4NGZmJyk7IC8vIGJsdWVcclxuLy8gICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzVlNWNlNicpOyAvLyB2aW9sZXRcclxuLy8gICB9XHJcblxyXG4vLyAgIHJldHVybiBncmFkaWVudDtcclxuLy8gfVxyXG5cclxuLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gV2F2ZUNoYXJnaW5nKHsgc2FmZVBlcmNlbnRhZywgY2hhcmdpbmcgfTogV2F2ZUNoYXJnaW5nUHJvcHMpIHtcclxuLy8gICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xyXG4vLyAgIGNvbnN0IHJpcHBsZVJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XHJcbi8vICAgY29uc3QgW3ByZXZQZXJjZW50LCBzZXRQcmV2UGVyY2VudF0gPSB1c2VTdGF0ZShzYWZlUGVyY2VudGFnKTtcclxuXHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIGlmIChzYWZlUGVyY2VudGFnICE9PSBwcmV2UGVyY2VudCAmJiBjaGFyZ2luZykge1xyXG4vLyAgICAgICAvLyBUcmlnZ2VyIHJpcHBsZSBlZmZlY3RcclxuLy8gICAgICAgaWYgKHJpcHBsZVJlZi5jdXJyZW50KSB7XHJcbi8vICAgICAgICAgcmlwcGxlUmVmLmN1cnJlbnQuY2xhc3NMaXN0LnJlbW92ZSgncmlwcGxlLWFuaW1hdGUnKTtcclxuLy8gICAgICAgICB2b2lkIHJpcHBsZVJlZi5jdXJyZW50Lm9mZnNldFdpZHRoOyAvLyBUcmlnZ2VyIHJlZmxvd1xyXG4vLyAgICAgICAgIHJpcHBsZVJlZi5jdXJyZW50LmNsYXNzTGlzdC5hZGQoJ3JpcHBsZS1hbmltYXRlJyk7XHJcbi8vICAgICAgIH1cclxuLy8gICAgICAgc2V0UHJldlBlcmNlbnQoc2FmZVBlcmNlbnRhZyk7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW3NhZmVQZXJjZW50YWcsIGNoYXJnaW5nLCBwcmV2UGVyY2VudF0pO1xyXG5cclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbi8vICAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG4vLyAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbi8vICAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuLy8gICAgIGNvbnN0IHdpZHRoID0gY2FudmFzLndpZHRoO1xyXG4vLyAgICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcclxuXHJcbi8vICAgICBjb25zdCB3YXZlSGVpZ2h0ID0gMTI7XHJcbi8vICAgICBjb25zdCB3YXZlTGVuZ3RoID0gODA7XHJcbi8vICAgICBjb25zdCB3YXZlU3BlZWQgPSAwLjA4O1xyXG4vLyAgICAgY29uc3Qgc2Vjb25kYXJ5V2F2ZU9mZnNldCA9IDE1O1xyXG5cclxuLy8gICAgIGxldCBvZmZzZXQgPSAwO1xyXG4vLyAgICAgbGV0IGFuaW1hdGlvbkZyYW1lSWQ6IG51bWJlcjtcclxuXHJcbi8vICAgICAvLyBTcGFya2xlIGVmZmVjdCBwYXJhbXNcclxuLy8gICAgIGNvbnN0IHNwYXJrbGVzOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyByYWRpdXM6IG51bWJlcjsgYWxwaGE6IG51bWJlcjsgZGVsdGE6IG51bWJlciB9W10gPSBbXTtcclxuLy8gICAgIGNvbnN0IG1heFNwYXJrbGVzID0gODtcclxuXHJcbi8vICAgICAvLyBJbml0aWFsaXplIHNwYXJrbGVzIHJhbmRvbWx5IGFyb3VuZCB0aGUgd2F2ZSBhcmVhXHJcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFNwYXJrbGVzOyBpKyspIHtcclxuLy8gICAgICAgc3BhcmtsZXMucHVzaCh7XHJcbi8vICAgICAgICAgeDogTWF0aC5yYW5kb20oKSAqIHdpZHRoLFxyXG4vLyAgICAgICAgIHk6IGhlaWdodCAqIDAuNSArIE1hdGgucmFuZG9tKCkgKiBoZWlnaHQgKiAwLjUsXHJcbi8vICAgICAgICAgcmFkaXVzOiAxICsgTWF0aC5yYW5kb20oKSAqIDIsXHJcbi8vICAgICAgICAgYWxwaGE6IE1hdGgucmFuZG9tKCksXHJcbi8vICAgICAgICAgZGVsdGE6IDAuMDIgKyBNYXRoLnJhbmRvbSgpICogMC4wMyxcclxuLy8gICAgICAgfSk7XHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgY29uc3QgZHJhd1NwYXJrbGVzID0gKCkgPT4ge1xyXG4vLyAgICAgICBzcGFya2xlcy5mb3JFYWNoKChzKSA9PiB7XHJcbi8vICAgICAgICAgcy5hbHBoYSArPSBzLmRlbHRhO1xyXG4vLyAgICAgICAgIGlmIChzLmFscGhhID4gMSB8fCBzLmFscGhhIDwgMCkgcy5kZWx0YSA9IC1zLmRlbHRhO1xyXG4vLyAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuLy8gICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAnd2hpdGUnO1xyXG4vLyAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gNjtcclxuLy8gICAgICAgICBjdHguZmlsbFN0eWxlID0gYHJnYmEoMjU1LDI1NSwyNTUsJHtzLmFscGhhLnRvRml4ZWQoMil9KWA7XHJcbi8vICAgICAgICAgY3R4LmFyYyhzLngsIHMueSwgcy5yYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuLy8gICAgICAgICBjdHguZmlsbCgpO1xyXG4vLyAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcclxuLy8gICAgICAgfSk7XHJcbi8vICAgICB9O1xyXG5cclxuLy8gICAgIGNvbnN0IGRyYXdXYXZlID0gKCkgPT4ge1xyXG4vLyAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuLy8gICAgICAgLy8gR2xhc3N5IGJhY2tncm91bmQgY2lyY2xlXHJcbi8vICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuLy8gICAgICAgY3R4LmFyYyh3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHdpZHRoIC8gMiwgMCwgTWF0aC5QSSAqIDIpO1xyXG4vLyAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbi8vICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgxNSwgMjMsIDQyLCAwLjcpJzsgLy8gU2xpZ2h0bHkgZGFya2VyIGdsYXNzXHJcbi8vICAgICAgIGN0eC5maWxsKCk7XHJcblxyXG4vLyAgICAgICBjdHguc2F2ZSgpO1xyXG4vLyAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbi8vICAgICAgIGN0eC5hcmMod2lkdGggLyAyLCBoZWlnaHQgLyAyLCB3aWR0aCAvIDIsIDAsIE1hdGguUEkgKiAyKTtcclxuLy8gICAgICAgY3R4LmNsaXAoKTtcclxuXHJcbi8vICAgICAgIGNvbnN0IHdhdmVZID0gaGVpZ2h0ICogKDEgLSBzYWZlUGVyY2VudGFnIC8gMTAwKTtcclxuXHJcbi8vICAgICAgIC8vIER5bmFtaWMgbmVvbiBncmFkaWVudFxyXG4vLyAgICAgICBjb25zdCBncmFkaWVudCA9IGdldFdhdmVHcmFkaWVudChjdHgsIHdpZHRoLCBoZWlnaHQsIHNhZmVQZXJjZW50YWcpO1xyXG4vLyAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XHJcbi8vICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IGdyYWRpZW50IGFzIGFueTtcclxuLy8gICAgICAgY3R4LnNoYWRvd0JsdXIgPSAyNTtcclxuXHJcbi8vICAgICAgIC8vIE1haW4gd2F2ZVxyXG4vLyAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbi8vICAgICAgIGZvciAobGV0IHggPSAwOyB4IDw9IHdpZHRoOyB4KyspIHtcclxuLy8gICAgICAgICBjb25zdCB5ID0gd2F2ZVkgKyBNYXRoLnNpbigoeCArIG9mZnNldCkgLyB3YXZlTGVuZ3RoKSAqIHdhdmVIZWlnaHQ7XHJcbi8vICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcclxuLy8gICAgICAgfVxyXG4vLyAgICAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xyXG4vLyAgICAgICBjdHgubGluZVRvKDAsIGhlaWdodCk7XHJcbi8vICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuLy8gICAgICAgY3R4LmZpbGwoKTtcclxuXHJcbi8vICAgICAgIC8vIFNlY29uZGFyeSB3YXZlIGxheWVyIChsaWdodGVyKVxyXG4vLyAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjM7XHJcbi8vICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuLy8gICAgICAgZm9yIChsZXQgeCA9IDA7IHggPD0gd2lkdGg7IHgrKykge1xyXG4vLyAgICAgICAgIGNvbnN0IHkgPSB3YXZlWSArIE1hdGguc2luKCh4ICsgb2Zmc2V0ICsgc2Vjb25kYXJ5V2F2ZU9mZnNldCkgLyB3YXZlTGVuZ3RoKSAqICh3YXZlSGVpZ2h0IC0gNik7XHJcbi8vICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcclxuLy8gICAgICAgfVxyXG4vLyAgICAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xyXG4vLyAgICAgICBjdHgubGluZVRvKDAsIGhlaWdodCk7XHJcbi8vICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuLy8gICAgICAgY3R4LmZpbGwoKTtcclxuLy8gICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcclxuXHJcbi8vICAgICAgIC8vIERyYXcgc3BhcmtsZXNcclxuLy8gICAgICAgZHJhd1NwYXJrbGVzKCk7XHJcblxyXG4vLyAgICAgICBjdHgucmVzdG9yZSgpO1xyXG5cclxuLy8gICAgICAgLy8gUHVsc2UgZWZmZWN0IGlmIDEwMCVcclxuLy8gICAgICAgaWYgKHNhZmVQZXJjZW50YWcgPj0gMTAwKSB7XHJcbi8vICAgICAgICAgY29uc3QgcHVsc2VSYWRpdXMgPSAxMDAgKyBNYXRoLnNpbihvZmZzZXQgKiAwLjMpICogMTA7XHJcbi8vICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4vLyAgICAgICAgIGN0eC5hcmMod2lkdGggLyAyLCBoZWlnaHQgLyAyLCBwdWxzZVJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG4vLyAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsIDI1NSwgMjU1LCAwLjIpJztcclxuLy8gICAgICAgICBjdHgubGluZVdpZHRoID0gNjtcclxuLy8gICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAnY3lhbic7XHJcbi8vICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAzMDtcclxuLy8gICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbi8vICAgICAgIH1cclxuXHJcbi8vICAgICAgIG9mZnNldCArPSB3YXZlU3BlZWQgKiB3YXZlTGVuZ3RoO1xyXG4vLyAgICAgICBhbmltYXRpb25GcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXdXYXZlKTtcclxuLy8gICAgIH07XHJcblxyXG4vLyAgICAgZHJhd1dhdmUoKTtcclxuXHJcbi8vICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZCk7XHJcbi8vICAgfSwgW3NhZmVQZXJjZW50YWddKTtcclxuXHJcbi8vICAgcmV0dXJuIChcclxuLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmUgdy1bMjIwcHhdIGgtWzIyMHB4XSByb3VuZGVkLWZ1bGwgYmctZ3JhZGllbnQtdG8tYnIgZnJvbS1bIzExMTgyN10gdmlhLVsjMWUyOTNiXSB0by1bIzBmMTcyYV0gc2hhZG93LTJ4bCBzaGFkb3ctY3lhbi05MDAvNDAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgc2VsZWN0LW5vbmVcIj5cclxuLy8gICAgICAgPGNhbnZhc1xyXG4vLyAgICAgICAgIHJlZj17Y2FudmFzUmVmfVxyXG4vLyAgICAgICAgIHdpZHRoPXsyMjB9XHJcbi8vICAgICAgICAgaGVpZ2h0PXsyMjB9XHJcbi8vICAgICAgICAgY2xhc3NOYW1lPVwicm91bmRlZC1mdWxsXCJcclxuLy8gICAgICAgLz5cclxuXHJcbi8vICAgICAgIHsvKiBSaXBwbGUgZWZmZWN0ICovfVxyXG4vLyAgICAgICA8ZGl2XHJcbi8vICAgICAgICAgcmVmPXtyaXBwbGVSZWZ9XHJcbi8vICAgICAgICAgY2xhc3NOYW1lPVwicG9pbnRlci1ldmVudHMtbm9uZSBhYnNvbHV0ZSByb3VuZGVkLWZ1bGwgYm9yZGVyLTIgYm9yZGVyLWN5YW4tNDAwIG9wYWNpdHktMFwiXHJcbi8vICAgICAgICAgc3R5bGU9e3tcclxuLy8gICAgICAgICAgIHdpZHRoOiAyMjAsXHJcbi8vICAgICAgICAgICBoZWlnaHQ6IDIyMCxcclxuLy8gICAgICAgICAgIHRvcDogMCxcclxuLy8gICAgICAgICAgIGxlZnQ6IDAsXHJcbi8vICAgICAgICAgICBib3hTaGFkb3c6ICcwIDAgMTVweCAzcHggY3lhbicsXHJcbi8vICAgICAgICAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjNzIGVhc2UtaW4tb3V0LCB0cmFuc2Zvcm0gMC41cyBlYXNlLW91dCcsXHJcbi8vICAgICAgICAgfX1cclxuLy8gICAgICAgLz5cclxuXHJcbi8vICAgICAgIHsvKiBDZW50ZXIgU09DIFRleHQgKi99XHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB0ZXh0LWN5YW4tNDAwIGZvbnQtZXh0cmFib2xkIHNlbGVjdC1ub25lIHBvaW50ZXItZXZlbnRzLW5vbmVcIj5cclxuLy8gICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LTZ4bCBkcm9wLXNoYWRvdy1sZ1wiPntzYWZlUGVyY2VudGFnfSU8L3NwYW4+XHJcbi8vICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidXBwZXJjYXNlIHRleHQteHMgdHJhY2tpbmctd2lkZXN0IGRyb3Atc2hhZG93LW1kIHRleHQtY3lhbi0zMDBcIj5cclxuLy8gICAgICAgICAgIENoYXJnZSBMZXZlbFxyXG4vLyAgICAgICAgIDwvc3Bhbj5cclxuLy8gICAgICAgPC9kaXY+XHJcblxyXG4vLyAgICAgICA8c3R5bGUganN4PntgXHJcbi8vICAgICAgICAgLnJpcHBsZS1hbmltYXRlIHtcclxuLy8gICAgICAgICAgIG9wYWNpdHk6IDAuNiAhaW1wb3J0YW50O1xyXG4vLyAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjMpO1xyXG4vLyAgICAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjZzIGVhc2Utb3V0LCB0cmFuc2Zvcm0gMC42cyBlYXNlLW91dDtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICAgIGB9PC9zdHlsZT5cclxuLy8gICAgIDwvZGl2PlxyXG4vLyAgICk7XHJcbi8vIH1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsImdldFdhdmVDb2xvciIsInBlcmNlbnQiLCJwIiwiTWF0aCIsIm1heCIsIm1pbiIsInIiLCJnIiwiYiIsInJvdW5kIiwiV2F2ZUNoYXJnaW5nIiwic2FmZVBlcmNlbnRhZyIsImNhbnZhc1JlZiIsImNhbnZhcyIsImN1cnJlbnQiLCJjdHgiLCJnZXRDb250ZXh0Iiwid2lkdGgiLCJoZWlnaHQiLCJ3YXZlSGVpZ2h0Iiwid2F2ZUxlbmd0aCIsIndhdmVTcGVlZCIsIm9mZnNldCIsImFuaW1hdGlvbkZyYW1lSWQiLCJkcmF3V2F2ZSIsImNsZWFyUmVjdCIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiY2xpcCIsImZpbGxTdHlsZSIsImZpbGxSZWN0Iiwid2F2ZVkiLCJ4IiwieSIsInNpbiIsImxpbmVUbyIsImNsb3NlUGF0aCIsInNoYWRvd0NvbG9yIiwic2hhZG93Qmx1ciIsImZpbGwiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlZiIsImNsYXNzTmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/WaveCharging.tsx\n"));

/***/ })

});