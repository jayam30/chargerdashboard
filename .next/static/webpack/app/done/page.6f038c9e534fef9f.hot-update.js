"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/done/page",{

/***/ "(app-pages-browser)/./hooks/useBMSData.ts":
/*!*****************************!*\
  !*** ./hooks/useBMSData.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useBMSData: () => (/* binding */ useBMSData)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _contexts_WebSocketContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contexts/WebSocketContext */ \"(app-pages-browser)/./contexts/WebSocketContext.tsx\");\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n// \"use client\";\n// import { useState, useEffect, useCallback } from 'react';\n// import { useWebSocket } from '../contexts/WebSocketContext';\n// import { toast } from 'sonner';\n// interface BMSData {\n//   voltage: number;\n//   current: number;\n//   SOC: number;\n//   isReceiverCoilDetected: boolean;\n// }\n// export function useBMSData() {\n//   const { sendMessage, lastMessage, connected, bmsData: contextBMSData } = useWebSocket();\n//   const [bmsData, setBMSData] = useState<BMSData>({\n//     voltage: 0,\n//     current: 0,\n//     SOC: 15,\n//     isReceiverCoilDetected: false,\n//   });\n//   // Update BMS data when receiving new messages\n//   useEffect(() => {\n//     if (lastMessage?.type === 'bms_data' && lastMessage.data) {\n//       setBMSData(lastMessage.data as BMSData);\n//     }\n//   }, [lastMessage]);\n//   // Sync with context BMS data\n//   useEffect(() => {\n//     setBMSData(contextBMSData);\n//   }, [contextBMSData]);\n//   // Update BMS data\n//   const updateBMSData = useCallback(async (newData: Partial<BMSData>): Promise<boolean> => {\n//     if (!connected) {\n//       toast.error('Not connected to charging system');\n//       return false;\n//     }\n//     try {\n//       const updatedData = {\n//         ...bmsData,\n//         ...newData,\n//       };\n//       sendMessage({\n//         type: 'updateBMSData',\n//         data: updatedData,\n//       });\n//       setBMSData(updatedData);\n//       return true;\n//     } catch (error) {\n//       console.error('Error updating BMS data:', error);\n//       toast.error('Failed to update BMS data');\n//       return false;\n//     }\n//   }, [connected, sendMessage, bmsData]);\n//   // Reset BMS data\n//   const resetBMSData = useCallback(() => {\n//     if (!connected) {\n//       toast.error('Not connected to charging system');\n//       return;\n//     }\n//     try {\n//       const resetData: BMSData = {\n//         voltage: 0,\n//         current: 0,\n//         SOC: 15,\n//         isReceiverCoilDetected: false,\n//       };\n//       sendMessage({\n//         type: 'resetBMSData',\n//         data: resetData,\n//       });\n//       setBMSData(resetData);\n//       toast.success('BMS data reset');\n//     } catch (error) {\n//       console.error('Error resetting BMS data:', error);\n//       toast.error('Failed to reset BMS data');\n//     }\n//   }, [connected, sendMessage]);\n//   // Monitor receiver coil detection\n//   useEffect(() => {\n//     if (bmsData.isReceiverCoilDetected) {\n//       toast.success('Receiver coil detected');\n//     } else if (bmsData.isReceiverCoilDetected === false) {\n//       toast.error('Receiver coil not detected');\n//     }\n//   }, [bmsData.isReceiverCoilDetected]);\n//   // Calculate charging power\n//   const calculateChargingPower = useCallback((): number => {\n//     return bmsData.voltage * bmsData.current;\n//   }, [bmsData.voltage, bmsData.current]);\n//   return {\n//     bmsData,\n//     updateBMSData,\n//     resetBMSData,\n//     isReceiverCoilDetected: bmsData.isReceiverCoilDetected,\n//     chargingPower: calculateChargingPower(),\n//   };\n// }\n////fod\n// \"use client\";\n// import { useState, useEffect, useCallback } from 'react';\n// import { useWebSocket } from '../contexts/WebSocketContext';\n// import { toast } from 'sonner';\n// interface BMSData {\n//   voltage: number;\n//   current: number;\n//   SOC: number;\n//   isReceiverCoilDetected: boolean;\n//   isFOD: boolean;\n//   isMiss: boolean;\n// }\n// export function useBMSData() {\n//   const { sendMessage, lastMessage, connected, bmsData: contextBMSData } = useWebSocket();\n//   const [bmsData, setBMSData] = useState<BMSData>({\n//     voltage: 0,\n//     current: 0,\n//     SOC: 15,\n//     isReceiverCoilDetected: false,\n//     isFOD: false,\n//     isMiss: false,\n//   });\n//   // Update BMS data when receiving new messages\n//   useEffect(() => {\n//     if (lastMessage?.type === 'bms_data' && lastMessage.data) {\n//       setBMSData(lastMessage.data as BMSData);\n//     }\n//   }, [lastMessage]);\n//   // Sync with context BMS data\n//   useEffect(() => {\n//     setBMSData(contextBMSData);\n//   }, [contextBMSData]);\n//   // Update BMS data\n//   const updateBMSData = useCallback(async (newData: Partial<BMSData>): Promise<boolean> => {\n//     if (!connected) {\n//       toast.error('Not connected to charging system');\n//       return false;\n//     }\n//     try {\n//       const updatedData = {\n//         ...bmsData,\n//         ...newData,\n//       };\n//       sendMessage({\n//         type: 'updateBMSData',\n//         data: updatedData,\n//       });\n//       setBMSData(updatedData);\n//       return true;\n//     } catch (error) {\n//       console.error('Error updating BMS data:', error);\n//       toast.error('Failed to update BMS data');\n//       return false;\n//     }\n//   }, [connected, sendMessage, bmsData]);\n//   // Reset BMS data\n//   const resetBMSData = useCallback(() => {\n//     if (!connected) {\n//       toast.error('Not connected to charging system');\n//       return;\n//     }\n//     try {\n//       const resetData: BMSData = {\n//         voltage: 0,\n//         current: 0,\n//         SOC: 15,\n//         isReceiverCoilDetected: false,\n//         isFOD: false,\n//         isMiss: false,\n//       };\n//       sendMessage({\n//         type: 'resetBMSData',\n//         data: resetData,\n//       });\n//       setBMSData(resetData);\n//       toast.success('BMS data reset');\n//     } catch (error) {\n//       console.error('Error resetting BMS data:', error);\n//       toast.error('Failed to reset BMS data');\n//     }\n//   }, [connected, sendMessage]);\n//   // Monitor receiver coil detection\n//   useEffect(() => {\n//     if (bmsData.isReceiverCoilDetected) {\n//       toast.success('Receiver coil detected');\n//     } else if (bmsData.isReceiverCoilDetected === false) {\n//       toast.error('Receiver coil not detected');\n//     }\n//   }, [bmsData.isReceiverCoilDetected]);\n//   // Calculate charging power\n//   const calculateChargingPower = useCallback((): number => {\n//     return bmsData.voltage * bmsData.current;\n//   }, [bmsData.voltage, bmsData.current]);\n//   return {\n//     bmsData,\n//     updateBMSData,\n//     resetBMSData,\n//     isReceiverCoilDetected: bmsData.isReceiverCoilDetected,\n//     isFOD: bmsData.isFOD,\n//     isMiss: bmsData.isMiss,\n//     chargingPower: calculateChargingPower(),\n//   };\n// }\n//miss alignment\n/* __next_internal_client_entry_do_not_use__ useBMSData auto */ \n\n\nfunction useBMSData() {\n    const { sendMessage, lastMessage, connected, bmsData: contextBMSData } = (0,_contexts_WebSocketContext__WEBPACK_IMPORTED_MODULE_1__.useWebSocket)();\n    const [bmsData, setBMSData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        voltage: 0,\n        current: 0,\n        SOC: 15,\n        isReceiverCoilDetected: false,\n        // targetSOC: 0,\n        isFOD: false,\n        isMiss: false\n    });\n    // Update BMS data when receiving new messages\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useBMSData.useEffect\": ()=>{\n            if ((lastMessage === null || lastMessage === void 0 ? void 0 : lastMessage.type) === 'bms_data' && lastMessage.data) {\n                setBMSData(lastMessage.data);\n            }\n        }\n    }[\"useBMSData.useEffect\"], [\n        lastMessage\n    ]);\n    // Sync with context BMS data\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useBMSData.useEffect\": ()=>{\n            setBMSData(contextBMSData);\n        }\n    }[\"useBMSData.useEffect\"], [\n        contextBMSData\n    ]);\n    // Update BMS data\n    const updateBMSData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBMSData.useCallback[updateBMSData]\": async (newData)=>{\n            if (!connected) {\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.error('Not connected to charging system');\n                return false;\n            }\n            try {\n                const updatedData = {\n                    ...bmsData,\n                    ...newData\n                };\n                sendMessage({\n                    type: 'updateBMSData',\n                    data: updatedData\n                });\n                setBMSData(updatedData);\n                return true;\n            } catch (error) {\n                console.error('Error updating BMS data:', error);\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.error('Failed to update BMS data');\n                return false;\n            }\n        }\n    }[\"useBMSData.useCallback[updateBMSData]\"], [\n        connected,\n        sendMessage,\n        bmsData\n    ]);\n    // Reset BMS data\n    const resetBMSData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBMSData.useCallback[resetBMSData]\": ()=>{\n            if (!connected) {\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.error('Not connected to charging system');\n                return;\n            }\n            try {\n                const resetData = {\n                    voltage: 0,\n                    current: 0,\n                    SOC: 15,\n                    isReceiverCoilDetected: false,\n                    isFOD: false,\n                    // targetSOC: 0,\n                    isMiss: false\n                };\n                sendMessage({\n                    type: 'resetBMSData',\n                    data: resetData\n                });\n                setBMSData(resetData);\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.success('BMS data reset');\n            } catch (error) {\n                console.error('Error resetting BMS data:', error);\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.error('Failed to reset BMS data');\n            }\n        }\n    }[\"useBMSData.useCallback[resetBMSData]\"], [\n        connected,\n        sendMessage\n    ]);\n    // Monitor receiver coil detection\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useBMSData.useEffect\": ()=>{\n            if (bmsData.isReceiverCoilDetected) {\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.success('Receiver coil detected');\n            } else if (bmsData.isReceiverCoilDetected === false) {\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.error('Receiver coil not detected');\n            }\n        }\n    }[\"useBMSData.useEffect\"], [\n        bmsData.isReceiverCoilDetected\n    ]);\n    // Calculate charging power\n    // const calculateChargingPower = useCallback((): number => {\n    //   return bmsData.voltage * bmsData.current;\n    // }, [bmsData.voltage, bmsData.current]);\n    const calculateChargingPower = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBMSData.useCallback[calculateChargingPower]\": ()=>{\n            var _bmsData_voltage;\n            const voltage = (_bmsData_voltage = bmsData === null || bmsData === void 0 ? void 0 : bmsData.voltage) !== null && _bmsData_voltage !== void 0 ? _bmsData_voltage : 0;\n            var _bmsData_current;\n            const current = (_bmsData_current = bmsData === null || bmsData === void 0 ? void 0 : bmsData.current) !== null && _bmsData_current !== void 0 ? _bmsData_current : 0;\n            const powerW = voltage * current; // Power in Watts\n            const energyIncrement = powerW / 1000 / 3600; // kWh added every second\n            return Number(energyIncrement.toFixed(6)); // rounded to 6 decimal places\n        }\n    }[\"useBMSData.useCallback[calculateChargingPower]\"], [\n        bmsData === null || bmsData === void 0 ? void 0 : bmsData.voltage,\n        bmsData === null || bmsData === void 0 ? void 0 : bmsData.current\n    ]);\n    return {\n        bmsData,\n        updateBMSData,\n        resetBMSData,\n        isReceiverCoilDetected: bmsData.isReceiverCoilDetected,\n        isFOD: bmsData.isFOD,\n        isMiss: bmsData.isMiss,\n        chargingPower: calculateChargingPower()\n    };\n} // soc\n // \"use client\";\n // import { useState, useEffect, useCallback } from 'react';\n // import { useWebSocket } from '../contexts/WebSocketContext';\n // import { toast } from 'sonner';\n // interface BMSData {\n //   voltage: number;\n //   current: number;\n //   SOC: number;\n //   isReceiverCoilDetected: boolean;\n //   isFOD: boolean;\n //   isMiss: boolean;\n // }\n // export function useBMSData() {\n //   const { sendMessage, lastMessage, connected, bmsData: contextBMSData } = useWebSocket();\n //   const [bmsData, setBMSData] = useState<BMSData>({\n //     voltage: 0,\n //     current: 0,\n //     SOC: 15,\n //     isReceiverCoilDetected: false,\n //     isFOD: false,\n //     isMiss: false,\n //   });\n //   // Update BMS data when receiving new messages\n //   useEffect(() => {\n //     if (lastMessage?.type === 'bms_data' && lastMessage.data) {\n //       setBMSData(lastMessage.data as BMSData);\n //     }\n //   }, [lastMessage]);\n //   // Sync with context BMS data\n //   useEffect(() => {\n //     setBMSData(contextBMSData);\n //   }, [contextBMSData]);\n //   // Update BMS data\n //   const updateBMSData = useCallback(async (newData: Partial<BMSData>): Promise<boolean> => {\n //     if (!connected) {\n //       toast.error('Not connected to charging system');\n //       return false;\n //     }\n //     try {\n //       const updatedData = {\n //         ...bmsData,\n //         ...newData,\n //       };\n //       sendMessage({\n //         type: 'updateBMSData',\n //         data: updatedData,\n //       });\n //       setBMSData(updatedData);\n //       return true;\n //     } catch (error) {\n //       console.error('Error updating BMS data:', error);\n //       toast.error('Failed to update BMS data');\n //       return false;\n //     }\n //   }, [connected, sendMessage, bmsData]);\n //   // Reset BMS data\n //   const resetBMSData = useCallback(() => {\n //     if (!connected) {\n //       toast.error('Not connected to charging system');\n //       return;\n //     }\n //     try {\n //       const resetData: BMSData = {\n //         voltage: 0,\n //         current: 0,\n //         SOC: 15,\n //         isReceiverCoilDetected: false,\n //         isFOD: false,\n //         isMiss: false,\n //       };\n //       sendMessage({\n //         type: 'resetBMSData',\n //         data: resetData,\n //       });\n //       setBMSData(resetData);\n //       toast.success('BMS data reset');\n //     } catch (error) {\n //       console.error('Error resetting BMS data:', error);\n //       toast.error('Failed to reset BMS data');\n //     }\n //   }, [connected, sendMessage]);\n //   // Monitor receiver coil detection\n //   useEffect(() => {\n //     if (bmsData.isReceiverCoilDetected) {\n //       toast.success('Receiver coil detected');\n //     } else if (bmsData.isReceiverCoilDetected === false) {\n //       toast.error('Receiver coil not detected');\n //     }\n //   }, [bmsData.isReceiverCoilDetected]);\n //   // Calculate charging power\n //   const calculateChargingPower = useCallback((): number => {\n //     return bmsData.voltage * bmsData.current;\n //   }, [bmsData.voltage, bmsData.current]);\n //   return {\n //     bmsData,\n //     updateBMSData,\n //     resetBMSData,\n //     isReceiverCoilDetected: bmsData.isReceiverCoilDetected,\n //     isFOD: bmsData.isFOD,\n //     isMiss: bmsData.isMiss,\n //     chargingPower: calculateChargingPower(),\n //   };\n // }\n //soc\n // \"use client\";\n // import { useState, useEffect, useCallback } from 'react';\n // import { useWebSocket } from '../contexts/WebSocketContext';\n // import { toast } from 'sonner';\n // interface BMSData {\n //   voltage: number;\n //   current: number;\n //   SOC: number;\n //   targetSOC: number; // ✅ Added targetSOC\n //   isReceiverCoilDetected: boolean;\n //   isFOD: boolean;\n //   isMiss: boolean;\n // }\n // export function useBMSData() {\n //   const { sendMessage, lastMessage, connected, bmsData: contextBMSData } = useWebSocket();\n //   const [bmsData, setBMSData] = useState<BMSData>({\n //     voltage: 0,\n //     current: 0,\n //     SOC: 15,\n //     targetSOC: 100, // ✅ Default value\n //     isReceiverCoilDetected: false,\n //     isFOD: false,\n //     isMiss: false,\n //   });\n //   // Update BMS data when receiving new messages\n //   useEffect(() => {\n //     if (lastMessage?.type === 'bms_data' && lastMessage.data) {\n //       setBMSData(lastMessage.data as BMSData);\n //     }\n //   }, [lastMessage]);\n //   // Sync with context BMS data\n //   useEffect(() => {\n //     setBMSData(contextBMSData);\n //   }, [contextBMSData]);\n //   // Update BMS data (including targetSOC)\n //   const updateBMSData = useCallback(async (newData: Partial<BMSData>): Promise<boolean> => {\n //     if (!connected) {\n //       toast.error('Not connected to charging system');\n //       return false;\n //     }\n //     try {\n //       const updatedData = {\n //         ...bmsData,\n //         ...newData,\n //       };\n //       // Use a consistent message type for bms_data\n //       sendMessage({\n //         type: 'bms_data',\n //         data: updatedData,\n //       });\n //       setBMSData(updatedData);\n //       return true;\n //     } catch (error) {\n //       console.error('Error updating BMS data:', error);\n //       toast.error('Failed to update BMS data');\n //       return false;\n //     }\n //   }, [connected, sendMessage, bmsData]);\n //   // Reset BMS data\n //   const resetBMSData = useCallback(() => {\n //     if (!connected) {\n //       toast.error('Not connected to charging system');\n //       return;\n //     }\n //     try {\n //       const resetData: BMSData = {\n //         voltage: 0,\n //         current: 0,\n //         SOC: 15,\n //         targetSOC: 100,\n //         isReceiverCoilDetected: false,\n //         isFOD: false,\n //         isMiss: false,\n //       };\n //       sendMessage({\n //         type: 'bms_data',\n //         data: resetData,\n //       });\n //       setBMSData(resetData);\n //       toast.success('BMS data reset');\n //     } catch (error) {\n //       console.error('Error resetting BMS data:', error);\n //       toast.error('Failed to reset BMS data');\n //     }\n //   }, [connected, sendMessage]);\n //   // Monitor receiver coil detection\n //   useEffect(() => {\n //     if (bmsData.isReceiverCoilDetected) {\n //       toast.success('Receiver coil detected');\n //     } else if (bmsData.isReceiverCoilDetected === false) {\n //       toast.error('Receiver coil not detected');\n //     }\n //   }, [bmsData.isReceiverCoilDetected]);\n //   // Calculate charging power\n //   const calculateChargingPower = useCallback((): number => {\n //     return bmsData.voltage * bmsData.current;\n //   }, [bmsData.voltage, bmsData.current]);\n //   return {\n //     bmsData,\n //     updateBMSData,\n //     resetBMSData,\n //     isReceiverCoilDetected: bmsData.isReceiverCoilDetected,\n //     isFOD: bmsData.isFOD,\n //     isMiss: bmsData.isMiss,\n //     chargingPower: calculateChargingPower(),\n //   };\n // }\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWU7Q0FDZixxQkFBcUI7Q0FDckIsb0JBQW9CO0NBQ3BCLDhEQUE4RDtDQUM5RCw0QkFBNEI7Q0FDNUIsOEJBQThCO0NBQzlCLCtDQUErQztDQUMvQyxPQUFPO0NBQ1AsSUFBSSIsInNvdXJjZXMiOlsiRDpcXGNvZGluZ1xcZGFzaCBkeW5hbWljc1xcZGFzaGJvYXJkc1xcTG9jYWxiYWNrZW5kXFxjaGFyZ2luZy1zeXN0ZW1cXGhvb2tzXFx1c2VCTVNEYXRhLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFwidXNlIGNsaWVudFwiO1xyXG5cclxuLy8gaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbi8vIGltcG9ydCB7IHVzZVdlYlNvY2tldCB9IGZyb20gJy4uL2NvbnRleHRzL1dlYlNvY2tldENvbnRleHQnO1xyXG4vLyBpbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3Nvbm5lcic7XHJcblxyXG4vLyBpbnRlcmZhY2UgQk1TRGF0YSB7XHJcbi8vICAgdm9sdGFnZTogbnVtYmVyO1xyXG4vLyAgIGN1cnJlbnQ6IG51bWJlcjtcclxuLy8gICBTT0M6IG51bWJlcjtcclxuLy8gICBpc1JlY2VpdmVyQ29pbERldGVjdGVkOiBib29sZWFuO1xyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gdXNlQk1TRGF0YSgpIHtcclxuLy8gICBjb25zdCB7IHNlbmRNZXNzYWdlLCBsYXN0TWVzc2FnZSwgY29ubmVjdGVkLCBibXNEYXRhOiBjb250ZXh0Qk1TRGF0YSB9ID0gdXNlV2ViU29ja2V0KCk7XHJcbi8vICAgY29uc3QgW2Jtc0RhdGEsIHNldEJNU0RhdGFdID0gdXNlU3RhdGU8Qk1TRGF0YT4oe1xyXG4vLyAgICAgdm9sdGFnZTogMCxcclxuLy8gICAgIGN1cnJlbnQ6IDAsXHJcbi8vICAgICBTT0M6IDE1LFxyXG4vLyAgICAgaXNSZWNlaXZlckNvaWxEZXRlY3RlZDogZmFsc2UsXHJcbi8vICAgfSk7XHJcblxyXG4vLyAgIC8vIFVwZGF0ZSBCTVMgZGF0YSB3aGVuIHJlY2VpdmluZyBuZXcgbWVzc2FnZXNcclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgaWYgKGxhc3RNZXNzYWdlPy50eXBlID09PSAnYm1zX2RhdGEnICYmIGxhc3RNZXNzYWdlLmRhdGEpIHtcclxuLy8gICAgICAgc2V0Qk1TRGF0YShsYXN0TWVzc2FnZS5kYXRhIGFzIEJNU0RhdGEpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtsYXN0TWVzc2FnZV0pO1xyXG5cclxuLy8gICAvLyBTeW5jIHdpdGggY29udGV4dCBCTVMgZGF0YVxyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBzZXRCTVNEYXRhKGNvbnRleHRCTVNEYXRhKTtcclxuLy8gICB9LCBbY29udGV4dEJNU0RhdGFdKTtcclxuXHJcbi8vICAgLy8gVXBkYXRlIEJNUyBkYXRhXHJcbi8vICAgY29uc3QgdXBkYXRlQk1TRGF0YSA9IHVzZUNhbGxiYWNrKGFzeW5jIChuZXdEYXRhOiBQYXJ0aWFsPEJNU0RhdGE+KTogUHJvbWlzZTxib29sZWFuPiA9PiB7XHJcbi8vICAgICBpZiAoIWNvbm5lY3RlZCkge1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignTm90IGNvbm5lY3RlZCB0byBjaGFyZ2luZyBzeXN0ZW0nKTtcclxuLy8gICAgICAgcmV0dXJuIGZhbHNlO1xyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0ge1xyXG4vLyAgICAgICAgIC4uLmJtc0RhdGEsXHJcbi8vICAgICAgICAgLi4ubmV3RGF0YSxcclxuLy8gICAgICAgfTtcclxuXHJcbi8vICAgICAgIHNlbmRNZXNzYWdlKHtcclxuLy8gICAgICAgICB0eXBlOiAndXBkYXRlQk1TRGF0YScsXHJcbi8vICAgICAgICAgZGF0YTogdXBkYXRlZERhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgc2V0Qk1TRGF0YSh1cGRhdGVkRGF0YSk7XHJcbi8vICAgICAgIHJldHVybiB0cnVlO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgQk1TIGRhdGE6JywgZXJyb3IpO1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBCTVMgZGF0YScpO1xyXG4vLyAgICAgICByZXR1cm4gZmFsc2U7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW2Nvbm5lY3RlZCwgc2VuZE1lc3NhZ2UsIGJtc0RhdGFdKTtcclxuXHJcbi8vICAgLy8gUmVzZXQgQk1TIGRhdGFcclxuLy8gICBjb25zdCByZXNldEJNU0RhdGEgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbi8vICAgICBpZiAoIWNvbm5lY3RlZCkge1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignTm90IGNvbm5lY3RlZCB0byBjaGFyZ2luZyBzeXN0ZW0nKTtcclxuLy8gICAgICAgcmV0dXJuO1xyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc2V0RGF0YTogQk1TRGF0YSA9IHtcclxuLy8gICAgICAgICB2b2x0YWdlOiAwLFxyXG4vLyAgICAgICAgIGN1cnJlbnQ6IDAsXHJcbi8vICAgICAgICAgU09DOiAxNSxcclxuLy8gICAgICAgICBpc1JlY2VpdmVyQ29pbERldGVjdGVkOiBmYWxzZSxcclxuLy8gICAgICAgfTtcclxuXHJcbi8vICAgICAgIHNlbmRNZXNzYWdlKHtcclxuLy8gICAgICAgICB0eXBlOiAncmVzZXRCTVNEYXRhJyxcclxuLy8gICAgICAgICBkYXRhOiByZXNldERhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgc2V0Qk1TRGF0YShyZXNldERhdGEpO1xyXG4vLyAgICAgICB0b2FzdC5zdWNjZXNzKCdCTVMgZGF0YSByZXNldCcpO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzZXR0aW5nIEJNUyBkYXRhOicsIGVycm9yKTtcclxuLy8gICAgICAgdG9hc3QuZXJyb3IoJ0ZhaWxlZCB0byByZXNldCBCTVMgZGF0YScpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtjb25uZWN0ZWQsIHNlbmRNZXNzYWdlXSk7XHJcblxyXG4vLyAgIC8vIE1vbml0b3IgcmVjZWl2ZXIgY29pbCBkZXRlY3Rpb25cclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgaWYgKGJtc0RhdGEuaXNSZWNlaXZlckNvaWxEZXRlY3RlZCkge1xyXG4vLyAgICAgICB0b2FzdC5zdWNjZXNzKCdSZWNlaXZlciBjb2lsIGRldGVjdGVkJyk7XHJcbi8vICAgICB9IGVsc2UgaWYgKGJtc0RhdGEuaXNSZWNlaXZlckNvaWxEZXRlY3RlZCA9PT0gZmFsc2UpIHtcclxuLy8gICAgICAgdG9hc3QuZXJyb3IoJ1JlY2VpdmVyIGNvaWwgbm90IGRldGVjdGVkJyk7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW2Jtc0RhdGEuaXNSZWNlaXZlckNvaWxEZXRlY3RlZF0pO1xyXG5cclxuLy8gICAvLyBDYWxjdWxhdGUgY2hhcmdpbmcgcG93ZXJcclxuLy8gICBjb25zdCBjYWxjdWxhdGVDaGFyZ2luZ1Bvd2VyID0gdXNlQ2FsbGJhY2soKCk6IG51bWJlciA9PiB7XHJcbi8vICAgICByZXR1cm4gYm1zRGF0YS52b2x0YWdlICogYm1zRGF0YS5jdXJyZW50O1xyXG4vLyAgIH0sIFtibXNEYXRhLnZvbHRhZ2UsIGJtc0RhdGEuY3VycmVudF0pO1xyXG5cclxuLy8gICByZXR1cm4ge1xyXG4vLyAgICAgYm1zRGF0YSxcclxuLy8gICAgIHVwZGF0ZUJNU0RhdGEsXHJcbi8vICAgICByZXNldEJNU0RhdGEsXHJcbi8vICAgICBpc1JlY2VpdmVyQ29pbERldGVjdGVkOiBibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQsXHJcbi8vICAgICBjaGFyZ2luZ1Bvd2VyOiBjYWxjdWxhdGVDaGFyZ2luZ1Bvd2VyKCksXHJcbi8vICAgfTtcclxuLy8gfVxyXG5cclxuXHJcbi8vLy9mb2RcclxuXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG5cclxuLy8gaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbi8vIGltcG9ydCB7IHVzZVdlYlNvY2tldCB9IGZyb20gJy4uL2NvbnRleHRzL1dlYlNvY2tldENvbnRleHQnO1xyXG4vLyBpbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3Nvbm5lcic7XHJcblxyXG4vLyBpbnRlcmZhY2UgQk1TRGF0YSB7XHJcbi8vICAgdm9sdGFnZTogbnVtYmVyO1xyXG4vLyAgIGN1cnJlbnQ6IG51bWJlcjtcclxuLy8gICBTT0M6IG51bWJlcjtcclxuLy8gICBpc1JlY2VpdmVyQ29pbERldGVjdGVkOiBib29sZWFuO1xyXG4vLyAgIGlzRk9EOiBib29sZWFuO1xyXG4vLyAgIGlzTWlzczogYm9vbGVhbjtcclxuLy8gfVxyXG5cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIHVzZUJNU0RhdGEoKSB7XHJcbi8vICAgY29uc3QgeyBzZW5kTWVzc2FnZSwgbGFzdE1lc3NhZ2UsIGNvbm5lY3RlZCwgYm1zRGF0YTogY29udGV4dEJNU0RhdGEgfSA9IHVzZVdlYlNvY2tldCgpO1xyXG4vLyAgIGNvbnN0IFtibXNEYXRhLCBzZXRCTVNEYXRhXSA9IHVzZVN0YXRlPEJNU0RhdGE+KHtcclxuLy8gICAgIHZvbHRhZ2U6IDAsXHJcbi8vICAgICBjdXJyZW50OiAwLFxyXG4vLyAgICAgU09DOiAxNSxcclxuLy8gICAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGZhbHNlLFxyXG4vLyAgICAgaXNGT0Q6IGZhbHNlLFxyXG4vLyAgICAgaXNNaXNzOiBmYWxzZSxcclxuLy8gICB9KTtcclxuXHJcbi8vICAgLy8gVXBkYXRlIEJNUyBkYXRhIHdoZW4gcmVjZWl2aW5nIG5ldyBtZXNzYWdlc1xyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBpZiAobGFzdE1lc3NhZ2U/LnR5cGUgPT09ICdibXNfZGF0YScgJiYgbGFzdE1lc3NhZ2UuZGF0YSkge1xyXG4vLyAgICAgICBzZXRCTVNEYXRhKGxhc3RNZXNzYWdlLmRhdGEgYXMgQk1TRGF0YSk7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW2xhc3RNZXNzYWdlXSk7XHJcblxyXG4vLyAgIC8vIFN5bmMgd2l0aCBjb250ZXh0IEJNUyBkYXRhXHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIHNldEJNU0RhdGEoY29udGV4dEJNU0RhdGEpO1xyXG4vLyAgIH0sIFtjb250ZXh0Qk1TRGF0YV0pO1xyXG5cclxuLy8gICAvLyBVcGRhdGUgQk1TIGRhdGFcclxuLy8gICBjb25zdCB1cGRhdGVCTVNEYXRhID0gdXNlQ2FsbGJhY2soYXN5bmMgKG5ld0RhdGE6IFBhcnRpYWw8Qk1TRGF0YT4pOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcclxuLy8gICAgIGlmICghY29ubmVjdGVkKSB7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdOb3QgY29ubmVjdGVkIHRvIGNoYXJnaW5nIHN5c3RlbScpO1xyXG4vLyAgICAgICByZXR1cm4gZmFsc2U7XHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSB7XHJcbi8vICAgICAgICAgLi4uYm1zRGF0YSxcclxuLy8gICAgICAgICAuLi5uZXdEYXRhLFxyXG4vLyAgICAgICB9O1xyXG5cclxuLy8gICAgICAgc2VuZE1lc3NhZ2Uoe1xyXG4vLyAgICAgICAgIHR5cGU6ICd1cGRhdGVCTVNEYXRhJyxcclxuLy8gICAgICAgICBkYXRhOiB1cGRhdGVkRGF0YSxcclxuLy8gICAgICAgfSk7XHJcblxyXG4vLyAgICAgICBzZXRCTVNEYXRhKHVwZGF0ZWREYXRhKTtcclxuLy8gICAgICAgcmV0dXJuIHRydWU7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBCTVMgZGF0YTonLCBlcnJvcik7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIEJNUyBkYXRhJyk7XHJcbi8vICAgICAgIHJldHVybiBmYWxzZTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbY29ubmVjdGVkLCBzZW5kTWVzc2FnZSwgYm1zRGF0YV0pO1xyXG5cclxuLy8gICAvLyBSZXNldCBCTVMgZGF0YVxyXG4vLyAgIGNvbnN0IHJlc2V0Qk1TRGF0YSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuLy8gICAgIGlmICghY29ubmVjdGVkKSB7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdOb3QgY29ubmVjdGVkIHRvIGNoYXJnaW5nIHN5c3RlbScpO1xyXG4vLyAgICAgICByZXR1cm47XHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzZXREYXRhOiBCTVNEYXRhID0ge1xyXG4vLyAgICAgICAgIHZvbHRhZ2U6IDAsXHJcbi8vICAgICAgICAgY3VycmVudDogMCxcclxuLy8gICAgICAgICBTT0M6IDE1LFxyXG4vLyAgICAgICAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGZhbHNlLFxyXG4vLyAgICAgICAgIGlzRk9EOiBmYWxzZSxcclxuLy8gICAgICAgICBpc01pc3M6IGZhbHNlLFxyXG4vLyAgICAgICB9O1xyXG5cclxuLy8gICAgICAgc2VuZE1lc3NhZ2Uoe1xyXG4vLyAgICAgICAgIHR5cGU6ICdyZXNldEJNU0RhdGEnLFxyXG4vLyAgICAgICAgIGRhdGE6IHJlc2V0RGF0YSxcclxuLy8gICAgICAgfSk7XHJcblxyXG4vLyAgICAgICBzZXRCTVNEYXRhKHJlc2V0RGF0YSk7XHJcbi8vICAgICAgIHRvYXN0LnN1Y2Nlc3MoJ0JNUyBkYXRhIHJlc2V0Jyk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNldHRpbmcgQk1TIGRhdGE6JywgZXJyb3IpO1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignRmFpbGVkIHRvIHJlc2V0IEJNUyBkYXRhJyk7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW2Nvbm5lY3RlZCwgc2VuZE1lc3NhZ2VdKTtcclxuXHJcbi8vICAgLy8gTW9uaXRvciByZWNlaXZlciBjb2lsIGRldGVjdGlvblxyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBpZiAoYm1zRGF0YS5pc1JlY2VpdmVyQ29pbERldGVjdGVkKSB7XHJcbi8vICAgICAgIHRvYXN0LnN1Y2Nlc3MoJ1JlY2VpdmVyIGNvaWwgZGV0ZWN0ZWQnKTtcclxuLy8gICAgIH0gZWxzZSBpZiAoYm1zRGF0YS5pc1JlY2VpdmVyQ29pbERldGVjdGVkID09PSBmYWxzZSkge1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignUmVjZWl2ZXIgY29pbCBub3QgZGV0ZWN0ZWQnKTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbYm1zRGF0YS5pc1JlY2VpdmVyQ29pbERldGVjdGVkXSk7XHJcblxyXG4vLyAgIC8vIENhbGN1bGF0ZSBjaGFyZ2luZyBwb3dlclxyXG4vLyAgIGNvbnN0IGNhbGN1bGF0ZUNoYXJnaW5nUG93ZXIgPSB1c2VDYWxsYmFjaygoKTogbnVtYmVyID0+IHtcclxuLy8gICAgIHJldHVybiBibXNEYXRhLnZvbHRhZ2UgKiBibXNEYXRhLmN1cnJlbnQ7XHJcbi8vICAgfSwgW2Jtc0RhdGEudm9sdGFnZSwgYm1zRGF0YS5jdXJyZW50XSk7XHJcblxyXG4vLyAgIHJldHVybiB7XHJcbi8vICAgICBibXNEYXRhLFxyXG4vLyAgICAgdXBkYXRlQk1TRGF0YSxcclxuLy8gICAgIHJlc2V0Qk1TRGF0YSxcclxuLy8gICAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGJtc0RhdGEuaXNSZWNlaXZlckNvaWxEZXRlY3RlZCxcclxuLy8gICAgIGlzRk9EOiBibXNEYXRhLmlzRk9ELFxyXG4vLyAgICAgaXNNaXNzOiBibXNEYXRhLmlzTWlzcyxcclxuLy8gICAgIGNoYXJnaW5nUG93ZXI6IGNhbGN1bGF0ZUNoYXJnaW5nUG93ZXIoKSxcclxuLy8gICB9O1xyXG4vLyB9XHJcblxyXG4vL21pc3MgYWxpZ25tZW50XHJcblwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IHVzZVdlYlNvY2tldCB9IGZyb20gJy4uL2NvbnRleHRzL1dlYlNvY2tldENvbnRleHQnO1xyXG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3Nvbm5lcic7XHJcblxyXG5pbnRlcmZhY2UgQk1TRGF0YSB7XHJcbiAgdm9sdGFnZTogbnVtYmVyO1xyXG4gIGN1cnJlbnQ6IG51bWJlcjtcclxuICBTT0M6IG51bWJlcjtcclxuICBpc1JlY2VpdmVyQ29pbERldGVjdGVkPzogYm9vbGVhbjtcclxuICAvLyB0YXJnZXRTT0M/OiBudW1iZXI7XHJcbiAgaXNGT0Q/OiBib29sZWFuO1xyXG4gIGlzTWlzcz86IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCTVNEYXRhKCkge1xyXG4gIGNvbnN0IHsgc2VuZE1lc3NhZ2UsIGxhc3RNZXNzYWdlLCBjb25uZWN0ZWQsIGJtc0RhdGE6IGNvbnRleHRCTVNEYXRhIH0gPSB1c2VXZWJTb2NrZXQoKTtcclxuICBjb25zdCBbYm1zRGF0YSwgc2V0Qk1TRGF0YV0gPSB1c2VTdGF0ZTxCTVNEYXRhPih7XHJcbiAgICB2b2x0YWdlOiAwLFxyXG4gICAgY3VycmVudDogMCxcclxuICAgIFNPQzogMTUsXHJcbiAgICBpc1JlY2VpdmVyQ29pbERldGVjdGVkOiBmYWxzZSxcclxuICAgIC8vIHRhcmdldFNPQzogMCxcclxuICAgIGlzRk9EOiBmYWxzZSxcclxuICAgIGlzTWlzczogZmFsc2UsXHJcbiAgfSk7XHJcblxyXG4gIC8vIFVwZGF0ZSBCTVMgZGF0YSB3aGVuIHJlY2VpdmluZyBuZXcgbWVzc2FnZXNcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGxhc3RNZXNzYWdlPy50eXBlID09PSAnYm1zX2RhdGEnICYmIGxhc3RNZXNzYWdlLmRhdGEpIHtcclxuICAgICAgc2V0Qk1TRGF0YShsYXN0TWVzc2FnZS5kYXRhIGFzIEJNU0RhdGEpO1xyXG4gICAgfVxyXG4gIH0sIFtsYXN0TWVzc2FnZV0pO1xyXG5cclxuICAvLyBTeW5jIHdpdGggY29udGV4dCBCTVMgZGF0YVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBzZXRCTVNEYXRhKGNvbnRleHRCTVNEYXRhKTtcclxuICB9LCBbY29udGV4dEJNU0RhdGFdKTtcclxuXHJcbiAgLy8gVXBkYXRlIEJNUyBkYXRhXHJcbiAgY29uc3QgdXBkYXRlQk1TRGF0YSA9IHVzZUNhbGxiYWNrKGFzeW5jIChuZXdEYXRhOiBQYXJ0aWFsPEJNU0RhdGE+KTogUHJvbWlzZTxib29sZWFuPiA9PiB7XHJcbiAgICBpZiAoIWNvbm5lY3RlZCkge1xyXG4gICAgICB0b2FzdC5lcnJvcignTm90IGNvbm5lY3RlZCB0byBjaGFyZ2luZyBzeXN0ZW0nKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0ge1xyXG4gICAgICAgIC4uLmJtc0RhdGEsXHJcbiAgICAgICAgLi4ubmV3RGF0YSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNlbmRNZXNzYWdlKHtcclxuICAgICAgICB0eXBlOiAndXBkYXRlQk1TRGF0YScsXHJcbiAgICAgICAgZGF0YTogdXBkYXRlZERhdGEsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc2V0Qk1TRGF0YSh1cGRhdGVkRGF0YSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgQk1TIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICB0b2FzdC5lcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBCTVMgZGF0YScpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSwgW2Nvbm5lY3RlZCwgc2VuZE1lc3NhZ2UsIGJtc0RhdGFdKTtcclxuXHJcbiAgLy8gUmVzZXQgQk1TIGRhdGFcclxuICBjb25zdCByZXNldEJNU0RhdGEgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAoIWNvbm5lY3RlZCkge1xyXG4gICAgICB0b2FzdC5lcnJvcignTm90IGNvbm5lY3RlZCB0byBjaGFyZ2luZyBzeXN0ZW0nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc2V0RGF0YTogQk1TRGF0YSA9IHtcclxuICAgICAgICB2b2x0YWdlOiAwLFxyXG4gICAgICAgIGN1cnJlbnQ6IDAsXHJcbiAgICAgICAgU09DOiAxNSxcclxuICAgICAgICBpc1JlY2VpdmVyQ29pbERldGVjdGVkOiBmYWxzZSxcclxuICAgICAgICBpc0ZPRDogZmFsc2UsXHJcbiAgICAgICAgLy8gdGFyZ2V0U09DOiAwLFxyXG4gICAgICAgIGlzTWlzczogZmFsc2UsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzZW5kTWVzc2FnZSh7XHJcbiAgICAgICAgdHlwZTogJ3Jlc2V0Qk1TRGF0YScsXHJcbiAgICAgICAgZGF0YTogcmVzZXREYXRhLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNldEJNU0RhdGEocmVzZXREYXRhKTtcclxuICAgICAgdG9hc3Quc3VjY2VzcygnQk1TIGRhdGEgcmVzZXQnKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc2V0dGluZyBCTVMgZGF0YTonLCBlcnJvcik7XHJcbiAgICAgIHRvYXN0LmVycm9yKCdGYWlsZWQgdG8gcmVzZXQgQk1TIGRhdGEnKTtcclxuICAgIH1cclxuICB9LCBbY29ubmVjdGVkLCBzZW5kTWVzc2FnZV0pO1xyXG5cclxuICAvLyBNb25pdG9yIHJlY2VpdmVyIGNvaWwgZGV0ZWN0aW9uXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQpIHtcclxuICAgICAgdG9hc3Quc3VjY2VzcygnUmVjZWl2ZXIgY29pbCBkZXRlY3RlZCcpO1xyXG4gICAgfSBlbHNlIGlmIChibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgIHRvYXN0LmVycm9yKCdSZWNlaXZlciBjb2lsIG5vdCBkZXRlY3RlZCcpO1xyXG4gICAgfVxyXG4gIH0sIFtibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWRdKTtcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIGNoYXJnaW5nIHBvd2VyXHJcbiAgLy8gY29uc3QgY2FsY3VsYXRlQ2hhcmdpbmdQb3dlciA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xyXG4gIC8vICAgcmV0dXJuIGJtc0RhdGEudm9sdGFnZSAqIGJtc0RhdGEuY3VycmVudDtcclxuICAvLyB9LCBbYm1zRGF0YS52b2x0YWdlLCBibXNEYXRhLmN1cnJlbnRdKTtcclxuXHJcbiAgY29uc3QgY2FsY3VsYXRlQ2hhcmdpbmdQb3dlciA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xyXG4gICAgY29uc3Qgdm9sdGFnZSA9IGJtc0RhdGE/LnZvbHRhZ2UgPz8gMDtcclxuICAgIGNvbnN0IGN1cnJlbnQgPSBibXNEYXRhPy5jdXJyZW50ID8/IDA7XHJcbiAgXHJcbiAgICBjb25zdCBwb3dlclcgPSB2b2x0YWdlICogY3VycmVudDsgLy8gUG93ZXIgaW4gV2F0dHNcclxuICAgIGNvbnN0IGVuZXJneUluY3JlbWVudCA9IHBvd2VyVyAvIDEwMDAgLyAzNjAwOyAvLyBrV2ggYWRkZWQgZXZlcnkgc2Vjb25kXHJcbiAgXHJcbiAgICByZXR1cm4gTnVtYmVyKGVuZXJneUluY3JlbWVudC50b0ZpeGVkKDYpKTsgLy8gcm91bmRlZCB0byA2IGRlY2ltYWwgcGxhY2VzXHJcbiAgfSwgW2Jtc0RhdGE/LnZvbHRhZ2UsIGJtc0RhdGE/LmN1cnJlbnRdKTtcclxuICBcclxuICBcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGJtc0RhdGEsXHJcbiAgICB1cGRhdGVCTVNEYXRhLFxyXG4gICAgcmVzZXRCTVNEYXRhLFxyXG4gICAgaXNSZWNlaXZlckNvaWxEZXRlY3RlZDogYm1zRGF0YS5pc1JlY2VpdmVyQ29pbERldGVjdGVkLFxyXG4gICAgaXNGT0Q6IGJtc0RhdGEuaXNGT0QsXHJcbiAgICBpc01pc3M6IGJtc0RhdGEuaXNNaXNzLFxyXG4gICAgY2hhcmdpbmdQb3dlcjogY2FsY3VsYXRlQ2hhcmdpbmdQb3dlcigpLFxyXG4gICAgLy8gdGFyZ2V0RW5lcmd5OiBibXNEYXRhLnRhcmdldFNPQ1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIHNvY1xyXG4vLyBcInVzZSBjbGllbnRcIjtcclxuXHJcbi8vIGltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG4vLyBpbXBvcnQgeyB1c2VXZWJTb2NrZXQgfSBmcm9tICcuLi9jb250ZXh0cy9XZWJTb2NrZXRDb250ZXh0JztcclxuLy8gaW1wb3J0IHsgdG9hc3QgfSBmcm9tICdzb25uZXInO1xyXG5cclxuLy8gaW50ZXJmYWNlIEJNU0RhdGEge1xyXG4vLyAgIHZvbHRhZ2U6IG51bWJlcjtcclxuLy8gICBjdXJyZW50OiBudW1iZXI7XHJcbi8vICAgU09DOiBudW1iZXI7XHJcbi8vICAgaXNSZWNlaXZlckNvaWxEZXRlY3RlZDogYm9vbGVhbjtcclxuLy8gICBpc0ZPRDogYm9vbGVhbjtcclxuLy8gICBpc01pc3M6IGJvb2xlYW47XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiB1c2VCTVNEYXRhKCkge1xyXG4vLyAgIGNvbnN0IHsgc2VuZE1lc3NhZ2UsIGxhc3RNZXNzYWdlLCBjb25uZWN0ZWQsIGJtc0RhdGE6IGNvbnRleHRCTVNEYXRhIH0gPSB1c2VXZWJTb2NrZXQoKTtcclxuLy8gICBjb25zdCBbYm1zRGF0YSwgc2V0Qk1TRGF0YV0gPSB1c2VTdGF0ZTxCTVNEYXRhPih7XHJcbi8vICAgICB2b2x0YWdlOiAwLFxyXG4vLyAgICAgY3VycmVudDogMCxcclxuLy8gICAgIFNPQzogMTUsXHJcbi8vICAgICBpc1JlY2VpdmVyQ29pbERldGVjdGVkOiBmYWxzZSxcclxuLy8gICAgIGlzRk9EOiBmYWxzZSxcclxuLy8gICAgIGlzTWlzczogZmFsc2UsXHJcbi8vICAgfSk7XHJcblxyXG4vLyAgIC8vIFVwZGF0ZSBCTVMgZGF0YSB3aGVuIHJlY2VpdmluZyBuZXcgbWVzc2FnZXNcclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgaWYgKGxhc3RNZXNzYWdlPy50eXBlID09PSAnYm1zX2RhdGEnICYmIGxhc3RNZXNzYWdlLmRhdGEpIHtcclxuLy8gICAgICAgc2V0Qk1TRGF0YShsYXN0TWVzc2FnZS5kYXRhIGFzIEJNU0RhdGEpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtsYXN0TWVzc2FnZV0pO1xyXG5cclxuLy8gICAvLyBTeW5jIHdpdGggY29udGV4dCBCTVMgZGF0YVxyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBzZXRCTVNEYXRhKGNvbnRleHRCTVNEYXRhKTtcclxuLy8gICB9LCBbY29udGV4dEJNU0RhdGFdKTtcclxuXHJcbi8vICAgLy8gVXBkYXRlIEJNUyBkYXRhXHJcbi8vICAgY29uc3QgdXBkYXRlQk1TRGF0YSA9IHVzZUNhbGxiYWNrKGFzeW5jIChuZXdEYXRhOiBQYXJ0aWFsPEJNU0RhdGE+KTogUHJvbWlzZTxib29sZWFuPiA9PiB7XHJcbi8vICAgICBpZiAoIWNvbm5lY3RlZCkge1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignTm90IGNvbm5lY3RlZCB0byBjaGFyZ2luZyBzeXN0ZW0nKTtcclxuLy8gICAgICAgcmV0dXJuIGZhbHNlO1xyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0ge1xyXG4vLyAgICAgICAgIC4uLmJtc0RhdGEsXHJcbi8vICAgICAgICAgLi4ubmV3RGF0YSxcclxuLy8gICAgICAgfTtcclxuXHJcbi8vICAgICAgIHNlbmRNZXNzYWdlKHtcclxuLy8gICAgICAgICB0eXBlOiAndXBkYXRlQk1TRGF0YScsXHJcbi8vICAgICAgICAgZGF0YTogdXBkYXRlZERhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgc2V0Qk1TRGF0YSh1cGRhdGVkRGF0YSk7XHJcbi8vICAgICAgIHJldHVybiB0cnVlO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgQk1TIGRhdGE6JywgZXJyb3IpO1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBCTVMgZGF0YScpO1xyXG4vLyAgICAgICByZXR1cm4gZmFsc2U7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW2Nvbm5lY3RlZCwgc2VuZE1lc3NhZ2UsIGJtc0RhdGFdKTtcclxuXHJcbi8vICAgLy8gUmVzZXQgQk1TIGRhdGFcclxuLy8gICBjb25zdCByZXNldEJNU0RhdGEgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbi8vICAgICBpZiAoIWNvbm5lY3RlZCkge1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignTm90IGNvbm5lY3RlZCB0byBjaGFyZ2luZyBzeXN0ZW0nKTtcclxuLy8gICAgICAgcmV0dXJuO1xyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc2V0RGF0YTogQk1TRGF0YSA9IHtcclxuLy8gICAgICAgICB2b2x0YWdlOiAwLFxyXG4vLyAgICAgICAgIGN1cnJlbnQ6IDAsXHJcbi8vICAgICAgICAgU09DOiAxNSxcclxuLy8gICAgICAgICBpc1JlY2VpdmVyQ29pbERldGVjdGVkOiBmYWxzZSxcclxuLy8gICAgICAgICBpc0ZPRDogZmFsc2UsXHJcbi8vICAgICAgICAgaXNNaXNzOiBmYWxzZSxcclxuLy8gICAgICAgfTtcclxuXHJcbi8vICAgICAgIHNlbmRNZXNzYWdlKHtcclxuLy8gICAgICAgICB0eXBlOiAncmVzZXRCTVNEYXRhJyxcclxuLy8gICAgICAgICBkYXRhOiByZXNldERhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgc2V0Qk1TRGF0YShyZXNldERhdGEpO1xyXG4vLyAgICAgICB0b2FzdC5zdWNjZXNzKCdCTVMgZGF0YSByZXNldCcpO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzZXR0aW5nIEJNUyBkYXRhOicsIGVycm9yKTtcclxuLy8gICAgICAgdG9hc3QuZXJyb3IoJ0ZhaWxlZCB0byByZXNldCBCTVMgZGF0YScpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtjb25uZWN0ZWQsIHNlbmRNZXNzYWdlXSk7XHJcblxyXG4vLyAgIC8vIE1vbml0b3IgcmVjZWl2ZXIgY29pbCBkZXRlY3Rpb25cclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgaWYgKGJtc0RhdGEuaXNSZWNlaXZlckNvaWxEZXRlY3RlZCkge1xyXG4vLyAgICAgICB0b2FzdC5zdWNjZXNzKCdSZWNlaXZlciBjb2lsIGRldGVjdGVkJyk7XHJcbi8vICAgICB9IGVsc2UgaWYgKGJtc0RhdGEuaXNSZWNlaXZlckNvaWxEZXRlY3RlZCA9PT0gZmFsc2UpIHtcclxuLy8gICAgICAgdG9hc3QuZXJyb3IoJ1JlY2VpdmVyIGNvaWwgbm90IGRldGVjdGVkJyk7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW2Jtc0RhdGEuaXNSZWNlaXZlckNvaWxEZXRlY3RlZF0pO1xyXG5cclxuLy8gICAvLyBDYWxjdWxhdGUgY2hhcmdpbmcgcG93ZXJcclxuLy8gICBjb25zdCBjYWxjdWxhdGVDaGFyZ2luZ1Bvd2VyID0gdXNlQ2FsbGJhY2soKCk6IG51bWJlciA9PiB7XHJcbi8vICAgICByZXR1cm4gYm1zRGF0YS52b2x0YWdlICogYm1zRGF0YS5jdXJyZW50O1xyXG4vLyAgIH0sIFtibXNEYXRhLnZvbHRhZ2UsIGJtc0RhdGEuY3VycmVudF0pO1xyXG5cclxuLy8gICByZXR1cm4ge1xyXG4vLyAgICAgYm1zRGF0YSxcclxuLy8gICAgIHVwZGF0ZUJNU0RhdGEsXHJcbi8vICAgICByZXNldEJNU0RhdGEsXHJcbi8vICAgICBpc1JlY2VpdmVyQ29pbERldGVjdGVkOiBibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQsXHJcbi8vICAgICBpc0ZPRDogYm1zRGF0YS5pc0ZPRCxcclxuLy8gICAgIGlzTWlzczogYm1zRGF0YS5pc01pc3MsXHJcbi8vICAgICBjaGFyZ2luZ1Bvd2VyOiBjYWxjdWxhdGVDaGFyZ2luZ1Bvd2VyKCksXHJcbi8vICAgfTtcclxuLy8gfVxyXG5cclxuLy9zb2NcclxuLy8gXCJ1c2UgY2xpZW50XCI7XHJcblxyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuLy8gaW1wb3J0IHsgdXNlV2ViU29ja2V0IH0gZnJvbSAnLi4vY29udGV4dHMvV2ViU29ja2V0Q29udGV4dCc7XHJcbi8vIGltcG9ydCB7IHRvYXN0IH0gZnJvbSAnc29ubmVyJztcclxuXHJcbi8vIGludGVyZmFjZSBCTVNEYXRhIHtcclxuLy8gICB2b2x0YWdlOiBudW1iZXI7XHJcbi8vICAgY3VycmVudDogbnVtYmVyO1xyXG4vLyAgIFNPQzogbnVtYmVyO1xyXG4vLyAgIHRhcmdldFNPQzogbnVtYmVyOyAvLyDinIUgQWRkZWQgdGFyZ2V0U09DXHJcbi8vICAgaXNSZWNlaXZlckNvaWxEZXRlY3RlZDogYm9vbGVhbjtcclxuLy8gICBpc0ZPRDogYm9vbGVhbjtcclxuLy8gICBpc01pc3M6IGJvb2xlYW47XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiB1c2VCTVNEYXRhKCkge1xyXG4vLyAgIGNvbnN0IHsgc2VuZE1lc3NhZ2UsIGxhc3RNZXNzYWdlLCBjb25uZWN0ZWQsIGJtc0RhdGE6IGNvbnRleHRCTVNEYXRhIH0gPSB1c2VXZWJTb2NrZXQoKTtcclxuLy8gICBjb25zdCBbYm1zRGF0YSwgc2V0Qk1TRGF0YV0gPSB1c2VTdGF0ZTxCTVNEYXRhPih7XHJcbi8vICAgICB2b2x0YWdlOiAwLFxyXG4vLyAgICAgY3VycmVudDogMCxcclxuLy8gICAgIFNPQzogMTUsXHJcbi8vICAgICB0YXJnZXRTT0M6IDEwMCwgLy8g4pyFIERlZmF1bHQgdmFsdWVcclxuLy8gICAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGZhbHNlLFxyXG4vLyAgICAgaXNGT0Q6IGZhbHNlLFxyXG4vLyAgICAgaXNNaXNzOiBmYWxzZSxcclxuLy8gICB9KTtcclxuXHJcbi8vICAgLy8gVXBkYXRlIEJNUyBkYXRhIHdoZW4gcmVjZWl2aW5nIG5ldyBtZXNzYWdlc1xyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBpZiAobGFzdE1lc3NhZ2U/LnR5cGUgPT09ICdibXNfZGF0YScgJiYgbGFzdE1lc3NhZ2UuZGF0YSkge1xyXG4vLyAgICAgICBzZXRCTVNEYXRhKGxhc3RNZXNzYWdlLmRhdGEgYXMgQk1TRGF0YSk7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW2xhc3RNZXNzYWdlXSk7XHJcblxyXG4vLyAgIC8vIFN5bmMgd2l0aCBjb250ZXh0IEJNUyBkYXRhXHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIHNldEJNU0RhdGEoY29udGV4dEJNU0RhdGEpO1xyXG4vLyAgIH0sIFtjb250ZXh0Qk1TRGF0YV0pO1xyXG5cclxuLy8gICAvLyBVcGRhdGUgQk1TIGRhdGEgKGluY2x1ZGluZyB0YXJnZXRTT0MpXHJcbi8vICAgY29uc3QgdXBkYXRlQk1TRGF0YSA9IHVzZUNhbGxiYWNrKGFzeW5jIChuZXdEYXRhOiBQYXJ0aWFsPEJNU0RhdGE+KTogUHJvbWlzZTxib29sZWFuPiA9PiB7XHJcbi8vICAgICBpZiAoIWNvbm5lY3RlZCkge1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignTm90IGNvbm5lY3RlZCB0byBjaGFyZ2luZyBzeXN0ZW0nKTtcclxuLy8gICAgICAgcmV0dXJuIGZhbHNlO1xyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0ge1xyXG4vLyAgICAgICAgIC4uLmJtc0RhdGEsXHJcbi8vICAgICAgICAgLi4ubmV3RGF0YSxcclxuLy8gICAgICAgfTtcclxuXHJcbi8vICAgICAgIC8vIFVzZSBhIGNvbnNpc3RlbnQgbWVzc2FnZSB0eXBlIGZvciBibXNfZGF0YVxyXG4vLyAgICAgICBzZW5kTWVzc2FnZSh7XHJcbi8vICAgICAgICAgdHlwZTogJ2Jtc19kYXRhJyxcclxuLy8gICAgICAgICBkYXRhOiB1cGRhdGVkRGF0YSxcclxuLy8gICAgICAgfSk7XHJcblxyXG4vLyAgICAgICBzZXRCTVNEYXRhKHVwZGF0ZWREYXRhKTtcclxuLy8gICAgICAgcmV0dXJuIHRydWU7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBCTVMgZGF0YTonLCBlcnJvcik7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIEJNUyBkYXRhJyk7XHJcbi8vICAgICAgIHJldHVybiBmYWxzZTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbY29ubmVjdGVkLCBzZW5kTWVzc2FnZSwgYm1zRGF0YV0pO1xyXG5cclxuLy8gICAvLyBSZXNldCBCTVMgZGF0YVxyXG4vLyAgIGNvbnN0IHJlc2V0Qk1TRGF0YSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuLy8gICAgIGlmICghY29ubmVjdGVkKSB7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdOb3QgY29ubmVjdGVkIHRvIGNoYXJnaW5nIHN5c3RlbScpO1xyXG4vLyAgICAgICByZXR1cm47XHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzZXREYXRhOiBCTVNEYXRhID0ge1xyXG4vLyAgICAgICAgIHZvbHRhZ2U6IDAsXHJcbi8vICAgICAgICAgY3VycmVudDogMCxcclxuLy8gICAgICAgICBTT0M6IDE1LFxyXG4vLyAgICAgICAgIHRhcmdldFNPQzogMTAwLFxyXG4vLyAgICAgICAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGZhbHNlLFxyXG4vLyAgICAgICAgIGlzRk9EOiBmYWxzZSxcclxuLy8gICAgICAgICBpc01pc3M6IGZhbHNlLFxyXG4vLyAgICAgICB9O1xyXG5cclxuLy8gICAgICAgc2VuZE1lc3NhZ2Uoe1xyXG4vLyAgICAgICAgIHR5cGU6ICdibXNfZGF0YScsXHJcbi8vICAgICAgICAgZGF0YTogcmVzZXREYXRhLFxyXG4vLyAgICAgICB9KTtcclxuXHJcbi8vICAgICAgIHNldEJNU0RhdGEocmVzZXREYXRhKTtcclxuLy8gICAgICAgdG9hc3Quc3VjY2VzcygnQk1TIGRhdGEgcmVzZXQnKTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc2V0dGluZyBCTVMgZGF0YTonLCBlcnJvcik7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdGYWlsZWQgdG8gcmVzZXQgQk1TIGRhdGEnKTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbY29ubmVjdGVkLCBzZW5kTWVzc2FnZV0pO1xyXG5cclxuLy8gICAvLyBNb25pdG9yIHJlY2VpdmVyIGNvaWwgZGV0ZWN0aW9uXHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIGlmIChibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQpIHtcclxuLy8gICAgICAgdG9hc3Quc3VjY2VzcygnUmVjZWl2ZXIgY29pbCBkZXRlY3RlZCcpO1xyXG4vLyAgICAgfSBlbHNlIGlmIChibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQgPT09IGZhbHNlKSB7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdSZWNlaXZlciBjb2lsIG5vdCBkZXRlY3RlZCcpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWRdKTtcclxuXHJcbi8vICAgLy8gQ2FsY3VsYXRlIGNoYXJnaW5nIHBvd2VyXHJcbi8vICAgY29uc3QgY2FsY3VsYXRlQ2hhcmdpbmdQb3dlciA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xyXG4vLyAgICAgcmV0dXJuIGJtc0RhdGEudm9sdGFnZSAqIGJtc0RhdGEuY3VycmVudDtcclxuLy8gICB9LCBbYm1zRGF0YS52b2x0YWdlLCBibXNEYXRhLmN1cnJlbnRdKTtcclxuXHJcbi8vICAgcmV0dXJuIHtcclxuLy8gICAgIGJtc0RhdGEsXHJcbi8vICAgICB1cGRhdGVCTVNEYXRhLFxyXG4vLyAgICAgcmVzZXRCTVNEYXRhLFxyXG4vLyAgICAgaXNSZWNlaXZlckNvaWxEZXRlY3RlZDogYm1zRGF0YS5pc1JlY2VpdmVyQ29pbERldGVjdGVkLFxyXG4vLyAgICAgaXNGT0Q6IGJtc0RhdGEuaXNGT0QsXHJcbi8vICAgICBpc01pc3M6IGJtc0RhdGEuaXNNaXNzLFxyXG4vLyAgICAgY2hhcmdpbmdQb3dlcjogY2FsY3VsYXRlQ2hhcmdpbmdQb3dlcigpLFxyXG4vLyAgIH07XHJcbi8vIH1cclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VXZWJTb2NrZXQiLCJ0b2FzdCIsInVzZUJNU0RhdGEiLCJzZW5kTWVzc2FnZSIsImxhc3RNZXNzYWdlIiwiY29ubmVjdGVkIiwiYm1zRGF0YSIsImNvbnRleHRCTVNEYXRhIiwic2V0Qk1TRGF0YSIsInZvbHRhZ2UiLCJjdXJyZW50IiwiU09DIiwiaXNSZWNlaXZlckNvaWxEZXRlY3RlZCIsImlzRk9EIiwiaXNNaXNzIiwidHlwZSIsImRhdGEiLCJ1cGRhdGVCTVNEYXRhIiwibmV3RGF0YSIsImVycm9yIiwidXBkYXRlZERhdGEiLCJjb25zb2xlIiwicmVzZXRCTVNEYXRhIiwicmVzZXREYXRhIiwic3VjY2VzcyIsImNhbGN1bGF0ZUNoYXJnaW5nUG93ZXIiLCJwb3dlclciLCJlbmVyZ3lJbmNyZW1lbnQiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwiY2hhcmdpbmdQb3dlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useBMSData.ts\n"));

/***/ })

});