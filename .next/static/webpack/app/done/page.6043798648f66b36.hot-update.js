"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/done/page",{

/***/ "(app-pages-browser)/./hooks/useBMSData.ts":
/*!*****************************!*\
  !*** ./hooks/useBMSData.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useBMSData: () => (/* binding */ useBMSData)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _contexts_WebSocketContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contexts/WebSocketContext */ \"(app-pages-browser)/./contexts/WebSocketContext.tsx\");\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n// \"use client\";\n// import { useState, useEffect, useCallback } from 'react';\n// import { useWebSocket } from '../contexts/WebSocketContext';\n// import { toast } from 'sonner';\n// interface BMSData {\n//   voltage: number;\n//   current: number;\n//   SOC: number;\n//   isReceiverCoilDetected: boolean;\n// }\n// export function useBMSData() {\n//   const { sendMessage, lastMessage, connected, bmsData: contextBMSData } = useWebSocket();\n//   const [bmsData, setBMSData] = useState<BMSData>({\n//     voltage: 0,\n//     current: 0,\n//     SOC: 15,\n//     isReceiverCoilDetected: false,\n//   });\n//   // Update BMS data when receiving new messages\n//   useEffect(() => {\n//     if (lastMessage?.type === 'bms_data' && lastMessage.data) {\n//       setBMSData(lastMessage.data as BMSData);\n//     }\n//   }, [lastMessage]);\n//   // Sync with context BMS data\n//   useEffect(() => {\n//     setBMSData(contextBMSData);\n//   }, [contextBMSData]);\n//   // Update BMS data\n//   const updateBMSData = useCallback(async (newData: Partial<BMSData>): Promise<boolean> => {\n//     if (!connected) {\n//       toast.error('Not connected to charging system');\n//       return false;\n//     }\n//     try {\n//       const updatedData = {\n//         ...bmsData,\n//         ...newData,\n//       };\n//       sendMessage({\n//         type: 'updateBMSData',\n//         data: updatedData,\n//       });\n//       setBMSData(updatedData);\n//       return true;\n//     } catch (error) {\n//       console.error('Error updating BMS data:', error);\n//       toast.error('Failed to update BMS data');\n//       return false;\n//     }\n//   }, [connected, sendMessage, bmsData]);\n//   // Reset BMS data\n//   const resetBMSData = useCallback(() => {\n//     if (!connected) {\n//       toast.error('Not connected to charging system');\n//       return;\n//     }\n//     try {\n//       const resetData: BMSData = {\n//         voltage: 0,\n//         current: 0,\n//         SOC: 15,\n//         isReceiverCoilDetected: false,\n//       };\n//       sendMessage({\n//         type: 'resetBMSData',\n//         data: resetData,\n//       });\n//       setBMSData(resetData);\n//       toast.success('BMS data reset');\n//     } catch (error) {\n//       console.error('Error resetting BMS data:', error);\n//       toast.error('Failed to reset BMS data');\n//     }\n//   }, [connected, sendMessage]);\n//   // Monitor receiver coil detection\n//   useEffect(() => {\n//     if (bmsData.isReceiverCoilDetected) {\n//       toast.success('Receiver coil detected');\n//     } else if (bmsData.isReceiverCoilDetected === false) {\n//       toast.error('Receiver coil not detected');\n//     }\n//   }, [bmsData.isReceiverCoilDetected]);\n//   // Calculate charging power\n//   const calculateChargingPower = useCallback((): number => {\n//     return bmsData.voltage * bmsData.current;\n//   }, [bmsData.voltage, bmsData.current]);\n//   return {\n//     bmsData,\n//     updateBMSData,\n//     resetBMSData,\n//     isReceiverCoilDetected: bmsData.isReceiverCoilDetected,\n//     chargingPower: calculateChargingPower(),\n//   };\n// }\n////fod\n// \"use client\";\n// import { useState, useEffect, useCallback } from 'react';\n// import { useWebSocket } from '../contexts/WebSocketContext';\n// import { toast } from 'sonner';\n// interface BMSData {\n//   voltage: number;\n//   current: number;\n//   SOC: number;\n//   isReceiverCoilDetected: boolean;\n//   isFOD: boolean;\n//   isMiss: boolean;\n// }\n// export function useBMSData() {\n//   const { sendMessage, lastMessage, connected, bmsData: contextBMSData } = useWebSocket();\n//   const [bmsData, setBMSData] = useState<BMSData>({\n//     voltage: 0,\n//     current: 0,\n//     SOC: 15,\n//     isReceiverCoilDetected: false,\n//     isFOD: false,\n//     isMiss: false,\n//   });\n//   // Update BMS data when receiving new messages\n//   useEffect(() => {\n//     if (lastMessage?.type === 'bms_data' && lastMessage.data) {\n//       setBMSData(lastMessage.data as BMSData);\n//     }\n//   }, [lastMessage]);\n//   // Sync with context BMS data\n//   useEffect(() => {\n//     setBMSData(contextBMSData);\n//   }, [contextBMSData]);\n//   // Update BMS data\n//   const updateBMSData = useCallback(async (newData: Partial<BMSData>): Promise<boolean> => {\n//     if (!connected) {\n//       toast.error('Not connected to charging system');\n//       return false;\n//     }\n//     try {\n//       const updatedData = {\n//         ...bmsData,\n//         ...newData,\n//       };\n//       sendMessage({\n//         type: 'updateBMSData',\n//         data: updatedData,\n//       });\n//       setBMSData(updatedData);\n//       return true;\n//     } catch (error) {\n//       console.error('Error updating BMS data:', error);\n//       toast.error('Failed to update BMS data');\n//       return false;\n//     }\n//   }, [connected, sendMessage, bmsData]);\n//   // Reset BMS data\n//   const resetBMSData = useCallback(() => {\n//     if (!connected) {\n//       toast.error('Not connected to charging system');\n//       return;\n//     }\n//     try {\n//       const resetData: BMSData = {\n//         voltage: 0,\n//         current: 0,\n//         SOC: 15,\n//         isReceiverCoilDetected: false,\n//         isFOD: false,\n//         isMiss: false,\n//       };\n//       sendMessage({\n//         type: 'resetBMSData',\n//         data: resetData,\n//       });\n//       setBMSData(resetData);\n//       toast.success('BMS data reset');\n//     } catch (error) {\n//       console.error('Error resetting BMS data:', error);\n//       toast.error('Failed to reset BMS data');\n//     }\n//   }, [connected, sendMessage]);\n//   // Monitor receiver coil detection\n//   useEffect(() => {\n//     if (bmsData.isReceiverCoilDetected) {\n//       toast.success('Receiver coil detected');\n//     } else if (bmsData.isReceiverCoilDetected === false) {\n//       toast.error('Receiver coil not detected');\n//     }\n//   }, [bmsData.isReceiverCoilDetected]);\n//   // Calculate charging power\n//   const calculateChargingPower = useCallback((): number => {\n//     return bmsData.voltage * bmsData.current;\n//   }, [bmsData.voltage, bmsData.current]);\n//   return {\n//     bmsData,\n//     updateBMSData,\n//     resetBMSData,\n//     isReceiverCoilDetected: bmsData.isReceiverCoilDetected,\n//     isFOD: bmsData.isFOD,\n//     isMiss: bmsData.isMiss,\n//     chargingPower: calculateChargingPower(),\n//   };\n// }\n//miss alignment\n/* __next_internal_client_entry_do_not_use__ useBMSData auto */ \n\n\nfunction useBMSData() {\n    const { sendMessage, lastMessage, connected, bmsData: contextBMSData } = (0,_contexts_WebSocketContext__WEBPACK_IMPORTED_MODULE_1__.useWebSocket)();\n    const [bmsData, setBMSData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        voltage: 0,\n        current: 0,\n        SOC: 15,\n        isReceiverCoilDetected: false,\n        // targetSOC: 0,\n        isFOD: false,\n        isMiss: false\n    });\n    // Update BMS data when receiving new messages\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useBMSData.useEffect\": ()=>{\n            if ((lastMessage === null || lastMessage === void 0 ? void 0 : lastMessage.type) === 'bms_data' && lastMessage.data) {\n                setBMSData(lastMessage.data);\n            }\n        }\n    }[\"useBMSData.useEffect\"], [\n        lastMessage\n    ]);\n    // Sync with context BMS data\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useBMSData.useEffect\": ()=>{\n            setBMSData(contextBMSData);\n        }\n    }[\"useBMSData.useEffect\"], [\n        contextBMSData\n    ]);\n    // Update BMS data\n    const updateBMSData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBMSData.useCallback[updateBMSData]\": async (newData)=>{\n            if (!connected) {\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.error('Not connected to charging system');\n                return false;\n            }\n            try {\n                const updatedData = {\n                    ...bmsData,\n                    ...newData\n                };\n                sendMessage({\n                    type: 'updateBMSData',\n                    data: updatedData\n                });\n                setBMSData(updatedData);\n                return true;\n            } catch (error) {\n                console.error('Error updating BMS data:', error);\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.error('Failed to update BMS data');\n                return false;\n            }\n        }\n    }[\"useBMSData.useCallback[updateBMSData]\"], [\n        connected,\n        sendMessage,\n        bmsData\n    ]);\n    // Reset BMS data\n    const resetBMSData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBMSData.useCallback[resetBMSData]\": ()=>{\n            if (!connected) {\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.error('Not connected to charging system');\n                return;\n            }\n            try {\n                const resetData = {\n                    voltage: 0,\n                    current: 0,\n                    SOC: 15,\n                    isReceiverCoilDetected: false,\n                    isFOD: false,\n                    // targetSOC: 0,\n                    isMiss: false\n                };\n                sendMessage({\n                    type: 'resetBMSData',\n                    data: resetData\n                });\n                setBMSData(resetData);\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.success('BMS data reset');\n            } catch (error) {\n                console.error('Error resetting BMS data:', error);\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.error('Failed to reset BMS data');\n            }\n        }\n    }[\"useBMSData.useCallback[resetBMSData]\"], [\n        connected,\n        sendMessage\n    ]);\n    // Monitor receiver coil detection\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useBMSData.useEffect\": ()=>{\n            if (bmsData.isReceiverCoilDetected) {\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.success('Receiver coil detected');\n            } else if (bmsData.isReceiverCoilDetected === false) {\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.error('Receiver coil not detected');\n            }\n        }\n    }[\"useBMSData.useEffect\"], [\n        bmsData.isReceiverCoilDetected\n    ]);\n    // Calculate charging power\n    // const calculateChargingPower = useCallback((): number => {\n    //   return bmsData.voltage * bmsData.current;\n    // }, [bmsData.voltage, bmsData.current]);\n    const calculateChargingPower = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBMSData.useCallback[calculateChargingPower]\": ()=>{\n            const { voltage = 0, current = 0 } = bmsData || {};\n            const powerW = voltage * current; // watts\n            const energyIncrement = powerW / 1000 / 3600; // kWh per second\n            return Number(energyIncrement.toFixed(6));\n        }\n    }[\"useBMSData.useCallback[calculateChargingPower]\"], [\n        bmsData\n    ]);\n    return {\n        bmsData,\n        updateBMSData,\n        resetBMSData,\n        isReceiverCoilDetected: bmsData.isReceiverCoilDetected,\n        isFOD: bmsData.isFOD,\n        isMiss: bmsData.isMiss,\n        chargingPower: calculateChargingPower()\n    };\n} // soc\n // \"use client\";\n // import { useState, useEffect, useCallback } from 'react';\n // import { useWebSocket } from '../contexts/WebSocketContext';\n // import { toast } from 'sonner';\n // interface BMSData {\n //   voltage: number;\n //   current: number;\n //   SOC: number;\n //   isReceiverCoilDetected: boolean;\n //   isFOD: boolean;\n //   isMiss: boolean;\n // }\n // export function useBMSData() {\n //   const { sendMessage, lastMessage, connected, bmsData: contextBMSData } = useWebSocket();\n //   const [bmsData, setBMSData] = useState<BMSData>({\n //     voltage: 0,\n //     current: 0,\n //     SOC: 15,\n //     isReceiverCoilDetected: false,\n //     isFOD: false,\n //     isMiss: false,\n //   });\n //   // Update BMS data when receiving new messages\n //   useEffect(() => {\n //     if (lastMessage?.type === 'bms_data' && lastMessage.data) {\n //       setBMSData(lastMessage.data as BMSData);\n //     }\n //   }, [lastMessage]);\n //   // Sync with context BMS data\n //   useEffect(() => {\n //     setBMSData(contextBMSData);\n //   }, [contextBMSData]);\n //   // Update BMS data\n //   const updateBMSData = useCallback(async (newData: Partial<BMSData>): Promise<boolean> => {\n //     if (!connected) {\n //       toast.error('Not connected to charging system');\n //       return false;\n //     }\n //     try {\n //       const updatedData = {\n //         ...bmsData,\n //         ...newData,\n //       };\n //       sendMessage({\n //         type: 'updateBMSData',\n //         data: updatedData,\n //       });\n //       setBMSData(updatedData);\n //       return true;\n //     } catch (error) {\n //       console.error('Error updating BMS data:', error);\n //       toast.error('Failed to update BMS data');\n //       return false;\n //     }\n //   }, [connected, sendMessage, bmsData]);\n //   // Reset BMS data\n //   const resetBMSData = useCallback(() => {\n //     if (!connected) {\n //       toast.error('Not connected to charging system');\n //       return;\n //     }\n //     try {\n //       const resetData: BMSData = {\n //         voltage: 0,\n //         current: 0,\n //         SOC: 15,\n //         isReceiverCoilDetected: false,\n //         isFOD: false,\n //         isMiss: false,\n //       };\n //       sendMessage({\n //         type: 'resetBMSData',\n //         data: resetData,\n //       });\n //       setBMSData(resetData);\n //       toast.success('BMS data reset');\n //     } catch (error) {\n //       console.error('Error resetting BMS data:', error);\n //       toast.error('Failed to reset BMS data');\n //     }\n //   }, [connected, sendMessage]);\n //   // Monitor receiver coil detection\n //   useEffect(() => {\n //     if (bmsData.isReceiverCoilDetected) {\n //       toast.success('Receiver coil detected');\n //     } else if (bmsData.isReceiverCoilDetected === false) {\n //       toast.error('Receiver coil not detected');\n //     }\n //   }, [bmsData.isReceiverCoilDetected]);\n //   // Calculate charging power\n //   const calculateChargingPower = useCallback((): number => {\n //     return bmsData.voltage * bmsData.current;\n //   }, [bmsData.voltage, bmsData.current]);\n //   return {\n //     bmsData,\n //     updateBMSData,\n //     resetBMSData,\n //     isReceiverCoilDetected: bmsData.isReceiverCoilDetected,\n //     isFOD: bmsData.isFOD,\n //     isMiss: bmsData.isMiss,\n //     chargingPower: calculateChargingPower(),\n //   };\n // }\n //soc\n // \"use client\";\n // import { useState, useEffect, useCallback } from 'react';\n // import { useWebSocket } from '../contexts/WebSocketContext';\n // import { toast } from 'sonner';\n // interface BMSData {\n //   voltage: number;\n //   current: number;\n //   SOC: number;\n //   targetSOC: number; // ✅ Added targetSOC\n //   isReceiverCoilDetected: boolean;\n //   isFOD: boolean;\n //   isMiss: boolean;\n // }\n // export function useBMSData() {\n //   const { sendMessage, lastMessage, connected, bmsData: contextBMSData } = useWebSocket();\n //   const [bmsData, setBMSData] = useState<BMSData>({\n //     voltage: 0,\n //     current: 0,\n //     SOC: 15,\n //     targetSOC: 100, // ✅ Default value\n //     isReceiverCoilDetected: false,\n //     isFOD: false,\n //     isMiss: false,\n //   });\n //   // Update BMS data when receiving new messages\n //   useEffect(() => {\n //     if (lastMessage?.type === 'bms_data' && lastMessage.data) {\n //       setBMSData(lastMessage.data as BMSData);\n //     }\n //   }, [lastMessage]);\n //   // Sync with context BMS data\n //   useEffect(() => {\n //     setBMSData(contextBMSData);\n //   }, [contextBMSData]);\n //   // Update BMS data (including targetSOC)\n //   const updateBMSData = useCallback(async (newData: Partial<BMSData>): Promise<boolean> => {\n //     if (!connected) {\n //       toast.error('Not connected to charging system');\n //       return false;\n //     }\n //     try {\n //       const updatedData = {\n //         ...bmsData,\n //         ...newData,\n //       };\n //       // Use a consistent message type for bms_data\n //       sendMessage({\n //         type: 'bms_data',\n //         data: updatedData,\n //       });\n //       setBMSData(updatedData);\n //       return true;\n //     } catch (error) {\n //       console.error('Error updating BMS data:', error);\n //       toast.error('Failed to update BMS data');\n //       return false;\n //     }\n //   }, [connected, sendMessage, bmsData]);\n //   // Reset BMS data\n //   const resetBMSData = useCallback(() => {\n //     if (!connected) {\n //       toast.error('Not connected to charging system');\n //       return;\n //     }\n //     try {\n //       const resetData: BMSData = {\n //         voltage: 0,\n //         current: 0,\n //         SOC: 15,\n //         targetSOC: 100,\n //         isReceiverCoilDetected: false,\n //         isFOD: false,\n //         isMiss: false,\n //       };\n //       sendMessage({\n //         type: 'bms_data',\n //         data: resetData,\n //       });\n //       setBMSData(resetData);\n //       toast.success('BMS data reset');\n //     } catch (error) {\n //       console.error('Error resetting BMS data:', error);\n //       toast.error('Failed to reset BMS data');\n //     }\n //   }, [connected, sendMessage]);\n //   // Monitor receiver coil detection\n //   useEffect(() => {\n //     if (bmsData.isReceiverCoilDetected) {\n //       toast.success('Receiver coil detected');\n //     } else if (bmsData.isReceiverCoilDetected === false) {\n //       toast.error('Receiver coil not detected');\n //     }\n //   }, [bmsData.isReceiverCoilDetected]);\n //   // Calculate charging power\n //   const calculateChargingPower = useCallback((): number => {\n //     return bmsData.voltage * bmsData.current;\n //   }, [bmsData.voltage, bmsData.current]);\n //   return {\n //     bmsData,\n //     updateBMSData,\n //     resetBMSData,\n //     isReceiverCoilDetected: bmsData.isReceiverCoilDetected,\n //     isFOD: bmsData.isFOD,\n //     isMiss: bmsData.isMiss,\n //     chargingPower: calculateChargingPower(),\n //   };\n // }\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUJNU0RhdGEudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxnQkFBZ0I7QUFFaEIsNERBQTREO0FBQzVELCtEQUErRDtBQUMvRCxrQ0FBa0M7QUFFbEMsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLHFDQUFxQztBQUNyQyxJQUFJO0FBRUosaUNBQWlDO0FBQ2pDLDZGQUE2RjtBQUM3RixzREFBc0Q7QUFDdEQsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YscUNBQXFDO0FBQ3JDLFFBQVE7QUFFUixtREFBbUQ7QUFDbkQsc0JBQXNCO0FBQ3RCLGtFQUFrRTtBQUNsRSxpREFBaUQ7QUFDakQsUUFBUTtBQUNSLHVCQUF1QjtBQUV2QixrQ0FBa0M7QUFDbEMsc0JBQXNCO0FBQ3RCLGtDQUFrQztBQUNsQywwQkFBMEI7QUFFMUIsdUJBQXVCO0FBQ3ZCLCtGQUErRjtBQUMvRix3QkFBd0I7QUFDeEIseURBQXlEO0FBQ3pELHNCQUFzQjtBQUN0QixRQUFRO0FBRVIsWUFBWTtBQUNaLDhCQUE4QjtBQUM5QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLFdBQVc7QUFFWCxzQkFBc0I7QUFDdEIsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QixZQUFZO0FBRVosaUNBQWlDO0FBQ2pDLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIsMERBQTBEO0FBQzFELGtEQUFrRDtBQUNsRCxzQkFBc0I7QUFDdEIsUUFBUTtBQUNSLDJDQUEyQztBQUUzQyxzQkFBc0I7QUFDdEIsNkNBQTZDO0FBQzdDLHdCQUF3QjtBQUN4Qix5REFBeUQ7QUFDekQsZ0JBQWdCO0FBQ2hCLFFBQVE7QUFFUixZQUFZO0FBQ1oscUNBQXFDO0FBQ3JDLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLHlDQUF5QztBQUN6QyxXQUFXO0FBRVgsc0JBQXNCO0FBQ3RCLGdDQUFnQztBQUNoQywyQkFBMkI7QUFDM0IsWUFBWTtBQUVaLCtCQUErQjtBQUMvQix5Q0FBeUM7QUFDekMsd0JBQXdCO0FBQ3hCLDJEQUEyRDtBQUMzRCxpREFBaUQ7QUFDakQsUUFBUTtBQUNSLGtDQUFrQztBQUVsQyx1Q0FBdUM7QUFDdkMsc0JBQXNCO0FBQ3RCLDRDQUE0QztBQUM1QyxpREFBaUQ7QUFDakQsNkRBQTZEO0FBQzdELG1EQUFtRDtBQUNuRCxRQUFRO0FBQ1IsMENBQTBDO0FBRTFDLGdDQUFnQztBQUNoQywrREFBK0Q7QUFDL0QsZ0RBQWdEO0FBQ2hELDRDQUE0QztBQUU1QyxhQUFhO0FBQ2IsZUFBZTtBQUNmLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsOERBQThEO0FBQzlELCtDQUErQztBQUMvQyxPQUFPO0FBQ1AsSUFBSTtBQUdKLE9BQU87QUFFUCxnQkFBZ0I7QUFFaEIsNERBQTREO0FBQzVELCtEQUErRDtBQUMvRCxrQ0FBa0M7QUFFbEMsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLHFDQUFxQztBQUNyQyxvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLElBQUk7QUFFSixpQ0FBaUM7QUFDakMsNkZBQTZGO0FBQzdGLHNEQUFzRDtBQUN0RCxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGVBQWU7QUFDZixxQ0FBcUM7QUFDckMsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixRQUFRO0FBRVIsbURBQW1EO0FBQ25ELHNCQUFzQjtBQUN0QixrRUFBa0U7QUFDbEUsaURBQWlEO0FBQ2pELFFBQVE7QUFDUix1QkFBdUI7QUFFdkIsa0NBQWtDO0FBQ2xDLHNCQUFzQjtBQUN0QixrQ0FBa0M7QUFDbEMsMEJBQTBCO0FBRTFCLHVCQUF1QjtBQUN2QiwrRkFBK0Y7QUFDL0Ysd0JBQXdCO0FBQ3hCLHlEQUF5RDtBQUN6RCxzQkFBc0I7QUFDdEIsUUFBUTtBQUVSLFlBQVk7QUFDWiw4QkFBOEI7QUFDOUIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixXQUFXO0FBRVgsc0JBQXNCO0FBQ3RCLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IsWUFBWTtBQUVaLGlDQUFpQztBQUNqQyxxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLDBEQUEwRDtBQUMxRCxrREFBa0Q7QUFDbEQsc0JBQXNCO0FBQ3RCLFFBQVE7QUFDUiwyQ0FBMkM7QUFFM0Msc0JBQXNCO0FBQ3RCLDZDQUE2QztBQUM3Qyx3QkFBd0I7QUFDeEIseURBQXlEO0FBQ3pELGdCQUFnQjtBQUNoQixRQUFRO0FBRVIsWUFBWTtBQUNaLHFDQUFxQztBQUNyQyxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQix5Q0FBeUM7QUFDekMsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QixXQUFXO0FBRVgsc0JBQXNCO0FBQ3RCLGdDQUFnQztBQUNoQywyQkFBMkI7QUFDM0IsWUFBWTtBQUVaLCtCQUErQjtBQUMvQix5Q0FBeUM7QUFDekMsd0JBQXdCO0FBQ3hCLDJEQUEyRDtBQUMzRCxpREFBaUQ7QUFDakQsUUFBUTtBQUNSLGtDQUFrQztBQUVsQyx1Q0FBdUM7QUFDdkMsc0JBQXNCO0FBQ3RCLDRDQUE0QztBQUM1QyxpREFBaUQ7QUFDakQsNkRBQTZEO0FBQzdELG1EQUFtRDtBQUNuRCxRQUFRO0FBQ1IsMENBQTBDO0FBRTFDLGdDQUFnQztBQUNoQywrREFBK0Q7QUFDL0QsZ0RBQWdEO0FBQ2hELDRDQUE0QztBQUU1QyxhQUFhO0FBQ2IsZUFBZTtBQUNmLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsOERBQThEO0FBQzlELDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsK0NBQStDO0FBQy9DLE9BQU87QUFDUCxJQUFJO0FBRUosZ0JBQWdCO2dFQUd5QztBQUNHO0FBQzdCO0FBWXhCLFNBQVNLO0lBQ2QsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsU0FBUyxFQUFFQyxTQUFTQyxjQUFjLEVBQUUsR0FBR1Asd0VBQVlBO0lBQ3JGLE1BQU0sQ0FBQ00sU0FBU0UsV0FBVyxHQUFHWCwrQ0FBUUEsQ0FBVTtRQUM5Q1ksU0FBUztRQUNUQyxTQUFTO1FBQ1RDLEtBQUs7UUFDTEMsd0JBQXdCO1FBQ3hCLGdCQUFnQjtRQUNoQkMsT0FBTztRQUNQQyxRQUFRO0lBQ1Y7SUFFQSw4Q0FBOEM7SUFDOUNoQixnREFBU0E7Z0NBQUM7WUFDUixJQUFJTSxDQUFBQSx3QkFBQUEsa0NBQUFBLFlBQWFXLElBQUksTUFBSyxjQUFjWCxZQUFZWSxJQUFJLEVBQUU7Z0JBQ3hEUixXQUFXSixZQUFZWSxJQUFJO1lBQzdCO1FBQ0Y7K0JBQUc7UUFBQ1o7S0FBWTtJQUVoQiw2QkFBNkI7SUFDN0JOLGdEQUFTQTtnQ0FBQztZQUNSVSxXQUFXRDtRQUNiOytCQUFHO1FBQUNBO0tBQWU7SUFFbkIsa0JBQWtCO0lBQ2xCLE1BQU1VLGdCQUFnQmxCLGtEQUFXQTtpREFBQyxPQUFPbUI7WUFDdkMsSUFBSSxDQUFDYixXQUFXO2dCQUNkSix5Q0FBS0EsQ0FBQ2tCLEtBQUssQ0FBQztnQkFDWixPQUFPO1lBQ1Q7WUFFQSxJQUFJO2dCQUNGLE1BQU1DLGNBQWM7b0JBQ2xCLEdBQUdkLE9BQU87b0JBQ1YsR0FBR1ksT0FBTztnQkFDWjtnQkFFQWYsWUFBWTtvQkFDVlksTUFBTTtvQkFDTkMsTUFBTUk7Z0JBQ1I7Z0JBRUFaLFdBQVdZO2dCQUNYLE9BQU87WUFDVCxFQUFFLE9BQU9ELE9BQU87Z0JBQ2RFLFFBQVFGLEtBQUssQ0FBQyw0QkFBNEJBO2dCQUMxQ2xCLHlDQUFLQSxDQUFDa0IsS0FBSyxDQUFDO2dCQUNaLE9BQU87WUFDVDtRQUNGO2dEQUFHO1FBQUNkO1FBQVdGO1FBQWFHO0tBQVE7SUFFcEMsaUJBQWlCO0lBQ2pCLE1BQU1nQixlQUFldkIsa0RBQVdBO2dEQUFDO1lBQy9CLElBQUksQ0FBQ00sV0FBVztnQkFDZEoseUNBQUtBLENBQUNrQixLQUFLLENBQUM7Z0JBQ1o7WUFDRjtZQUVBLElBQUk7Z0JBQ0YsTUFBTUksWUFBcUI7b0JBQ3pCZCxTQUFTO29CQUNUQyxTQUFTO29CQUNUQyxLQUFLO29CQUNMQyx3QkFBd0I7b0JBQ3hCQyxPQUFPO29CQUNQLGdCQUFnQjtvQkFDaEJDLFFBQVE7Z0JBQ1Y7Z0JBRUFYLFlBQVk7b0JBQ1ZZLE1BQU07b0JBQ05DLE1BQU1PO2dCQUNSO2dCQUVBZixXQUFXZTtnQkFDWHRCLHlDQUFLQSxDQUFDdUIsT0FBTyxDQUFDO1lBQ2hCLEVBQUUsT0FBT0wsT0FBTztnQkFDZEUsUUFBUUYsS0FBSyxDQUFDLDZCQUE2QkE7Z0JBQzNDbEIseUNBQUtBLENBQUNrQixLQUFLLENBQUM7WUFDZDtRQUNGOytDQUFHO1FBQUNkO1FBQVdGO0tBQVk7SUFFM0Isa0NBQWtDO0lBQ2xDTCxnREFBU0E7Z0NBQUM7WUFDUixJQUFJUSxRQUFRTSxzQkFBc0IsRUFBRTtnQkFDbENYLHlDQUFLQSxDQUFDdUIsT0FBTyxDQUFDO1lBQ2hCLE9BQU8sSUFBSWxCLFFBQVFNLHNCQUFzQixLQUFLLE9BQU87Z0JBQ25EWCx5Q0FBS0EsQ0FBQ2tCLEtBQUssQ0FBQztZQUNkO1FBQ0Y7K0JBQUc7UUFBQ2IsUUFBUU0sc0JBQXNCO0tBQUM7SUFFbkMsMkJBQTJCO0lBQzNCLDZEQUE2RDtJQUM3RCw4Q0FBOEM7SUFDOUMsMENBQTBDO0lBRTFDLE1BQU1hLHlCQUF5QjFCLGtEQUFXQTswREFBQztZQUN6QyxNQUFNLEVBQUVVLFVBQVUsQ0FBQyxFQUFFQyxVQUFVLENBQUMsRUFBRSxHQUFHSixXQUFXLENBQUM7WUFDakQsTUFBTW9CLFNBQVNqQixVQUFVQyxTQUFTLFFBQVE7WUFDMUMsTUFBTWlCLGtCQUFrQixTQUFVLE9BQVEsTUFBTSxpQkFBaUI7WUFDakUsT0FBT0MsT0FBT0QsZ0JBQWdCRSxPQUFPLENBQUM7UUFDeEM7eURBQUc7UUFBQ3ZCO0tBQVE7SUFHWixPQUFPO1FBQ0xBO1FBQ0FXO1FBQ0FLO1FBQ0FWLHdCQUF3Qk4sUUFBUU0sc0JBQXNCO1FBQ3REQyxPQUFPUCxRQUFRTyxLQUFLO1FBQ3BCQyxRQUFRUixRQUFRUSxNQUFNO1FBQ3RCZ0IsZUFBZUw7SUFFakI7QUFDRixFQUVBLE1BQU07Q0FDTixnQkFBZ0I7Q0FFaEIsNERBQTREO0NBQzVELCtEQUErRDtDQUMvRCxrQ0FBa0M7Q0FFbEMsc0JBQXNCO0NBQ3RCLHFCQUFxQjtDQUNyQixxQkFBcUI7Q0FDckIsaUJBQWlCO0NBQ2pCLHFDQUFxQztDQUNyQyxvQkFBb0I7Q0FDcEIscUJBQXFCO0NBQ3JCLElBQUk7Q0FFSixpQ0FBaUM7Q0FDakMsNkZBQTZGO0NBQzdGLHNEQUFzRDtDQUN0RCxrQkFBa0I7Q0FDbEIsa0JBQWtCO0NBQ2xCLGVBQWU7Q0FDZixxQ0FBcUM7Q0FDckMsb0JBQW9CO0NBQ3BCLHFCQUFxQjtDQUNyQixRQUFRO0NBRVIsbURBQW1EO0NBQ25ELHNCQUFzQjtDQUN0QixrRUFBa0U7Q0FDbEUsaURBQWlEO0NBQ2pELFFBQVE7Q0FDUix1QkFBdUI7Q0FFdkIsa0NBQWtDO0NBQ2xDLHNCQUFzQjtDQUN0QixrQ0FBa0M7Q0FDbEMsMEJBQTBCO0NBRTFCLHVCQUF1QjtDQUN2QiwrRkFBK0Y7Q0FDL0Ysd0JBQXdCO0NBQ3hCLHlEQUF5RDtDQUN6RCxzQkFBc0I7Q0FDdEIsUUFBUTtDQUVSLFlBQVk7Q0FDWiw4QkFBOEI7Q0FDOUIsc0JBQXNCO0NBQ3RCLHNCQUFzQjtDQUN0QixXQUFXO0NBRVgsc0JBQXNCO0NBQ3RCLGlDQUFpQztDQUNqQyw2QkFBNkI7Q0FDN0IsWUFBWTtDQUVaLGlDQUFpQztDQUNqQyxxQkFBcUI7Q0FDckIsd0JBQXdCO0NBQ3hCLDBEQUEwRDtDQUMxRCxrREFBa0Q7Q0FDbEQsc0JBQXNCO0NBQ3RCLFFBQVE7Q0FDUiwyQ0FBMkM7Q0FFM0Msc0JBQXNCO0NBQ3RCLDZDQUE2QztDQUM3Qyx3QkFBd0I7Q0FDeEIseURBQXlEO0NBQ3pELGdCQUFnQjtDQUNoQixRQUFRO0NBRVIsWUFBWTtDQUNaLHFDQUFxQztDQUNyQyxzQkFBc0I7Q0FDdEIsc0JBQXNCO0NBQ3RCLG1CQUFtQjtDQUNuQix5Q0FBeUM7Q0FDekMsd0JBQXdCO0NBQ3hCLHlCQUF5QjtDQUN6QixXQUFXO0NBRVgsc0JBQXNCO0NBQ3RCLGdDQUFnQztDQUNoQywyQkFBMkI7Q0FDM0IsWUFBWTtDQUVaLCtCQUErQjtDQUMvQix5Q0FBeUM7Q0FDekMsd0JBQXdCO0NBQ3hCLDJEQUEyRDtDQUMzRCxpREFBaUQ7Q0FDakQsUUFBUTtDQUNSLGtDQUFrQztDQUVsQyx1Q0FBdUM7Q0FDdkMsc0JBQXNCO0NBQ3RCLDRDQUE0QztDQUM1QyxpREFBaUQ7Q0FDakQsNkRBQTZEO0NBQzdELG1EQUFtRDtDQUNuRCxRQUFRO0NBQ1IsMENBQTBDO0NBRTFDLGdDQUFnQztDQUNoQywrREFBK0Q7Q0FDL0QsZ0RBQWdEO0NBQ2hELDRDQUE0QztDQUU1QyxhQUFhO0NBQ2IsZUFBZTtDQUNmLHFCQUFxQjtDQUNyQixvQkFBb0I7Q0FDcEIsOERBQThEO0NBQzlELDRCQUE0QjtDQUM1Qiw4QkFBOEI7Q0FDOUIsK0NBQStDO0NBQy9DLE9BQU87Q0FDUCxJQUFJO0NBRUosS0FBSztDQUNMLGdCQUFnQjtDQUVoQiw0REFBNEQ7Q0FDNUQsK0RBQStEO0NBQy9ELGtDQUFrQztDQUVsQyxzQkFBc0I7Q0FDdEIscUJBQXFCO0NBQ3JCLHFCQUFxQjtDQUNyQixpQkFBaUI7Q0FDakIsNENBQTRDO0NBQzVDLHFDQUFxQztDQUNyQyxvQkFBb0I7Q0FDcEIscUJBQXFCO0NBQ3JCLElBQUk7Q0FFSixpQ0FBaUM7Q0FDakMsNkZBQTZGO0NBQzdGLHNEQUFzRDtDQUN0RCxrQkFBa0I7Q0FDbEIsa0JBQWtCO0NBQ2xCLGVBQWU7Q0FDZix5Q0FBeUM7Q0FDekMscUNBQXFDO0NBQ3JDLG9CQUFvQjtDQUNwQixxQkFBcUI7Q0FDckIsUUFBUTtDQUVSLG1EQUFtRDtDQUNuRCxzQkFBc0I7Q0FDdEIsa0VBQWtFO0NBQ2xFLGlEQUFpRDtDQUNqRCxRQUFRO0NBQ1IsdUJBQXVCO0NBRXZCLGtDQUFrQztDQUNsQyxzQkFBc0I7Q0FDdEIsa0NBQWtDO0NBQ2xDLDBCQUEwQjtDQUUxQiw2Q0FBNkM7Q0FDN0MsK0ZBQStGO0NBQy9GLHdCQUF3QjtDQUN4Qix5REFBeUQ7Q0FDekQsc0JBQXNCO0NBQ3RCLFFBQVE7Q0FFUixZQUFZO0NBQ1osOEJBQThCO0NBQzlCLHNCQUFzQjtDQUN0QixzQkFBc0I7Q0FDdEIsV0FBVztDQUVYLHNEQUFzRDtDQUN0RCxzQkFBc0I7Q0FDdEIsNEJBQTRCO0NBQzVCLDZCQUE2QjtDQUM3QixZQUFZO0NBRVosaUNBQWlDO0NBQ2pDLHFCQUFxQjtDQUNyQix3QkFBd0I7Q0FDeEIsMERBQTBEO0NBQzFELGtEQUFrRDtDQUNsRCxzQkFBc0I7Q0FDdEIsUUFBUTtDQUNSLDJDQUEyQztDQUUzQyxzQkFBc0I7Q0FDdEIsNkNBQTZDO0NBQzdDLHdCQUF3QjtDQUN4Qix5REFBeUQ7Q0FDekQsZ0JBQWdCO0NBQ2hCLFFBQVE7Q0FFUixZQUFZO0NBQ1oscUNBQXFDO0NBQ3JDLHNCQUFzQjtDQUN0QixzQkFBc0I7Q0FDdEIsbUJBQW1CO0NBQ25CLDBCQUEwQjtDQUMxQix5Q0FBeUM7Q0FDekMsd0JBQXdCO0NBQ3hCLHlCQUF5QjtDQUN6QixXQUFXO0NBRVgsc0JBQXNCO0NBQ3RCLDRCQUE0QjtDQUM1QiwyQkFBMkI7Q0FDM0IsWUFBWTtDQUVaLCtCQUErQjtDQUMvQix5Q0FBeUM7Q0FDekMsd0JBQXdCO0NBQ3hCLDJEQUEyRDtDQUMzRCxpREFBaUQ7Q0FDakQsUUFBUTtDQUNSLGtDQUFrQztDQUVsQyx1Q0FBdUM7Q0FDdkMsc0JBQXNCO0NBQ3RCLDRDQUE0QztDQUM1QyxpREFBaUQ7Q0FDakQsNkRBQTZEO0NBQzdELG1EQUFtRDtDQUNuRCxRQUFRO0NBQ1IsMENBQTBDO0NBRTFDLGdDQUFnQztDQUNoQywrREFBK0Q7Q0FDL0QsZ0RBQWdEO0NBQ2hELDRDQUE0QztDQUU1QyxhQUFhO0NBQ2IsZUFBZTtDQUNmLHFCQUFxQjtDQUNyQixvQkFBb0I7Q0FDcEIsOERBQThEO0NBQzlELDRCQUE0QjtDQUM1Qiw4QkFBOEI7Q0FDOUIsK0NBQStDO0NBQy9DLE9BQU87Q0FDUCxJQUFJIiwic291cmNlcyI6WyJEOlxcY29kaW5nXFxkYXNoIGR5bmFtaWNzXFxkYXNoYm9hcmRzXFxMb2NhbGJhY2tlbmRcXGNoYXJnaW5nLXN5c3RlbVxcaG9va3NcXHVzZUJNU0RhdGEudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gXCJ1c2UgY2xpZW50XCI7XHJcblxyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuLy8gaW1wb3J0IHsgdXNlV2ViU29ja2V0IH0gZnJvbSAnLi4vY29udGV4dHMvV2ViU29ja2V0Q29udGV4dCc7XHJcbi8vIGltcG9ydCB7IHRvYXN0IH0gZnJvbSAnc29ubmVyJztcclxuXHJcbi8vIGludGVyZmFjZSBCTVNEYXRhIHtcclxuLy8gICB2b2x0YWdlOiBudW1iZXI7XHJcbi8vICAgY3VycmVudDogbnVtYmVyO1xyXG4vLyAgIFNPQzogbnVtYmVyO1xyXG4vLyAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGJvb2xlYW47XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiB1c2VCTVNEYXRhKCkge1xyXG4vLyAgIGNvbnN0IHsgc2VuZE1lc3NhZ2UsIGxhc3RNZXNzYWdlLCBjb25uZWN0ZWQsIGJtc0RhdGE6IGNvbnRleHRCTVNEYXRhIH0gPSB1c2VXZWJTb2NrZXQoKTtcclxuLy8gICBjb25zdCBbYm1zRGF0YSwgc2V0Qk1TRGF0YV0gPSB1c2VTdGF0ZTxCTVNEYXRhPih7XHJcbi8vICAgICB2b2x0YWdlOiAwLFxyXG4vLyAgICAgY3VycmVudDogMCxcclxuLy8gICAgIFNPQzogMTUsXHJcbi8vICAgICBpc1JlY2VpdmVyQ29pbERldGVjdGVkOiBmYWxzZSxcclxuLy8gICB9KTtcclxuXHJcbi8vICAgLy8gVXBkYXRlIEJNUyBkYXRhIHdoZW4gcmVjZWl2aW5nIG5ldyBtZXNzYWdlc1xyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBpZiAobGFzdE1lc3NhZ2U/LnR5cGUgPT09ICdibXNfZGF0YScgJiYgbGFzdE1lc3NhZ2UuZGF0YSkge1xyXG4vLyAgICAgICBzZXRCTVNEYXRhKGxhc3RNZXNzYWdlLmRhdGEgYXMgQk1TRGF0YSk7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW2xhc3RNZXNzYWdlXSk7XHJcblxyXG4vLyAgIC8vIFN5bmMgd2l0aCBjb250ZXh0IEJNUyBkYXRhXHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIHNldEJNU0RhdGEoY29udGV4dEJNU0RhdGEpO1xyXG4vLyAgIH0sIFtjb250ZXh0Qk1TRGF0YV0pO1xyXG5cclxuLy8gICAvLyBVcGRhdGUgQk1TIGRhdGFcclxuLy8gICBjb25zdCB1cGRhdGVCTVNEYXRhID0gdXNlQ2FsbGJhY2soYXN5bmMgKG5ld0RhdGE6IFBhcnRpYWw8Qk1TRGF0YT4pOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcclxuLy8gICAgIGlmICghY29ubmVjdGVkKSB7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdOb3QgY29ubmVjdGVkIHRvIGNoYXJnaW5nIHN5c3RlbScpO1xyXG4vLyAgICAgICByZXR1cm4gZmFsc2U7XHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSB7XHJcbi8vICAgICAgICAgLi4uYm1zRGF0YSxcclxuLy8gICAgICAgICAuLi5uZXdEYXRhLFxyXG4vLyAgICAgICB9O1xyXG5cclxuLy8gICAgICAgc2VuZE1lc3NhZ2Uoe1xyXG4vLyAgICAgICAgIHR5cGU6ICd1cGRhdGVCTVNEYXRhJyxcclxuLy8gICAgICAgICBkYXRhOiB1cGRhdGVkRGF0YSxcclxuLy8gICAgICAgfSk7XHJcblxyXG4vLyAgICAgICBzZXRCTVNEYXRhKHVwZGF0ZWREYXRhKTtcclxuLy8gICAgICAgcmV0dXJuIHRydWU7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBCTVMgZGF0YTonLCBlcnJvcik7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIEJNUyBkYXRhJyk7XHJcbi8vICAgICAgIHJldHVybiBmYWxzZTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbY29ubmVjdGVkLCBzZW5kTWVzc2FnZSwgYm1zRGF0YV0pO1xyXG5cclxuLy8gICAvLyBSZXNldCBCTVMgZGF0YVxyXG4vLyAgIGNvbnN0IHJlc2V0Qk1TRGF0YSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuLy8gICAgIGlmICghY29ubmVjdGVkKSB7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdOb3QgY29ubmVjdGVkIHRvIGNoYXJnaW5nIHN5c3RlbScpO1xyXG4vLyAgICAgICByZXR1cm47XHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzZXREYXRhOiBCTVNEYXRhID0ge1xyXG4vLyAgICAgICAgIHZvbHRhZ2U6IDAsXHJcbi8vICAgICAgICAgY3VycmVudDogMCxcclxuLy8gICAgICAgICBTT0M6IDE1LFxyXG4vLyAgICAgICAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGZhbHNlLFxyXG4vLyAgICAgICB9O1xyXG5cclxuLy8gICAgICAgc2VuZE1lc3NhZ2Uoe1xyXG4vLyAgICAgICAgIHR5cGU6ICdyZXNldEJNU0RhdGEnLFxyXG4vLyAgICAgICAgIGRhdGE6IHJlc2V0RGF0YSxcclxuLy8gICAgICAgfSk7XHJcblxyXG4vLyAgICAgICBzZXRCTVNEYXRhKHJlc2V0RGF0YSk7XHJcbi8vICAgICAgIHRvYXN0LnN1Y2Nlc3MoJ0JNUyBkYXRhIHJlc2V0Jyk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNldHRpbmcgQk1TIGRhdGE6JywgZXJyb3IpO1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignRmFpbGVkIHRvIHJlc2V0IEJNUyBkYXRhJyk7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW2Nvbm5lY3RlZCwgc2VuZE1lc3NhZ2VdKTtcclxuXHJcbi8vICAgLy8gTW9uaXRvciByZWNlaXZlciBjb2lsIGRldGVjdGlvblxyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBpZiAoYm1zRGF0YS5pc1JlY2VpdmVyQ29pbERldGVjdGVkKSB7XHJcbi8vICAgICAgIHRvYXN0LnN1Y2Nlc3MoJ1JlY2VpdmVyIGNvaWwgZGV0ZWN0ZWQnKTtcclxuLy8gICAgIH0gZWxzZSBpZiAoYm1zRGF0YS5pc1JlY2VpdmVyQ29pbERldGVjdGVkID09PSBmYWxzZSkge1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignUmVjZWl2ZXIgY29pbCBub3QgZGV0ZWN0ZWQnKTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbYm1zRGF0YS5pc1JlY2VpdmVyQ29pbERldGVjdGVkXSk7XHJcblxyXG4vLyAgIC8vIENhbGN1bGF0ZSBjaGFyZ2luZyBwb3dlclxyXG4vLyAgIGNvbnN0IGNhbGN1bGF0ZUNoYXJnaW5nUG93ZXIgPSB1c2VDYWxsYmFjaygoKTogbnVtYmVyID0+IHtcclxuLy8gICAgIHJldHVybiBibXNEYXRhLnZvbHRhZ2UgKiBibXNEYXRhLmN1cnJlbnQ7XHJcbi8vICAgfSwgW2Jtc0RhdGEudm9sdGFnZSwgYm1zRGF0YS5jdXJyZW50XSk7XHJcblxyXG4vLyAgIHJldHVybiB7XHJcbi8vICAgICBibXNEYXRhLFxyXG4vLyAgICAgdXBkYXRlQk1TRGF0YSxcclxuLy8gICAgIHJlc2V0Qk1TRGF0YSxcclxuLy8gICAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGJtc0RhdGEuaXNSZWNlaXZlckNvaWxEZXRlY3RlZCxcclxuLy8gICAgIGNoYXJnaW5nUG93ZXI6IGNhbGN1bGF0ZUNoYXJnaW5nUG93ZXIoKSxcclxuLy8gICB9O1xyXG4vLyB9XHJcblxyXG5cclxuLy8vL2ZvZFxyXG5cclxuLy8gXCJ1c2UgY2xpZW50XCI7XHJcblxyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuLy8gaW1wb3J0IHsgdXNlV2ViU29ja2V0IH0gZnJvbSAnLi4vY29udGV4dHMvV2ViU29ja2V0Q29udGV4dCc7XHJcbi8vIGltcG9ydCB7IHRvYXN0IH0gZnJvbSAnc29ubmVyJztcclxuXHJcbi8vIGludGVyZmFjZSBCTVNEYXRhIHtcclxuLy8gICB2b2x0YWdlOiBudW1iZXI7XHJcbi8vICAgY3VycmVudDogbnVtYmVyO1xyXG4vLyAgIFNPQzogbnVtYmVyO1xyXG4vLyAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGJvb2xlYW47XHJcbi8vICAgaXNGT0Q6IGJvb2xlYW47XHJcbi8vICAgaXNNaXNzOiBib29sZWFuO1xyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gdXNlQk1TRGF0YSgpIHtcclxuLy8gICBjb25zdCB7IHNlbmRNZXNzYWdlLCBsYXN0TWVzc2FnZSwgY29ubmVjdGVkLCBibXNEYXRhOiBjb250ZXh0Qk1TRGF0YSB9ID0gdXNlV2ViU29ja2V0KCk7XHJcbi8vICAgY29uc3QgW2Jtc0RhdGEsIHNldEJNU0RhdGFdID0gdXNlU3RhdGU8Qk1TRGF0YT4oe1xyXG4vLyAgICAgdm9sdGFnZTogMCxcclxuLy8gICAgIGN1cnJlbnQ6IDAsXHJcbi8vICAgICBTT0M6IDE1LFxyXG4vLyAgICAgaXNSZWNlaXZlckNvaWxEZXRlY3RlZDogZmFsc2UsXHJcbi8vICAgICBpc0ZPRDogZmFsc2UsXHJcbi8vICAgICBpc01pc3M6IGZhbHNlLFxyXG4vLyAgIH0pO1xyXG5cclxuLy8gICAvLyBVcGRhdGUgQk1TIGRhdGEgd2hlbiByZWNlaXZpbmcgbmV3IG1lc3NhZ2VzXHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIGlmIChsYXN0TWVzc2FnZT8udHlwZSA9PT0gJ2Jtc19kYXRhJyAmJiBsYXN0TWVzc2FnZS5kYXRhKSB7XHJcbi8vICAgICAgIHNldEJNU0RhdGEobGFzdE1lc3NhZ2UuZGF0YSBhcyBCTVNEYXRhKTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbbGFzdE1lc3NhZ2VdKTtcclxuXHJcbi8vICAgLy8gU3luYyB3aXRoIGNvbnRleHQgQk1TIGRhdGFcclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgc2V0Qk1TRGF0YShjb250ZXh0Qk1TRGF0YSk7XHJcbi8vICAgfSwgW2NvbnRleHRCTVNEYXRhXSk7XHJcblxyXG4vLyAgIC8vIFVwZGF0ZSBCTVMgZGF0YVxyXG4vLyAgIGNvbnN0IHVwZGF0ZUJNU0RhdGEgPSB1c2VDYWxsYmFjayhhc3luYyAobmV3RGF0YTogUGFydGlhbDxCTVNEYXRhPik6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xyXG4vLyAgICAgaWYgKCFjb25uZWN0ZWQpIHtcclxuLy8gICAgICAgdG9hc3QuZXJyb3IoJ05vdCBjb25uZWN0ZWQgdG8gY2hhcmdpbmcgc3lzdGVtJyk7XHJcbi8vICAgICAgIHJldHVybiBmYWxzZTtcclxuLy8gICAgIH1cclxuXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IHtcclxuLy8gICAgICAgICAuLi5ibXNEYXRhLFxyXG4vLyAgICAgICAgIC4uLm5ld0RhdGEsXHJcbi8vICAgICAgIH07XHJcblxyXG4vLyAgICAgICBzZW5kTWVzc2FnZSh7XHJcbi8vICAgICAgICAgdHlwZTogJ3VwZGF0ZUJNU0RhdGEnLFxyXG4vLyAgICAgICAgIGRhdGE6IHVwZGF0ZWREYXRhLFxyXG4vLyAgICAgICB9KTtcclxuXHJcbi8vICAgICAgIHNldEJNU0RhdGEodXBkYXRlZERhdGEpO1xyXG4vLyAgICAgICByZXR1cm4gdHJ1ZTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIEJNUyBkYXRhOicsIGVycm9yKTtcclxuLy8gICAgICAgdG9hc3QuZXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgQk1TIGRhdGEnKTtcclxuLy8gICAgICAgcmV0dXJuIGZhbHNlO1xyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtjb25uZWN0ZWQsIHNlbmRNZXNzYWdlLCBibXNEYXRhXSk7XHJcblxyXG4vLyAgIC8vIFJlc2V0IEJNUyBkYXRhXHJcbi8vICAgY29uc3QgcmVzZXRCTVNEYXRhID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFjb25uZWN0ZWQpIHtcclxuLy8gICAgICAgdG9hc3QuZXJyb3IoJ05vdCBjb25uZWN0ZWQgdG8gY2hhcmdpbmcgc3lzdGVtJyk7XHJcbi8vICAgICAgIHJldHVybjtcclxuLy8gICAgIH1cclxuXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCByZXNldERhdGE6IEJNU0RhdGEgPSB7XHJcbi8vICAgICAgICAgdm9sdGFnZTogMCxcclxuLy8gICAgICAgICBjdXJyZW50OiAwLFxyXG4vLyAgICAgICAgIFNPQzogMTUsXHJcbi8vICAgICAgICAgaXNSZWNlaXZlckNvaWxEZXRlY3RlZDogZmFsc2UsXHJcbi8vICAgICAgICAgaXNGT0Q6IGZhbHNlLFxyXG4vLyAgICAgICAgIGlzTWlzczogZmFsc2UsXHJcbi8vICAgICAgIH07XHJcblxyXG4vLyAgICAgICBzZW5kTWVzc2FnZSh7XHJcbi8vICAgICAgICAgdHlwZTogJ3Jlc2V0Qk1TRGF0YScsXHJcbi8vICAgICAgICAgZGF0YTogcmVzZXREYXRhLFxyXG4vLyAgICAgICB9KTtcclxuXHJcbi8vICAgICAgIHNldEJNU0RhdGEocmVzZXREYXRhKTtcclxuLy8gICAgICAgdG9hc3Quc3VjY2VzcygnQk1TIGRhdGEgcmVzZXQnKTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc2V0dGluZyBCTVMgZGF0YTonLCBlcnJvcik7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdGYWlsZWQgdG8gcmVzZXQgQk1TIGRhdGEnKTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbY29ubmVjdGVkLCBzZW5kTWVzc2FnZV0pO1xyXG5cclxuLy8gICAvLyBNb25pdG9yIHJlY2VpdmVyIGNvaWwgZGV0ZWN0aW9uXHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIGlmIChibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQpIHtcclxuLy8gICAgICAgdG9hc3Quc3VjY2VzcygnUmVjZWl2ZXIgY29pbCBkZXRlY3RlZCcpO1xyXG4vLyAgICAgfSBlbHNlIGlmIChibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQgPT09IGZhbHNlKSB7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdSZWNlaXZlciBjb2lsIG5vdCBkZXRlY3RlZCcpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWRdKTtcclxuXHJcbi8vICAgLy8gQ2FsY3VsYXRlIGNoYXJnaW5nIHBvd2VyXHJcbi8vICAgY29uc3QgY2FsY3VsYXRlQ2hhcmdpbmdQb3dlciA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xyXG4vLyAgICAgcmV0dXJuIGJtc0RhdGEudm9sdGFnZSAqIGJtc0RhdGEuY3VycmVudDtcclxuLy8gICB9LCBbYm1zRGF0YS52b2x0YWdlLCBibXNEYXRhLmN1cnJlbnRdKTtcclxuXHJcbi8vICAgcmV0dXJuIHtcclxuLy8gICAgIGJtc0RhdGEsXHJcbi8vICAgICB1cGRhdGVCTVNEYXRhLFxyXG4vLyAgICAgcmVzZXRCTVNEYXRhLFxyXG4vLyAgICAgaXNSZWNlaXZlckNvaWxEZXRlY3RlZDogYm1zRGF0YS5pc1JlY2VpdmVyQ29pbERldGVjdGVkLFxyXG4vLyAgICAgaXNGT0Q6IGJtc0RhdGEuaXNGT0QsXHJcbi8vICAgICBpc01pc3M6IGJtc0RhdGEuaXNNaXNzLFxyXG4vLyAgICAgY2hhcmdpbmdQb3dlcjogY2FsY3VsYXRlQ2hhcmdpbmdQb3dlcigpLFxyXG4vLyAgIH07XHJcbi8vIH1cclxuXHJcbi8vbWlzcyBhbGlnbm1lbnRcclxuXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgdXNlV2ViU29ja2V0IH0gZnJvbSAnLi4vY29udGV4dHMvV2ViU29ja2V0Q29udGV4dCc7XHJcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAnc29ubmVyJztcclxuXHJcbmludGVyZmFjZSBCTVNEYXRhIHtcclxuICB2b2x0YWdlOiBudW1iZXI7XHJcbiAgY3VycmVudDogbnVtYmVyO1xyXG4gIFNPQzogbnVtYmVyO1xyXG4gIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ/OiBib29sZWFuO1xyXG4gIC8vIHRhcmdldFNPQz86IG51bWJlcjtcclxuICBpc0ZPRD86IGJvb2xlYW47XHJcbiAgaXNNaXNzPzogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJNU0RhdGEoKSB7XHJcbiAgY29uc3QgeyBzZW5kTWVzc2FnZSwgbGFzdE1lc3NhZ2UsIGNvbm5lY3RlZCwgYm1zRGF0YTogY29udGV4dEJNU0RhdGEgfSA9IHVzZVdlYlNvY2tldCgpO1xyXG4gIGNvbnN0IFtibXNEYXRhLCBzZXRCTVNEYXRhXSA9IHVzZVN0YXRlPEJNU0RhdGE+KHtcclxuICAgIHZvbHRhZ2U6IDAsXHJcbiAgICBjdXJyZW50OiAwLFxyXG4gICAgU09DOiAxNSxcclxuICAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGZhbHNlLFxyXG4gICAgLy8gdGFyZ2V0U09DOiAwLFxyXG4gICAgaXNGT0Q6IGZhbHNlLFxyXG4gICAgaXNNaXNzOiBmYWxzZSxcclxuICB9KTtcclxuXHJcbiAgLy8gVXBkYXRlIEJNUyBkYXRhIHdoZW4gcmVjZWl2aW5nIG5ldyBtZXNzYWdlc1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAobGFzdE1lc3NhZ2U/LnR5cGUgPT09ICdibXNfZGF0YScgJiYgbGFzdE1lc3NhZ2UuZGF0YSkge1xyXG4gICAgICBzZXRCTVNEYXRhKGxhc3RNZXNzYWdlLmRhdGEgYXMgQk1TRGF0YSk7XHJcbiAgICB9XHJcbiAgfSwgW2xhc3RNZXNzYWdlXSk7XHJcblxyXG4gIC8vIFN5bmMgd2l0aCBjb250ZXh0IEJNUyBkYXRhXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHNldEJNU0RhdGEoY29udGV4dEJNU0RhdGEpO1xyXG4gIH0sIFtjb250ZXh0Qk1TRGF0YV0pO1xyXG5cclxuICAvLyBVcGRhdGUgQk1TIGRhdGFcclxuICBjb25zdCB1cGRhdGVCTVNEYXRhID0gdXNlQ2FsbGJhY2soYXN5bmMgKG5ld0RhdGE6IFBhcnRpYWw8Qk1TRGF0YT4pOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcclxuICAgIGlmICghY29ubmVjdGVkKSB7XHJcbiAgICAgIHRvYXN0LmVycm9yKCdOb3QgY29ubmVjdGVkIHRvIGNoYXJnaW5nIHN5c3RlbScpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSB7XHJcbiAgICAgICAgLi4uYm1zRGF0YSxcclxuICAgICAgICAuLi5uZXdEYXRhLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc2VuZE1lc3NhZ2Uoe1xyXG4gICAgICAgIHR5cGU6ICd1cGRhdGVCTVNEYXRhJyxcclxuICAgICAgICBkYXRhOiB1cGRhdGVkRGF0YSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzZXRCTVNEYXRhKHVwZGF0ZWREYXRhKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBCTVMgZGF0YTonLCBlcnJvcik7XHJcbiAgICAgIHRvYXN0LmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIEJNUyBkYXRhJyk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9LCBbY29ubmVjdGVkLCBzZW5kTWVzc2FnZSwgYm1zRGF0YV0pO1xyXG5cclxuICAvLyBSZXNldCBCTVMgZGF0YVxyXG4gIGNvbnN0IHJlc2V0Qk1TRGF0YSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmICghY29ubmVjdGVkKSB7XHJcbiAgICAgIHRvYXN0LmVycm9yKCdOb3QgY29ubmVjdGVkIHRvIGNoYXJnaW5nIHN5c3RlbScpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzZXREYXRhOiBCTVNEYXRhID0ge1xyXG4gICAgICAgIHZvbHRhZ2U6IDAsXHJcbiAgICAgICAgY3VycmVudDogMCxcclxuICAgICAgICBTT0M6IDE1LFxyXG4gICAgICAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzRk9EOiBmYWxzZSxcclxuICAgICAgICAvLyB0YXJnZXRTT0M6IDAsXHJcbiAgICAgICAgaXNNaXNzOiBmYWxzZSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNlbmRNZXNzYWdlKHtcclxuICAgICAgICB0eXBlOiAncmVzZXRCTVNEYXRhJyxcclxuICAgICAgICBkYXRhOiByZXNldERhdGEsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc2V0Qk1TRGF0YShyZXNldERhdGEpO1xyXG4gICAgICB0b2FzdC5zdWNjZXNzKCdCTVMgZGF0YSByZXNldCcpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzZXR0aW5nIEJNUyBkYXRhOicsIGVycm9yKTtcclxuICAgICAgdG9hc3QuZXJyb3IoJ0ZhaWxlZCB0byByZXNldCBCTVMgZGF0YScpO1xyXG4gICAgfVxyXG4gIH0sIFtjb25uZWN0ZWQsIHNlbmRNZXNzYWdlXSk7XHJcblxyXG4gIC8vIE1vbml0b3IgcmVjZWl2ZXIgY29pbCBkZXRlY3Rpb25cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGJtc0RhdGEuaXNSZWNlaXZlckNvaWxEZXRlY3RlZCkge1xyXG4gICAgICB0b2FzdC5zdWNjZXNzKCdSZWNlaXZlciBjb2lsIGRldGVjdGVkJyk7XHJcbiAgICB9IGVsc2UgaWYgKGJtc0RhdGEuaXNSZWNlaXZlckNvaWxEZXRlY3RlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgdG9hc3QuZXJyb3IoJ1JlY2VpdmVyIGNvaWwgbm90IGRldGVjdGVkJyk7XHJcbiAgICB9XHJcbiAgfSwgW2Jtc0RhdGEuaXNSZWNlaXZlckNvaWxEZXRlY3RlZF0pO1xyXG5cclxuICAvLyBDYWxjdWxhdGUgY2hhcmdpbmcgcG93ZXJcclxuICAvLyBjb25zdCBjYWxjdWxhdGVDaGFyZ2luZ1Bvd2VyID0gdXNlQ2FsbGJhY2soKCk6IG51bWJlciA9PiB7XHJcbiAgLy8gICByZXR1cm4gYm1zRGF0YS52b2x0YWdlICogYm1zRGF0YS5jdXJyZW50O1xyXG4gIC8vIH0sIFtibXNEYXRhLnZvbHRhZ2UsIGJtc0RhdGEuY3VycmVudF0pO1xyXG5cclxuICBjb25zdCBjYWxjdWxhdGVDaGFyZ2luZ1Bvd2VyID0gdXNlQ2FsbGJhY2soKCk6IG51bWJlciA9PiB7XHJcbiAgICBjb25zdCB7IHZvbHRhZ2UgPSAwLCBjdXJyZW50ID0gMCB9ID0gYm1zRGF0YSB8fCB7fTtcclxuICAgIGNvbnN0IHBvd2VyVyA9IHZvbHRhZ2UgKiBjdXJyZW50OyAvLyB3YXR0c1xyXG4gICAgY29uc3QgZW5lcmd5SW5jcmVtZW50ID0gKHBvd2VyVyAvIDEwMDApIC8gMzYwMDsgLy8ga1doIHBlciBzZWNvbmRcclxuICAgIHJldHVybiBOdW1iZXIoZW5lcmd5SW5jcmVtZW50LnRvRml4ZWQoNikpO1xyXG4gIH0sIFtibXNEYXRhXSk7XHJcbiAgXHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBibXNEYXRhLFxyXG4gICAgdXBkYXRlQk1TRGF0YSxcclxuICAgIHJlc2V0Qk1TRGF0YSxcclxuICAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGJtc0RhdGEuaXNSZWNlaXZlckNvaWxEZXRlY3RlZCxcclxuICAgIGlzRk9EOiBibXNEYXRhLmlzRk9ELFxyXG4gICAgaXNNaXNzOiBibXNEYXRhLmlzTWlzcyxcclxuICAgIGNoYXJnaW5nUG93ZXI6IGNhbGN1bGF0ZUNoYXJnaW5nUG93ZXIoKSxcclxuICAgIC8vIHRhcmdldEVuZXJneTogYm1zRGF0YS50YXJnZXRTT0NcclxuICB9O1xyXG59XHJcblxyXG4vLyBzb2NcclxuLy8gXCJ1c2UgY2xpZW50XCI7XHJcblxyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuLy8gaW1wb3J0IHsgdXNlV2ViU29ja2V0IH0gZnJvbSAnLi4vY29udGV4dHMvV2ViU29ja2V0Q29udGV4dCc7XHJcbi8vIGltcG9ydCB7IHRvYXN0IH0gZnJvbSAnc29ubmVyJztcclxuXHJcbi8vIGludGVyZmFjZSBCTVNEYXRhIHtcclxuLy8gICB2b2x0YWdlOiBudW1iZXI7XHJcbi8vICAgY3VycmVudDogbnVtYmVyO1xyXG4vLyAgIFNPQzogbnVtYmVyO1xyXG4vLyAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGJvb2xlYW47XHJcbi8vICAgaXNGT0Q6IGJvb2xlYW47XHJcbi8vICAgaXNNaXNzOiBib29sZWFuO1xyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gdXNlQk1TRGF0YSgpIHtcclxuLy8gICBjb25zdCB7IHNlbmRNZXNzYWdlLCBsYXN0TWVzc2FnZSwgY29ubmVjdGVkLCBibXNEYXRhOiBjb250ZXh0Qk1TRGF0YSB9ID0gdXNlV2ViU29ja2V0KCk7XHJcbi8vICAgY29uc3QgW2Jtc0RhdGEsIHNldEJNU0RhdGFdID0gdXNlU3RhdGU8Qk1TRGF0YT4oe1xyXG4vLyAgICAgdm9sdGFnZTogMCxcclxuLy8gICAgIGN1cnJlbnQ6IDAsXHJcbi8vICAgICBTT0M6IDE1LFxyXG4vLyAgICAgaXNSZWNlaXZlckNvaWxEZXRlY3RlZDogZmFsc2UsXHJcbi8vICAgICBpc0ZPRDogZmFsc2UsXHJcbi8vICAgICBpc01pc3M6IGZhbHNlLFxyXG4vLyAgIH0pO1xyXG5cclxuLy8gICAvLyBVcGRhdGUgQk1TIGRhdGEgd2hlbiByZWNlaXZpbmcgbmV3IG1lc3NhZ2VzXHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIGlmIChsYXN0TWVzc2FnZT8udHlwZSA9PT0gJ2Jtc19kYXRhJyAmJiBsYXN0TWVzc2FnZS5kYXRhKSB7XHJcbi8vICAgICAgIHNldEJNU0RhdGEobGFzdE1lc3NhZ2UuZGF0YSBhcyBCTVNEYXRhKTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbbGFzdE1lc3NhZ2VdKTtcclxuXHJcbi8vICAgLy8gU3luYyB3aXRoIGNvbnRleHQgQk1TIGRhdGFcclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgc2V0Qk1TRGF0YShjb250ZXh0Qk1TRGF0YSk7XHJcbi8vICAgfSwgW2NvbnRleHRCTVNEYXRhXSk7XHJcblxyXG4vLyAgIC8vIFVwZGF0ZSBCTVMgZGF0YVxyXG4vLyAgIGNvbnN0IHVwZGF0ZUJNU0RhdGEgPSB1c2VDYWxsYmFjayhhc3luYyAobmV3RGF0YTogUGFydGlhbDxCTVNEYXRhPik6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xyXG4vLyAgICAgaWYgKCFjb25uZWN0ZWQpIHtcclxuLy8gICAgICAgdG9hc3QuZXJyb3IoJ05vdCBjb25uZWN0ZWQgdG8gY2hhcmdpbmcgc3lzdGVtJyk7XHJcbi8vICAgICAgIHJldHVybiBmYWxzZTtcclxuLy8gICAgIH1cclxuXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IHtcclxuLy8gICAgICAgICAuLi5ibXNEYXRhLFxyXG4vLyAgICAgICAgIC4uLm5ld0RhdGEsXHJcbi8vICAgICAgIH07XHJcblxyXG4vLyAgICAgICBzZW5kTWVzc2FnZSh7XHJcbi8vICAgICAgICAgdHlwZTogJ3VwZGF0ZUJNU0RhdGEnLFxyXG4vLyAgICAgICAgIGRhdGE6IHVwZGF0ZWREYXRhLFxyXG4vLyAgICAgICB9KTtcclxuXHJcbi8vICAgICAgIHNldEJNU0RhdGEodXBkYXRlZERhdGEpO1xyXG4vLyAgICAgICByZXR1cm4gdHJ1ZTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIEJNUyBkYXRhOicsIGVycm9yKTtcclxuLy8gICAgICAgdG9hc3QuZXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgQk1TIGRhdGEnKTtcclxuLy8gICAgICAgcmV0dXJuIGZhbHNlO1xyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtjb25uZWN0ZWQsIHNlbmRNZXNzYWdlLCBibXNEYXRhXSk7XHJcblxyXG4vLyAgIC8vIFJlc2V0IEJNUyBkYXRhXHJcbi8vICAgY29uc3QgcmVzZXRCTVNEYXRhID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFjb25uZWN0ZWQpIHtcclxuLy8gICAgICAgdG9hc3QuZXJyb3IoJ05vdCBjb25uZWN0ZWQgdG8gY2hhcmdpbmcgc3lzdGVtJyk7XHJcbi8vICAgICAgIHJldHVybjtcclxuLy8gICAgIH1cclxuXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCByZXNldERhdGE6IEJNU0RhdGEgPSB7XHJcbi8vICAgICAgICAgdm9sdGFnZTogMCxcclxuLy8gICAgICAgICBjdXJyZW50OiAwLFxyXG4vLyAgICAgICAgIFNPQzogMTUsXHJcbi8vICAgICAgICAgaXNSZWNlaXZlckNvaWxEZXRlY3RlZDogZmFsc2UsXHJcbi8vICAgICAgICAgaXNGT0Q6IGZhbHNlLFxyXG4vLyAgICAgICAgIGlzTWlzczogZmFsc2UsXHJcbi8vICAgICAgIH07XHJcblxyXG4vLyAgICAgICBzZW5kTWVzc2FnZSh7XHJcbi8vICAgICAgICAgdHlwZTogJ3Jlc2V0Qk1TRGF0YScsXHJcbi8vICAgICAgICAgZGF0YTogcmVzZXREYXRhLFxyXG4vLyAgICAgICB9KTtcclxuXHJcbi8vICAgICAgIHNldEJNU0RhdGEocmVzZXREYXRhKTtcclxuLy8gICAgICAgdG9hc3Quc3VjY2VzcygnQk1TIGRhdGEgcmVzZXQnKTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc2V0dGluZyBCTVMgZGF0YTonLCBlcnJvcik7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdGYWlsZWQgdG8gcmVzZXQgQk1TIGRhdGEnKTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbY29ubmVjdGVkLCBzZW5kTWVzc2FnZV0pO1xyXG5cclxuLy8gICAvLyBNb25pdG9yIHJlY2VpdmVyIGNvaWwgZGV0ZWN0aW9uXHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIGlmIChibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQpIHtcclxuLy8gICAgICAgdG9hc3Quc3VjY2VzcygnUmVjZWl2ZXIgY29pbCBkZXRlY3RlZCcpO1xyXG4vLyAgICAgfSBlbHNlIGlmIChibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQgPT09IGZhbHNlKSB7XHJcbi8vICAgICAgIHRvYXN0LmVycm9yKCdSZWNlaXZlciBjb2lsIG5vdCBkZXRlY3RlZCcpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtibXNEYXRhLmlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWRdKTtcclxuXHJcbi8vICAgLy8gQ2FsY3VsYXRlIGNoYXJnaW5nIHBvd2VyXHJcbi8vICAgY29uc3QgY2FsY3VsYXRlQ2hhcmdpbmdQb3dlciA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xyXG4vLyAgICAgcmV0dXJuIGJtc0RhdGEudm9sdGFnZSAqIGJtc0RhdGEuY3VycmVudDtcclxuLy8gICB9LCBbYm1zRGF0YS52b2x0YWdlLCBibXNEYXRhLmN1cnJlbnRdKTtcclxuXHJcbi8vICAgcmV0dXJuIHtcclxuLy8gICAgIGJtc0RhdGEsXHJcbi8vICAgICB1cGRhdGVCTVNEYXRhLFxyXG4vLyAgICAgcmVzZXRCTVNEYXRhLFxyXG4vLyAgICAgaXNSZWNlaXZlckNvaWxEZXRlY3RlZDogYm1zRGF0YS5pc1JlY2VpdmVyQ29pbERldGVjdGVkLFxyXG4vLyAgICAgaXNGT0Q6IGJtc0RhdGEuaXNGT0QsXHJcbi8vICAgICBpc01pc3M6IGJtc0RhdGEuaXNNaXNzLFxyXG4vLyAgICAgY2hhcmdpbmdQb3dlcjogY2FsY3VsYXRlQ2hhcmdpbmdQb3dlcigpLFxyXG4vLyAgIH07XHJcbi8vIH1cclxuXHJcbi8vc29jXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG5cclxuLy8gaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbi8vIGltcG9ydCB7IHVzZVdlYlNvY2tldCB9IGZyb20gJy4uL2NvbnRleHRzL1dlYlNvY2tldENvbnRleHQnO1xyXG4vLyBpbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3Nvbm5lcic7XHJcblxyXG4vLyBpbnRlcmZhY2UgQk1TRGF0YSB7XHJcbi8vICAgdm9sdGFnZTogbnVtYmVyO1xyXG4vLyAgIGN1cnJlbnQ6IG51bWJlcjtcclxuLy8gICBTT0M6IG51bWJlcjtcclxuLy8gICB0YXJnZXRTT0M6IG51bWJlcjsgLy8g4pyFIEFkZGVkIHRhcmdldFNPQ1xyXG4vLyAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGJvb2xlYW47XHJcbi8vICAgaXNGT0Q6IGJvb2xlYW47XHJcbi8vICAgaXNNaXNzOiBib29sZWFuO1xyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gdXNlQk1TRGF0YSgpIHtcclxuLy8gICBjb25zdCB7IHNlbmRNZXNzYWdlLCBsYXN0TWVzc2FnZSwgY29ubmVjdGVkLCBibXNEYXRhOiBjb250ZXh0Qk1TRGF0YSB9ID0gdXNlV2ViU29ja2V0KCk7XHJcbi8vICAgY29uc3QgW2Jtc0RhdGEsIHNldEJNU0RhdGFdID0gdXNlU3RhdGU8Qk1TRGF0YT4oe1xyXG4vLyAgICAgdm9sdGFnZTogMCxcclxuLy8gICAgIGN1cnJlbnQ6IDAsXHJcbi8vICAgICBTT0M6IDE1LFxyXG4vLyAgICAgdGFyZ2V0U09DOiAxMDAsIC8vIOKchSBEZWZhdWx0IHZhbHVlXHJcbi8vICAgICBpc1JlY2VpdmVyQ29pbERldGVjdGVkOiBmYWxzZSxcclxuLy8gICAgIGlzRk9EOiBmYWxzZSxcclxuLy8gICAgIGlzTWlzczogZmFsc2UsXHJcbi8vICAgfSk7XHJcblxyXG4vLyAgIC8vIFVwZGF0ZSBCTVMgZGF0YSB3aGVuIHJlY2VpdmluZyBuZXcgbWVzc2FnZXNcclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgaWYgKGxhc3RNZXNzYWdlPy50eXBlID09PSAnYm1zX2RhdGEnICYmIGxhc3RNZXNzYWdlLmRhdGEpIHtcclxuLy8gICAgICAgc2V0Qk1TRGF0YShsYXN0TWVzc2FnZS5kYXRhIGFzIEJNU0RhdGEpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtsYXN0TWVzc2FnZV0pO1xyXG5cclxuLy8gICAvLyBTeW5jIHdpdGggY29udGV4dCBCTVMgZGF0YVxyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBzZXRCTVNEYXRhKGNvbnRleHRCTVNEYXRhKTtcclxuLy8gICB9LCBbY29udGV4dEJNU0RhdGFdKTtcclxuXHJcbi8vICAgLy8gVXBkYXRlIEJNUyBkYXRhIChpbmNsdWRpbmcgdGFyZ2V0U09DKVxyXG4vLyAgIGNvbnN0IHVwZGF0ZUJNU0RhdGEgPSB1c2VDYWxsYmFjayhhc3luYyAobmV3RGF0YTogUGFydGlhbDxCTVNEYXRhPik6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xyXG4vLyAgICAgaWYgKCFjb25uZWN0ZWQpIHtcclxuLy8gICAgICAgdG9hc3QuZXJyb3IoJ05vdCBjb25uZWN0ZWQgdG8gY2hhcmdpbmcgc3lzdGVtJyk7XHJcbi8vICAgICAgIHJldHVybiBmYWxzZTtcclxuLy8gICAgIH1cclxuXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IHtcclxuLy8gICAgICAgICAuLi5ibXNEYXRhLFxyXG4vLyAgICAgICAgIC4uLm5ld0RhdGEsXHJcbi8vICAgICAgIH07XHJcblxyXG4vLyAgICAgICAvLyBVc2UgYSBjb25zaXN0ZW50IG1lc3NhZ2UgdHlwZSBmb3IgYm1zX2RhdGFcclxuLy8gICAgICAgc2VuZE1lc3NhZ2Uoe1xyXG4vLyAgICAgICAgIHR5cGU6ICdibXNfZGF0YScsXHJcbi8vICAgICAgICAgZGF0YTogdXBkYXRlZERhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgc2V0Qk1TRGF0YSh1cGRhdGVkRGF0YSk7XHJcbi8vICAgICAgIHJldHVybiB0cnVlO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgQk1TIGRhdGE6JywgZXJyb3IpO1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBCTVMgZGF0YScpO1xyXG4vLyAgICAgICByZXR1cm4gZmFsc2U7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW2Nvbm5lY3RlZCwgc2VuZE1lc3NhZ2UsIGJtc0RhdGFdKTtcclxuXHJcbi8vICAgLy8gUmVzZXQgQk1TIGRhdGFcclxuLy8gICBjb25zdCByZXNldEJNU0RhdGEgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbi8vICAgICBpZiAoIWNvbm5lY3RlZCkge1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignTm90IGNvbm5lY3RlZCB0byBjaGFyZ2luZyBzeXN0ZW0nKTtcclxuLy8gICAgICAgcmV0dXJuO1xyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc2V0RGF0YTogQk1TRGF0YSA9IHtcclxuLy8gICAgICAgICB2b2x0YWdlOiAwLFxyXG4vLyAgICAgICAgIGN1cnJlbnQ6IDAsXHJcbi8vICAgICAgICAgU09DOiAxNSxcclxuLy8gICAgICAgICB0YXJnZXRTT0M6IDEwMCxcclxuLy8gICAgICAgICBpc1JlY2VpdmVyQ29pbERldGVjdGVkOiBmYWxzZSxcclxuLy8gICAgICAgICBpc0ZPRDogZmFsc2UsXHJcbi8vICAgICAgICAgaXNNaXNzOiBmYWxzZSxcclxuLy8gICAgICAgfTtcclxuXHJcbi8vICAgICAgIHNlbmRNZXNzYWdlKHtcclxuLy8gICAgICAgICB0eXBlOiAnYm1zX2RhdGEnLFxyXG4vLyAgICAgICAgIGRhdGE6IHJlc2V0RGF0YSxcclxuLy8gICAgICAgfSk7XHJcblxyXG4vLyAgICAgICBzZXRCTVNEYXRhKHJlc2V0RGF0YSk7XHJcbi8vICAgICAgIHRvYXN0LnN1Y2Nlc3MoJ0JNUyBkYXRhIHJlc2V0Jyk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNldHRpbmcgQk1TIGRhdGE6JywgZXJyb3IpO1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignRmFpbGVkIHRvIHJlc2V0IEJNUyBkYXRhJyk7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW2Nvbm5lY3RlZCwgc2VuZE1lc3NhZ2VdKTtcclxuXHJcbi8vICAgLy8gTW9uaXRvciByZWNlaXZlciBjb2lsIGRldGVjdGlvblxyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBpZiAoYm1zRGF0YS5pc1JlY2VpdmVyQ29pbERldGVjdGVkKSB7XHJcbi8vICAgICAgIHRvYXN0LnN1Y2Nlc3MoJ1JlY2VpdmVyIGNvaWwgZGV0ZWN0ZWQnKTtcclxuLy8gICAgIH0gZWxzZSBpZiAoYm1zRGF0YS5pc1JlY2VpdmVyQ29pbERldGVjdGVkID09PSBmYWxzZSkge1xyXG4vLyAgICAgICB0b2FzdC5lcnJvcignUmVjZWl2ZXIgY29pbCBub3QgZGV0ZWN0ZWQnKTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbYm1zRGF0YS5pc1JlY2VpdmVyQ29pbERldGVjdGVkXSk7XHJcblxyXG4vLyAgIC8vIENhbGN1bGF0ZSBjaGFyZ2luZyBwb3dlclxyXG4vLyAgIGNvbnN0IGNhbGN1bGF0ZUNoYXJnaW5nUG93ZXIgPSB1c2VDYWxsYmFjaygoKTogbnVtYmVyID0+IHtcclxuLy8gICAgIHJldHVybiBibXNEYXRhLnZvbHRhZ2UgKiBibXNEYXRhLmN1cnJlbnQ7XHJcbi8vICAgfSwgW2Jtc0RhdGEudm9sdGFnZSwgYm1zRGF0YS5jdXJyZW50XSk7XHJcblxyXG4vLyAgIHJldHVybiB7XHJcbi8vICAgICBibXNEYXRhLFxyXG4vLyAgICAgdXBkYXRlQk1TRGF0YSxcclxuLy8gICAgIHJlc2V0Qk1TRGF0YSxcclxuLy8gICAgIGlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQ6IGJtc0RhdGEuaXNSZWNlaXZlckNvaWxEZXRlY3RlZCxcclxuLy8gICAgIGlzRk9EOiBibXNEYXRhLmlzRk9ELFxyXG4vLyAgICAgaXNNaXNzOiBibXNEYXRhLmlzTWlzcyxcclxuLy8gICAgIGNoYXJnaW5nUG93ZXI6IGNhbGN1bGF0ZUNoYXJnaW5nUG93ZXIoKSxcclxuLy8gICB9O1xyXG4vLyB9XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwidXNlV2ViU29ja2V0IiwidG9hc3QiLCJ1c2VCTVNEYXRhIiwic2VuZE1lc3NhZ2UiLCJsYXN0TWVzc2FnZSIsImNvbm5lY3RlZCIsImJtc0RhdGEiLCJjb250ZXh0Qk1TRGF0YSIsInNldEJNU0RhdGEiLCJ2b2x0YWdlIiwiY3VycmVudCIsIlNPQyIsImlzUmVjZWl2ZXJDb2lsRGV0ZWN0ZWQiLCJpc0ZPRCIsImlzTWlzcyIsInR5cGUiLCJkYXRhIiwidXBkYXRlQk1TRGF0YSIsIm5ld0RhdGEiLCJlcnJvciIsInVwZGF0ZWREYXRhIiwiY29uc29sZSIsInJlc2V0Qk1TRGF0YSIsInJlc2V0RGF0YSIsInN1Y2Nlc3MiLCJjYWxjdWxhdGVDaGFyZ2luZ1Bvd2VyIiwicG93ZXJXIiwiZW5lcmd5SW5jcmVtZW50IiwiTnVtYmVyIiwidG9GaXhlZCIsImNoYXJnaW5nUG93ZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useBMSData.ts\n"));

/***/ })

});